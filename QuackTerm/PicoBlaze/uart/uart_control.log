KCPSM6 Assembler log file for program 'C:\Users\equack\Documents\Xilinx\DVI-1080p\dvid_test_hd\PicoBlaze\uart_control.psm'.
Generated by KCPSM6 version v2.70
Ken Chapman - Xilinx Ltd - 16th May 2014

Assembly datestamp: 15 Apr 2017
Assembly timestamp: 12:47:09

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: 78F hex
Nominal program memory size: 2K (2048)   address(10:0)
Actual memory size: 2048
  (Memory size defined by -c option)
Occupied memory locations: 1936
Memory locations available: 112


Assembly listing

 Addr Code                              Instruction

 000                                    ;Copyright (C) 2017 Erik C. Quackenbush erikcq@quackenbush.com
 000                                    ;
 000                                    ; this is an ANSI terminal emulation program.
 000                                    ;
 000                                    ; this Picoblaze-6 program implements an ANSI display terminal which talks to a host over the USB to serial
 000                                    ; converter and generates an HDMI 120x67 (or 80x50) character display with input from a PS/2 keyboard.
 000                                    ; these are the extended key codes. They're prefixed with 0xE0
 000                                    ; from the PS/2 keyboard
 000                                    CONSTANT EXTKEY_END, 69
 000                                    CONSTANT EXTKEY_LEFT, 6B
 000                                    CONSTANT EXTKEY_HOME, 6C
 000                                    CONSTANT EXTKEY_INSERT, 70
 000                                    CONSTANT EXTKEY_DELETE, 71
 000                                    CONSTANT EXTKEY_DOWN, 72
 000                                    CONSTANT EXTKEY_RIGHT, 74
 000                                    CONSTANT EXTKEY_UP, 75
 000                                    CONSTANT EXTKEY_PGDN, 7A
 000                                    CONSTANT EXTKEY_PGUP, 7D
 000                                    CONSTANT EXTKEY_KEYPAD_ENTER, 5A               ; keypad enter- this is an EXTKEY unlike the other KEYPAD keys (the non ext-key is the standard ENTER)
 000                                    CONSTANT EXTKEY_KEYPAD_SLASH, 4A               ; keypad forward slash (divide). This is also an EXTKEY (the non ext-key is the standard slash)
 000                                    CONSTANT EXTKEY_WINDOWS, 5B
 000                                    CONSTANT EXTKEY_MENU, 5C
 000                                    CONSTANT EXTKEY_RIGHT_ALT, 11
 000                                    CONSTANT EXTKEY_PRINT_SCREEN, 12               ; two codes are send when you press printf screen, but they're both unique. we only need to watch for this first one
 000                                    CONSTANT EXTKEY_PRINT_SCREEN2, 7C              ;
 000                                    CONSTANT KEYPAD_END, 69
 000                                    CONSTANT KEYPAD_LEFT, 6B
 000                                    CONSTANT KEYPAD_HOME, 6C
 000                                    CONSTANT KEYPAD_INSERT, 70
 000                                    CONSTANT KEYPAD_DELETE, 71
 000                                    CONSTANT KEYPAD_DOWN, 72
 000                                    CONSTANT KEYPAD_DEAD, 73                       ; this is the 5 key.
 000                                    CONSTANT KEYPAD_RIGHT, 74
 000                                    CONSTANT KEYPAD_UP, 75
 000                                    CONSTANT KEYPAD_PGDN, 7A
 000                                    CONSTANT KEYPAD_PGUP, 7D
 000                                    CONSTANT PAUSE_BREAK_PREFIX, E1                ; this isn't quite an EXTKEY. We get an E1 code prefix which we ignore.
 000                                    ;
 000                                    ; these are the modifier keys. The alt and control keys can optionally be prefixed with 0xE0
 000                                    ; from the PS/2 keyboard which indicates that it's the right ctrl or right alt key.
 000                                    CONSTANT KEY_LEFT_SHIFT, 12
 000                                    CONSTANT KEY_RIGHT_SHIFT, 59
 000                                    CONSTANT KEY_LEFT_CONTROL, 14
 000                                    CONSTANT KEY_LEFT_ALT, 11
 000                                    CONSTANT KEY_RIGHT_CONTROL, 14                 ; same as left but with extended flag set
 000                                    CONSTANT KEY_RIGHT_ALT, 11                     ; same as left but with extended flag set
 000                                    CONSTANT KEY_CAPSLOCK, 58
 000                                    CONSTANT KEY_NUMLOCK, 77
 000                                    CONSTANT KEY_SCROLLLOCK, 7E
 000                                    ; these are the function keys
 000                                    CONSTANT KEY_F1, 05
 000                                    CONSTANT KEY_F2, 06
 000                                    CONSTANT KEY_F3, 04
 000                                    CONSTANT KEY_F4, 0C
 000                                    CONSTANT KEY_F5, 03
 000                                    CONSTANT KEY_F6, 0B
 000                                    CONSTANT KEY_F7, 83
 000                                    CONSTANT KEY_F8, 0A
 000                                    CONSTANT KEY_F9, 01
 000                                    CONSTANT KEY_F10, 09
 000                                    CONSTANT KEY_F11, 78
 000                                    CONSTANT KEY_F12, 07
 000                                    ; cursor positions in video memory. MAX_LINE_upper/lower is one character beyond the last visible character
 000                                    ; in the last line of the screen. LAST_LINE is the first character of the last line on the screen
 000                                    ; MAX_LINE is the number of lines on the screen.
 000                                    ;
 000                                    ; these constants will have different values for 80 versus 120 column mode.
 000                                    ;
 000                                    ; these values are for a 120x67 character screen.
 000                                    CONSTANT MAX_LINE_LOWER, 68                    ; address of last character of last line +1
 000                                    CONSTANT MAX_LINE_UPPER, 1F                    ; address of last character of last line +1
 000                                    CONSTANT LAST_LINE_LOWER, F0                   ; address of first character on last line
 000                                    CONSTANT LAST_LINE_UPPER, 1E                   ; address of first character on last line
 000                                    CONSTANT MAX_LINE, 43                          ; 67 decimal lines (could be 0x32 for 50 lines or 0x18 for 24 lines)
 000                                    ; CONSTANT MAX_CHAR_80_50, 0FA0
 000                                    ; CONSTANT LAST_LINE_80_50 0F50
 000                                    ; RAM ADDRESS assignments
 000                                    ; this is our memory map.
 000                                    CONSTANT scratchLOW, 00
 000                                    CONSTANT scratchHIGH, 01
 000                                    CONSTANT decimal0, 02                          ;  5 digit decimal value
 000                                    CONSTANT decimal1, 03                          ;  Suitable for 16-bit values up to
 000                                    CONSTANT decimal2, 04                          ;  65,536, used to print integer values
 000                                    CONSTANT decimal3, 05
 000                                    CONSTANT decimal4, 06
 000                                    CONSTANT param_counter, 07                     ; the number of CSI parameters is stored in 0x07
 000                                    CONSTANT param_block, 08                       ; the parameter block is stored at location 0x08-0x0F
 000                                    CONSTANT param_two, 09                         ; second parameter
 000                                    CONSTANT max_param, 10                         ; the last valid entry in the parameter block is 0x0F (0x10-1)
 000                                    CONSTANT digit_counter, 11                     ; the number of digits in the current parameter (so far) is stored in 0x11
 000                                    CONSTANT digit_block, 12                       ; the string of digits
 000                                    CONSTANT max_digit, 05                         ; we only allow 4 digit decimal parameters & we only process three of those digits. (this is not a RAM location)
 000                                    CONSTANT hidden_color, 17                      ; this is what our foreground color was before we hid it
 000                                    CONSTANT extra_flags, 18                       ; assorted lesser used flag bits
 000                                    CONSTANT RAM_19, 19
 000                                    CONSTANT RAM_1A, 1A                            ; these are unused
 000                                    CONSTANT RAM_1B, 1B
 000                                    CONSTANT RAM_1C, 1C
 000                                    CONSTANT RAM_1D, 1D
 000                                    CONSTANT offset_low, 1E                        ; scrolling offset used for hardware scrolling
 000                                    CONSTANT offset_high, 1F                       ; this address gets added in hardware to the cursor address.
 000                                    CONSTANT mode_flags, 30
 000                                    CONSTANT last_char, 31                         ; the last character transmitted
 000                                    CONSTANT saved_cursor_low, 32
 000                                    CONSTANT saved_cursor_high, 33
 000                                    CONSTANT saved_color_reg, 34
 000                                    CONSTANT saved_ansi_reg, 35
 000                                    CONSTANT scratchQ, 36
 000                                    CONSTANT scratchR, 37
 000                                    CONSTANT scratchS, 38
 000                                    CONSTANT scratchT, 39
 000                                    CONSTANT scratchU, 3A
 000                                    CONSTANT scratchV, 3B
 000                                    CONSTANT scratchW, 3C
 000                                    CONSTANT scratchX, 3D
 000                                    CONSTANT scratchY, 3E
 000                                    CONSTANT scratchZ, 3F                          ; the top of memory unless we change the picoblaze-6 generic in VHDL
 000                                    CONSTANT MODE_TALL, 01                         ; these bits define the video mode.
 000                                    CONSTANT MODE_EIGHTY, 02
 000                                    CONSTANT MODE_FIFTY, 04
 000                                    CONSTANT MODE_CAPS_LOCK, 08                    ; these bits define the state of the keyboard LEDs
 000                                    CONSTANT MODE_NUM_LOCK, 10
 000                                    CONSTANT MODE_SCROLL_LOCK, 20
 000                                    CONSTANT MODE_40, 40                           ; these bits are reserved.
 000                                    CONSTANT MODE_80, 80
 000                                    CONSTANT MODE_CAPS_LOCK_CLR, F7
 000                                    CONSTANT MODE_NUM_LOCK_CLR, EF
 000                                    CONSTANT MODE_SCROLL_LOCK_CLR, DF
 000                                    ; 0x00  120x67 * default
 000                                    ; 0x01  120x33
 000                                    ; 0x02   80x67
 000                                    ; 0x03   80x33
 000                                    ; 0x04  120x50
 000                                    ; 0x05  120x25
 000                                    ; 0x06  80x50
 000                                    ; 0x07  80x25
 000                                    ; special control keys (some are also shifted)
 000                                    ; these control key combinations produce the missing control characters
 000                                    ; after control-Z.
 000                                    ;
 000                                    ; ctrl-@ 00 (NULL) control at sign
 000                                    ; ctrl-[ 1B (escape) control open bracket
 000                                    ; ctrl-\ 1C control backslash
 000                                    ; ctrl-] 1D control close bracket
 000                                    ; ctrl-^ 1E control caret
 000                                    ; ctrl-_ 1F control underscore
 000                                    ; ctrl-? 7F (delete) control question mark
 000                                    ; these are the I/O port addresses.
 000                                    ;
 000                                    CONSTANT MSB_PORT, 02                          ; write the MSB of the cursor position here
 000                                    CONSTANT LSB_PORT, 03                          ; write the LSB of the cursor position here
 000                                    CONSTANT CHAR_PORT, 04                         ; write the character value here
 000                                    CONSTANT CHAR_READ_PORT, 05                    ; read the character value here
 000                                    CONSTANT PS2_READ_PORT, 06                     ; read scan codes from the PS/2 keyboard here
 000                                    CONSTANT PS2_STATUS_PORT, 07                   ; bit(0) is empty, bit(1) is full (FIFO status)
 000                                    CONSTANT ATTR_PORT, 09                         ; write to this to set the colors
 000                                    CONSTANT ATTR_READ_PORT, 0A                    ; read from this to see the colors
 000                                    CONSTANT MODE_PORT, 0B                         ; sets the video mode bits (120/80,50/25,50/67)
 000                                    CONSTANT UART_STATUS_PORT, 0C
 000                                    CONSTANT UART_READ_FIFO_PORT, 0D
 000                                    CONSTANT UART_FIFO_EMPTY, 01
 000                                    CONSTANT UART_FIFO_FULL, 02
 000                                    CONSTANT OFFSET_MSB_PORT, 0E                   ; scrolling offset gets added to the cursor address
 000                                    CONSTANT OFFSET_LSB_PORT, 0F                   ; so try to set these to a multiple of CHAR_PER_LINE
 000                                    CONSTANT TYPEMATIC_PORT, 10                    ; sets the keyboard typematic rate
 000                                    ; KEY_FLAG_REG contains these keyboard state flag bits
 000                                    ; OR these with the register to set the bits
 000                                    CONSTANT KEY_RELEASE, 01                       ; did this key have a release (F0) prefix?
 000                                    CONSTANT LEFT_SHIFT, 02
 000                                    CONSTANT RIGHT_SHIFT, 04
 000                                    CONSTANT EITHER_SHIFT, 06
 000                                    CONSTANT LEFT_ALT, 08
 000                                    CONSTANT RIGHT_ALT, 10
 000                                    CONSTANT EITHER_ALT, 18
 000                                    CONSTANT LEFT_CONTROL, 20
 000                                    CONSTANT RIGHT_CONTROL, 40
 000                                    CONSTANT EITHER_CONTROL, 60
 000                                    CONSTANT EXTENDED, 80                          ; is this an extended code prefixed by 0xE0?
 000                                    ; AND these with the register to clear the bits
 000                                    CONSTANT KEY_RELEASE_CLR, FE
 000                                    CONSTANT LEFT_SHIFT_CLR, FD
 000                                    CONSTANT RIGHT_SHIFT_CLR, FB
 000                                    CONSTANT LEFT_ALT_CLR, F7
 000                                    CONSTANT RIGHT_ALT_CLR, EF
 000                                    CONSTANT LEFT_CONTROL_CLR, DF
 000                                    CONSTANT RIGHT_CONTROL_CLR, BF
 000                                    CONSTANT EXTENDED_CLR, 7F
 000                                    CONSTANT RELEASE_EXT_CLR, 7E                   ; clear both the extended and release flags
 000                                    ; ANSI_FLAG_REG contains these command processing state flag bigs
 000                                    ; OR these with the register to set the bits
 000                                    CONSTANT ANSI_CSI, 01                          ; did we receive an ESC followed by a [ prefix?
 000                                    CONSTANT ANSI_ESCAPE, 02                       ; did we receive an ESC prefix?
 000                                    CONSTANT ANSI_ESC_CSI, 03                      ; either ESC and/or CSI
 000                                    CONSTANT ANSI_INVERSE, 04                      ; are the foreground and background colors revered?
 000                                    CONSTANT ANSI_HIDDEN, 08                       ; is the foreground color set to the background color?
 000                                    CONSTANT ANSI_SSG2, 10                         ; is the next character to be printed RAW?
 000                                    CONSTANT ANSI_SCROLL_LOCK, 20                  ; state of the scroll lock flag (toggles)
 000                                    CONSTANT ANSI_NUM_LOCK, 40                     ; state of the num lock flag (toggles)
 000                                    CONSTANT ANSI_CAPS_LOCK, 80                    ; currently unused
 000                                    ; AND these with the register to clear the bits
 000                                    CONSTANT ANSI_CSI_CLR, FE
 000                                    CONSTANT ANSI_ESCAPE_CLR, FD
 000                                    CONSTANT ANSI_INVERSE_CLR, FB
 000                                    CONSTANT ANSI_HIDDEN_CLR, F7
 000                                    CONSTANT ANSI_SSG2_CLR, EF
 000                                    CONSTANT ANSI_SCROLL_LOCK_CLR, DF
 000                                    CONSTANT ANSI_NUM_LOCK_CLR, BF
 000                                    CONSTANT ANSI_CAPS_LOCK_CLR, 7F
 000                                    ; extra flag bits (stored in RAM)
 000                                    CONSTANT EXTRA_DEBUG, 01                       ; we output characters RAW for debugging
 000                                    CONSTANT EXTRA_NETHACK, 02                     ; numeric keypad is in nethack navigation mode
 000                                    CONSTANT EXTRA_VT_GRAPHICS, 04                 ; VT100 graphics characters instead of lower case
 000                                    CONSTANT EXTRA_VT_GRAPHICS_CLR, FB
 000                                    CONSTANT EXTRA_NETHACK_CLR, FE
 000                                    CONSTANT EXTRA_DEBUG_CLR, FF
 000                                    ; a few special characters
 000                                    CONSTANT ENQ_CHAR, 05
 000                                    CONSTANT ACK_CHAR, 06
 000                                    CONSTANT BEL_CHAR, 07
 000                                    CONSTANT TAB_CHAR, 09
 000                                    CONSTANT FORM_FEED_CHAR, 0C
 000                                    CONSTANT ESC_CHAR, 1B
 000                                    CONSTANT RUBOUT_CHAR, 7F
 000                                    ;
 000                                    ; registers s0 and s1 are used for local scratch.
 000                                    ; registers s4 and s5 are used for parameters
 000                                    ;
 000                                    ; registers sE is used as the column position (remainder)
 000                                    ; registers sE and sF are used for copies.
 000                                    ;
 000                                    NAMEREG s2, DIVIDEND_LOW
 000                                    NAMEREG s3, DIVIDEND_HIGH
 000                                    NAMEREG s6, COLOR_REG
 000                                    NAMEREG s7, KEY_FLAG_REG
 000                                    NAMEREG s8, DIVISOR_LOW
 000                                    NAMEREG s9, DIVISOR_HIGH
 000                                    NAMEREG sA, CURSOR_HIGH
 000                                    NAMEREG sB, CURSOR_LOW
 000                                    NAMEREG sC, ANSI_FLAG_REG
 000                                    NAMEREG sD, CHAR_PER_LINE
 000                                    ;------------------------------------------------------------------------------------------
 000                                    ; Main Program
 000                                    ;------------------------------------------------------------------------------------------
 000                        cold_start: 
 000  20002                             CALL 002[init_terminal]
 001  22029                             JUMP 029[echo_loop]
 002                     init_terminal: 
 002  20788                             CALL 788[reset_UART_macros]                    ; Reset buffers in UART macros
 003  01D78                             LOAD sD[CHAR_PER_LINE], 78                     ; we default to 120 columns
 004  01700                             LOAD s7[KEY_FLAG_REG], 00                      ; set keyboard flags to zero
 005  01C00                             LOAD sC[ANSI_FLAG_REG], 00                     ; set ANSI parsing flags
 006  2FC35                             STORE sC[ANSI_FLAG_REG], 35[saved_ansi_reg]
 007  01000                             LOAD s0, 00
 008  2F032                             STORE s0, 32[saved_cursor_low]
 009  2F033                             STORE s0, 33[saved_cursor_high]
 00A  2F031                             STORE s0, 31[last_char]                        ; set last character to NULL
 00B  2F018                             STORE s0, 18[extra_flags]                      ; set debug flag to zero
 00C  2F030                             STORE s0, 30[mode_flags]                       ; set video mode to 120x67
 00D  2D00B                             OUTPUT s0, 0B[MODE_PORT]
 00E  01001                             LOAD s0, 01                                    ; typematic 26.7 CPS rate, 250 millisecond delay
 00F  2D010                             OUTPUT s0, 10[TYPEMATIC_PORT]
 010  01670                             LOAD s6[COLOR_REG], 70                         ; standard intensity white on black  (F0 for high intensity)
 011  2F634                             STORE s6[COLOR_REG], 34[saved_color_reg]
 012                         soft_boot: 
 012  205A9                             CALL 5A9[form_feed]                            ; clear the screen
 013  01806                             LOAD s8[DIVISOR_LOW], 06[hello_msg'upper]
 014  01981                             LOAD s9[DIVISOR_HIGH], 81[hello_msg'lower]
 015  20646                             CALL 646[print_string]                         ; print our Hello message
 016  002D0                             LOAD s2[DIVIDEND_LOW], sD[CHAR_PER_LINE]
 017  01300                             LOAD s3[DIVIDEND_HIGH], 00
 018  206DB                             CALL 6DB[print_integer]
 019  01578                             LOAD s5, 78["x"]
 01A  20270                             CALL 270[send_next]
 01B  01243                             LOAD s2[DIVIDEND_LOW], 43[MAX_LINE]
 01C  01300                             LOAD s3[DIVIDEND_HIGH], 00
 01D  206DB                             CALL 6DB[print_integer]
 01E  01520                             LOAD s5, 20                                    ; fill with spaces
 01F  01010                             LOAD s0, 10                                    ; display 15 mini color bars
 020                        color_loop: 
 020  20270                             CALL 270[send_next]
 021  20270                             CALL 270[send_next]
 022  11601                             ADD s6[COLOR_REG], 01
 023  19001                             SUB s0, 01
 024  1D000                             COMPARE s0, 00
 025  36020                             JUMP NZ, 020[color_loop]
 026  01670                             LOAD s6[COLOR_REG], 70                         ; restore the default colors
 027  205CF                             CALL 5CF[CRLF]                                 ; carriage_return
 028  25000                             RETURN 
 029                                    ; OK, we've initialized things and sent our welcome message to the screen. Now we loop processing characters from the
 029                                    ; UART and PS/2 ports.
 029                                    ;
 029                                    ; The CURSOR_LOW and CURSOR_HIGH registers hold the cursor address (linear).
 029                                    ; The KEY_FLAG_REG register holds the keyboard status bits (shift, control, alt)
 029                                    ; The s6 register holds the current color attributes (MSB 16 foreground, LSB 16 background)
 029                                    ;
 029                                    ; The ANSI flags are used by the output functions, not the input processing
 029                                    ;
 029                                    ;
 029                         echo_loop: 
 029  20041                             CALL 041[PS2CHECK]
 02A  2002E                             CALL 02E[UART_FIFO_RX]                         ; use the new FIFO instead of the built in FIFO
 02B  32029                             JUMP Z, 029[echo_loop]
 02C  20270                             CALL 270[send_next]
 02D                                    ; LOAD s4,s5
 02D                                    ; CALL hex_byte
 02D                                    ; LOAD s5," "
 02D                                    ; CALL UART_TX
 02D  22029                             JUMP 029[echo_loop]
 02E                      UART_FIFO_RX: ; read a character from the primary FIFO.
 02E  011A7                             LOAD s1, A7[167'd]                             ;Timeout = 167 x (6 instructions x 2 clock cycles)
 02F                      UART_TIMEOUT: 
 02F  0900C                             INPUT s0, 0C[UART_STATUS_PORT]
 030  0D001                             TEST s0, 01[UART_FIFO_EMPTY]                   ;Z=0 and C=1 when data present
 031  32035                             JUMP Z, 035[read_fifo_Rx]
 032  19101                             SUB s1, 01[1'd]
 033  31000                             RETURN Z                                       ;Timeout returns with Z=1 and C=0
 034  2202F                             JUMP 02F[UART_TIMEOUT]
 035  0950D               read_fifo_Rx: INPUT s5, 0D[UART_READ_FIFO_PORT]              ;read character from buffer
 036  01000                             LOAD s0, 00
 037  11001                             ADD s0, 01                                     ; force clear the zero flag to indicate that we have a character in s5.
 038  25000                             RETURN 
 039                                    ; set_cursor
 039                                    ; sets the cursor address for the HDMI character display to sAsB
 039                                    ; returns without affecting any registers
 039                                    ;
 039                                    ; note that you need a NOP or some other instruction after setting the address (the RETURN is sufficient)
 039                                    ; before you read or write the memory.
 039                                    ;
 039                  decrement_cursor: 
 039  19B01                             SUB sB[CURSOR_LOW], 01
 03A  1BA00                             SUBCY sA[CURSOR_HIGH], 00
 03B  25000                             RETURN 
 03C                    advance_cursor: 
 03C  11B01                             ADD sB[CURSOR_LOW], 01
 03D  11A00                             ADD sA[CURSOR_HIGH], 00
 03E                        set_cursor: 
 03E  2DA02                             OUTPUT sA[CURSOR_HIGH], 02[MSB_PORT]           ; set MSB of address
 03F  2DB03                             OUTPUT sB[CURSOR_LOW], 03[LSB_PORT]            ; set LSB of address
 040  25000                             RETURN 
 041                                    ;
 041                                    ; PS2CHECK reads a byte from the PS/2 keyboard port and converts it into ASCII
 041                                    ; or a series of control codes. It keeps track of status bits in the KEY_FLAG_REG register (global)
 041                                    ;
 041  09407                   PS2CHECK: INPUT s4, 07[PS2_STATUS_PORT]                  ; read PS/2 status byte
 042  0D401                             TEST s4, 01                                    ; check low bit
 043  35000                             RETURN NZ                                      ; empty FIFO
 044  09406                             INPUT s4, 06[PS2_READ_PORT]                    ; read PS/2 scan code byte from FIFO
 045                     check_release: 
 045  0D701                             TEST s7[KEY_FLAG_REG], 01[KEY_RELEASE]         ; was the last code an F0?
 046  32067                             JUMP Z, 067[check_prefix]                      ; no? OK, keep processing
 047                                    ; yes? is it a shift key release?
 047                     left_shift_up: 
 047  1D412                             COMPARE s4, 12[KEY_LEFT_SHIFT]
 048  3604D                             JUMP NZ, 04D[right_shift_up]
 049  0D780                             TEST s7[KEY_FLAG_REG], 80[EXTENDED]            ; we ignore EXTENDED left shift because of NUMLOCK strangeness
 04A  36065                             JUMP NZ, 065[finish_release]
 04B  037FD                             AND s7[KEY_FLAG_REG], FD[LEFT_SHIFT_CLR]
 04C  22065                             JUMP 065[finish_release]
 04D                    right_shift_up: 
 04D  1D459                             COMPARE s4, 59[KEY_RIGHT_SHIFT]
 04E  36051                             JUMP NZ, 051[right_control_up]
 04F  037FB                             AND s7[KEY_FLAG_REG], FB[RIGHT_SHIFT_CLR]
 050  22065                             JUMP 065[finish_release]
 051                  right_control_up: 
 051  0D780                             TEST s7[KEY_FLAG_REG], 80[EXTENDED]
 052  32057                             JUMP Z, 057[right_alt_up]
 053  1D414                             COMPARE s4, 14[KEY_RIGHT_CONTROL]
 054  36057                             JUMP NZ, 057[right_alt_up]
 055  037BF                             AND s7[KEY_FLAG_REG], BF[RIGHT_CONTROL_CLR]
 056  22065                             JUMP 065[finish_release]
 057                      right_alt_up: 
 057  0D780                             TEST s7[KEY_FLAG_REG], 80[EXTENDED]
 058  3205D                             JUMP Z, 05D[left_control_up]
 059  1D411                             COMPARE s4, 11[KEY_RIGHT_ALT]
 05A  36065                             JUMP NZ, 065[finish_release]
 05B  037EF                             AND s7[KEY_FLAG_REG], EF[RIGHT_ALT_CLR]
 05C  22065                             JUMP 065[finish_release]
 05D                   left_control_up: ; we do this regardless of whether we're an extended code or not to support both left and right control
 05D  1D414                             COMPARE s4, 14[KEY_LEFT_CONTROL]
 05E  36061                             JUMP NZ, 061[left_alt_up]
 05F  037DF                             AND s7[KEY_FLAG_REG], DF[LEFT_CONTROL_CLR]
 060  22065                             JUMP 065[finish_release]
 061                       left_alt_up: ; we do this regardless of whether we're an extended code or not to support both left and right alt
 061  1D411                             COMPARE s4, 11[KEY_LEFT_ALT]
 062  36065                             JUMP NZ, 065[finish_release]
 063  037F7                             AND s7[KEY_FLAG_REG], F7[LEFT_ALT_CLR]
 064  22065                             JUMP 065[finish_release]
 065                    finish_release: 
 065  0377E                             AND s7[KEY_FLAG_REG], 7E[RELEASE_EXT_CLR]      ; otherwise clear the extended and release bits and return
 066  25000                             RETURN                                         ; later we need to handle the shifting keys
 067                                    ; key release from previous?
 067                                    ;
 067                                    ; a key was pressed (not released)
 067                                    ;
 067                      check_prefix: 
 067  1D4E0                             COMPARE s4, E0                                 ; extended code prefix?
 068  3606B                             JUMP NZ, 06B[release_code]
 069  05780                             OR s7[KEY_FLAG_REG], 80[EXTENDED]
 06A  25000                             RETURN 
 06B  1D4F0               release_code: COMPARE s4, F0                                 ; key release prefix?
 06C  3606F                             JUMP NZ, 06F[standard_code]
 06D  05701                             OR s7[KEY_FLAG_REG], 01[KEY_RELEASE]
 06E  25000                             RETURN 
 06F                     standard_code: 
 06F                   scroll_lock_hit: 
 06F  1D47E                             COMPARE s4, 7E[KEY_SCROLLLOCK]
 070  36078                             JUMP NZ, 078[num_lock_hit]
 071  0D706                             TEST s7[KEY_FLAG_REG], 06[EITHER_SHIFT]
 072  32078                             JUMP Z, 078[num_lock_hit]
 073  07C20                             XOR sC[ANSI_FLAG_REG], 20[ANSI_SCROLL_LOCK]    ; shift scroll lock toggles local echo mode
 074  0DC20                             TEST sC[ANSI_FLAG_REG], 20[ANSI_SCROLL_LOCK]
 075  3662E                             JUMP NZ, 62E[scroll_led_on]
 076  22633                             JUMP 633[scroll_led_off]
 077  25000                             RETURN 
 078                      num_lock_hit: 
 078  1D477                             COMPARE s4, 77[KEY_NUMLOCK]
 079  3608B                             JUMP NZ, 08B[caps_lock_hit]
 07A  0D706                             TEST s7[KEY_FLAG_REG], 06[EITHER_SHIFT]        ; shift NUMLOCK puts us in RAW debug mode
 07B  32080                             JUMP Z, 080[control_numlock]
 07C                     shift_numlock: 
 07C  0B018                             FETCH s0, 18[extra_flags]
 07D  07001                             XOR s0, 01[EXTRA_DEBUG]
 07E  2F018                             STORE s0, 18[extra_flags]
 07F  25000                             RETURN 
 080                   control_numlock: ; control NUMLOCK toggles keypad nethack mode
 080  0D760                             TEST s7[KEY_FLAG_REG], 60[EITHER_CONTROL]
 081  32086                             JUMP Z, 086[normal_numlock]
 082  0B018                             FETCH s0, 18[extra_flags]
 083  07002                             XOR s0, 02[EXTRA_NETHACK]
 084  2F018                             STORE s0, 18[extra_flags]
 085  25000                             RETURN 
 086                    normal_numlock: 
 086  07C40                             XOR sC[ANSI_FLAG_REG], 40[ANSI_NUM_LOCK]
 087  0DC40                             TEST sC[ANSI_FLAG_REG], 40[ANSI_NUM_LOCK]
 088  36624                             JUMP NZ, 624[num_led_on]
 089  22629                             JUMP 629[num_led_off]
 08A  25000                             RETURN 
 08B                     caps_lock_hit: 
 08B  1D458                             COMPARE s4, 58[KEY_CAPSLOCK]
 08C  36092                             JUMP NZ, 092[left_shift]
 08D  07C80                             XOR sC[ANSI_FLAG_REG], 80[ANSI_CAPS_LOCK]      ; caps lock status is toggled on and off
 08E  0DC80                             TEST sC[ANSI_FLAG_REG], 80[ANSI_CAPS_LOCK]
 08F  3661A                             JUMP NZ, 61A[caps_led_on]
 090  2261F                             JUMP 61F[caps_led_off]
 091  25000                             RETURN 
 092  1D412                 left_shift: COMPARE s4, 12[KEY_LEFT_SHIFT]
 093  36098                             JUMP NZ, 098[right_shift]
 094  0D780                             TEST s7[KEY_FLAG_REG], 80[EXTENDED]            ; we ignore EXTENDED left shift because of NUMLOCK strangeness
 095  35000                             RETURN NZ
 096  05702                             OR s7[KEY_FLAG_REG], 02[LEFT_SHIFT]
 097  25000                             RETURN 
 098  1D459                right_shift: COMPARE s4, 59[KEY_RIGHT_SHIFT]
 099  3609C                             JUMP NZ, 09C[right_control]
 09A  05704                             OR s7[KEY_FLAG_REG], 04[RIGHT_SHIFT]
 09B  25000                             RETURN 
 09C                     right_control: 
 09C  0D780                             TEST s7[KEY_FLAG_REG], 80[EXTENDED]
 09D  320A3                             JUMP Z, 0A3[left_control]
 09E  1D414                             COMPARE s4, 14[KEY_RIGHT_CONTROL]
 09F  360A3                             JUMP NZ, 0A3[left_control]
 0A0  05740                             OR s7[KEY_FLAG_REG], 40[RIGHT_CONTROL]
 0A1  0377F                             AND s7[KEY_FLAG_REG], 7F[EXTENDED_CLR]
 0A2  25000                             RETURN 
 0A3                      left_control: 
 0A3  1D414                             COMPARE s4, 14[KEY_LEFT_CONTROL]
 0A4  360A7                             JUMP NZ, 0A7[right_alt]
 0A5  05720                             OR s7[KEY_FLAG_REG], 20[LEFT_CONTROL]
 0A6  25000                             RETURN 
 0A7                         right_alt: 
 0A7  0D780                             TEST s7[KEY_FLAG_REG], 80[EXTENDED]
 0A8  320AE                             JUMP Z, 0AE[left_alt]
 0A9  1D411                             COMPARE s4, 11[KEY_RIGHT_ALT]
 0AA  360AE                             JUMP NZ, 0AE[left_alt]
 0AB  05710                             OR s7[KEY_FLAG_REG], 10[RIGHT_ALT]
 0AC  0377F                             AND s7[KEY_FLAG_REG], 7F[EXTENDED_CLR]
 0AD  25000                             RETURN 
 0AE                          left_alt: 
 0AE  1D411                             COMPARE s4, 11[KEY_LEFT_ALT]
 0AF  360B2                             JUMP NZ, 0B2[actual_key]
 0B0  05708                             OR s7[KEY_FLAG_REG], 08[LEFT_ALT]
 0B1  25000                             RETURN 
 0B2                        actual_key: ; keys that actually generate one or more codes
 0B2  0D780                             TEST s7[KEY_FLAG_REG], 80[EXTENDED]
 0B3  32125                             JUMP Z, 125[not_extended]
 0B4                         ext_enter: 
 0B4  1D45A                             COMPARE s4, 5A[EXTKEY_KEYPAD_ENTER]            ;
 0B5  360B8                             JUMP NZ, 0B8[ext_slash]
 0B6  0150D                             LOAD s5, 0D[CR]
 0B7  22256                             JUMP 256[check_special]
 0B8                         ext_slash: 
 0B8  1D44A                             COMPARE s4, 4A[EXTKEY_KEYPAD_SLASH]
 0B9  360BC                             JUMP NZ, 0BC[ext_delete]
 0BA  0152F                             LOAD s5, 2F["/"]
 0BB  22256                             JUMP 256[check_special]
 0BC                        ext_delete: 
 0BC  1D471                             COMPARE s4, 71[EXTKEY_DELETE]
 0BD  360C3                             JUMP NZ, 0C3[ext_up]
 0BE                     ext_do_delete: 
 0BE  20642                             CALL 642[send_csi]
 0BF  01533                             LOAD s5, 33["3"]
 0C0  2026B                             CALL 26B[print_the_char]
 0C1  200DF                             CALL 0DF[extended_modifiers]
 0C2  22640                             JUMP 640[send_tilde]
 0C3                            ext_up: 
 0C3  1D475                             COMPARE s4, 75[EXTKEY_UP]                      ;
 0C4  360C9                             JUMP NZ, 0C9[ext_down]
 0C5                         ext_do_up: 
 0C5  20642                             CALL 642[send_csi]
 0C6  200E9                             CALL 0E9[extended_modifiers_single]
 0C7  01541                             LOAD s5, 41["A"]
 0C8  2226B                             JUMP 26B[print_the_char]
 0C9                          ext_down: 
 0C9  1D472                             COMPARE s4, 72[EXTKEY_DOWN]
 0CA  360CF                             JUMP NZ, 0CF[ext_right]
 0CB                       ext_do_down: 
 0CB  20642                             CALL 642[send_csi]
 0CC  200E9                             CALL 0E9[extended_modifiers_single]
 0CD  01542                             LOAD s5, 42["B"]
 0CE  2226B                             JUMP 26B[print_the_char]
 0CF                         ext_right: 
 0CF  1D474                             COMPARE s4, 74[EXTKEY_RIGHT]
 0D0  360D5                             JUMP NZ, 0D5[ext_left]
 0D1                      ext_do_right: 
 0D1  20642                             CALL 642[send_csi]
 0D2  200E9                             CALL 0E9[extended_modifiers_single]
 0D3  01543                             LOAD s5, 43["C"]
 0D4  2226B                             JUMP 26B[print_the_char]
 0D5                          ext_left: 
 0D5  1D46B                             COMPARE s4, 6B[EXTKEY_LEFT]
 0D6  36100                             JUMP NZ, 100[ext_home]
 0D7                       ext_do_left: 
 0D7  20642                             CALL 642[send_csi]
 0D8  200E9                             CALL 0E9[extended_modifiers_single]
 0D9  01544                             LOAD s5, 44["D"]
 0DA  2226B                             JUMP 26B[print_the_char]
 0DB                       ext_do_dead: ; the dead '5' key when we're in num lock mode
 0DB  20642                             CALL 642[send_csi]
 0DC  200E9                             CALL 0E9[extended_modifiers_single]
 0DD  01545                             LOAD s5, 45["E"]                               ; this is what Ubuntu xterm sends.
 0DE  2226B                             JUMP 26B[print_the_char]
 0DF                                    ;
 0DF                                    ; CSI-tilde is for extended keys.
 0DF                                    ; a second parameter can be present as a modifier:
 0DF                                    ;
 0DF                                    ; 2 shift
 0DF                                    ; 3 alt
 0DF                                    ; 4 shift+alt
 0DF                                    ; 5 control
 0DF                                    ; 6 shift+control
 0DF                                    ; 7 alt+control
 0DF                                    ; 8 shift+alt+control
 0DF                                    ;
 0DF                                    ; Another way to do it:
 0DF                                    ; (shift)+(alt*2)+(control*4) + 1
 0DF                                    ;
 0DF                extended_modifiers: ; add key modifiers if any are set
 0DF  200F5                             CALL 0F5[test_modifiers]
 0E0  11001                             ADD s0, 01
 0E1  1D001                             COMPARE s0, 01
 0E2  31000                             RETURN Z
 0E3  11030                             ADD s0, 30                                     ; make it a printable ASCII digit
 0E4  2F03C                             STORE s0, 3C[scratchW]
 0E5  0153B                             LOAD s5, 3B[";"]
 0E6  2026B                             CALL 26B[print_the_char]
 0E7  0B53C                             FETCH s5, 3C[scratchW]
 0E8  2226B                             JUMP 26B[print_the_char]
 0E9         extended_modifiers_single: ; single iteration plus modifiers
 0E9  200F5                             CALL 0F5[test_modifiers]
 0EA  11001                             ADD s0, 01
 0EB  1D001                             COMPARE s0, 01
 0EC  31000                             RETURN Z
 0ED  11030                             ADD s0, 30                                     ; make it a printable ASCII digit
 0EE  2F03C                             STORE s0, 3C[scratchW]
 0EF  01531                             LOAD s5, 31["1"]                               ; single iteration
 0F0  2026B                             CALL 26B[print_the_char]
 0F1  0153B                             LOAD s5, 3B[";"]
 0F2  2026B                             CALL 26B[print_the_char]
 0F3  0B53C                             FETCH s5, 3C[scratchW]
 0F4  2226B                             JUMP 26B[print_the_char]
 0F5                    test_modifiers: 
 0F5  01000                             LOAD s0, 00
 0F6                        test_shift: 
 0F6  0D706                             TEST s7[KEY_FLAG_REG], 06[EITHER_SHIFT]
 0F7  320F9                             JUMP Z, 0F9[test_alt]
 0F8  11001                             ADD s0, 01
 0F9                          test_alt: 
 0F9  0D718                             TEST s7[KEY_FLAG_REG], 18[EITHER_ALT]
 0FA  320FC                             JUMP Z, 0FC[test_control]
 0FB  11002                             ADD s0, 02
 0FC                      test_control: 
 0FC  0D760                             TEST s7[KEY_FLAG_REG], 60[EITHER_CONTROL]
 0FD  320FF                             JUMP Z, 0FF[test_end]                          ; not a RETURN Z because we plan to support META later
 0FE  11004                             ADD s0, 04
 0FF                          test_end: 
 0FF  25000                             RETURN 
 100                                    ; bug_hunt:
 100                                    ;   STORE s0, scratchM
 100                                    ;   STORE s4, scratchN
 100                                    ;   STORE s5, scratchO
 100                                    ;   LOAD s5, "<"
 100                                    ;CALL UART_TX
 100                                    ;CALL hex_byte
 100                                    ;LOAD s5, ","
 100                                    ;CALL UART_TX
 100                                    ;LOAD s4, KEY_FLAG_REG
 100                                    ;CALL hex_byte
 100                                    ;LOAD s5, ">"
 100                                    ;CALL UART_TX
 100                                    ;FETCH s0, scratchM
 100                                    ;FETCH s4, scratchN
 100                                    ;FETCH s5, scratchO
 100                                    ;RETURN
 100                                    ;
 100                                    ; more extended keys
 100                                    ;
 100                                    ;
 100                          ext_home: 
 100  1D46C                             COMPARE s4, 6C[EXTKEY_HOME]
 101  36107                             JUMP NZ, 107[ext_insert]
 102                       ext_do_home: 
 102  20642                             CALL 642[send_csi]
 103  01531                             LOAD s5, 31["1"]
 104  2026B                             CALL 26B[print_the_char]
 105  200DF                             CALL 0DF[extended_modifiers]
 106  22640                             JUMP 640[send_tilde]
 107                        ext_insert: 
 107  1D470                             COMPARE s4, 70[EXTKEY_INSERT]
 108  3610E                             JUMP NZ, 10E[ext_end]
 109                     ext_do_insert: 
 109  20642                             CALL 642[send_csi]
 10A  01532                             LOAD s5, 32["2"]                               ; putty/xterm
 10B  2026B                             CALL 26B[print_the_char]
 10C  200DF                             CALL 0DF[extended_modifiers]
 10D  22640                             JUMP 640[send_tilde]
 10E                           ext_end: ; from terminfo for xterm
 10E  1D469                             COMPARE s4, 69[EXTKEY_END]
 10F  36115                             JUMP NZ, 115[ext_pgup]
 110                        ext_do_end: 
 110  20642                             CALL 642[send_csi]
 111  01534                             LOAD s5, 34["4"]
 112  2026B                             CALL 26B[print_the_char]
 113  200DF                             CALL 0DF[extended_modifiers]
 114  22640                             JUMP 640[send_tilde]
 115                                    ;LOAD s5, end_key
 115                                    ;JUMP check_special ; this makes it go the end the of the line
 115                          ext_pgup: ; from terminfo for xterm
 115  1D47D                             COMPARE s4, 7D[EXTKEY_PGUP]
 116  3611C                             JUMP NZ, 11C[ext_pgdn]
 117                       ext_do_pgup: 
 117  20642                             CALL 642[send_csi]
 118  01535                             LOAD s5, 35["5"]
 119  2026B                             CALL 26B[print_the_char]
 11A  200DF                             CALL 0DF[extended_modifiers]
 11B  22640                             JUMP 640[send_tilde]
 11C                          ext_pgdn: ; from terminfo for xterm
 11C  1D47A                             COMPARE s4, 7A[EXTKEY_PGDN]
 11D  36123                             JUMP NZ, 123[ext_other]
 11E                       ext_do_pgdn: 
 11E  20642                             CALL 642[send_csi]
 11F  01536                             LOAD s5, 36["6"]
 120  2026B                             CALL 26B[print_the_char]
 121  200DF                             CALL 0DF[extended_modifiers]
 122  22640                             JUMP 640[send_tilde]
 123                                    ; JUMP check_special
 123                         ext_other: 
 123                     extended_code: 
 123  0377F                             AND s7[KEY_FLAG_REG], 7F[EXTENDED_CLR]         ; clear the extended flag
 124  25000                             RETURN 
 125                                    ;
 125                                    ; a key was pressed and it is not an extended code
 125                                    ;
 125                      not_extended: 
 125  0DC40                             TEST sC[ANSI_FLAG_REG], 40[ANSI_NUM_LOCK]
 126  3216D                             JUMP Z, 16D[special_non_extended]
 127                        numlock_on: 
 127                                    ;
 127                                    ; nethack mode?
 127                                    ; yku
 127                                    ; h.l
 127                                    ; bjn
 127  0B518                             FETCH s5, 18[extra_flags]
 128  0D502                             TEST s5, 02[EXTRA_NETHACK]
 129  32157                             JUMP Z, 157[keypad_navigation]
 12A  1D470                             COMPARE s4, 70[KEYPAD_INSERT]
 12B  32143                             JUMP Z, 143[hack_0]
 12C  1D471                             COMPARE s4, 71[KEYPAD_DELETE]
 12D  32141                             JUMP Z, 141[hack_dot]
 12E  1D46C                             COMPARE s4, 6C[KEYPAD_HOME]
 12F  32151                             JUMP Z, 151[hack_7]
 130  1D469                             COMPARE s4, 69[KEYPAD_END]
 131  32145                             JUMP Z, 145[hack_1]
 132  1D47D                             COMPARE s4, 7D[KEYPAD_PGUP]
 133  32155                             JUMP Z, 155[hack_9]
 134  1D47A                             COMPARE s4, 7A[KEYPAD_PGDN]
 135  32149                             JUMP Z, 149[hack_3]
 136  1D475                             COMPARE s4, 75[KEYPAD_UP]
 137  32153                             JUMP Z, 153[hack_8]
 138  1D472                             COMPARE s4, 72[KEYPAD_DOWN]
 139  32147                             JUMP Z, 147[hack_2]
 13A  1D46B                             COMPARE s4, 6B[KEYPAD_LEFT]
 13B  3214B                             JUMP Z, 14B[hack_4]
 13C  1D474                             COMPARE s4, 74[KEYPAD_RIGHT]
 13D  3214F                             JUMP Z, 14F[hack_6]
 13E  1D473                             COMPARE s4, 73[KEYPAD_DEAD]
 13F  3214D                             JUMP Z, 14D[hack_5]
 140  2216D                             JUMP 16D[special_non_extended]
 141  0152E                   hack_dot: LOAD s5, 2E["."]
 142  22256                             JUMP 256[check_special]
 143  01530                     hack_0: LOAD s5, 30["0"]
 144  22256                             JUMP 256[check_special]
 145  01562                     hack_1: LOAD s5, 62["b"]
 146  22256                             JUMP 256[check_special]
 147  0156A                     hack_2: LOAD s5, 6A["j"]
 148  22256                             JUMP 256[check_special]
 149  0156E                     hack_3: LOAD s5, 6E["n"]
 14A  22256                             JUMP 256[check_special]
 14B  01568                     hack_4: LOAD s5, 68["h"]
 14C  22256                             JUMP 256[check_special]
 14D  0152E                     hack_5: LOAD s5, 2E["."]
 14E  22256                             JUMP 256[check_special]
 14F  0156C                     hack_6: LOAD s5, 6C["l"]
 150  22256                             JUMP 256[check_special]
 151  01579                     hack_7: LOAD s5, 79["y"]
 152  22256                             JUMP 256[check_special]
 153  0156B                     hack_8: LOAD s5, 6B["k"]
 154  22256                             JUMP 256[check_special]
 155  01575                     hack_9: LOAD s5, 75["u"]
 156  22256                             JUMP 256[check_special]
 157                 keypad_navigation: 
 157  1D46C                             COMPARE s4, 6C[KEYPAD_HOME]
 158  32102                             JUMP Z, 102[ext_do_home]
 159  1D469                             COMPARE s4, 69[KEYPAD_END]
 15A  32110                             JUMP Z, 110[ext_do_end]
 15B  1D470                             COMPARE s4, 70[KEYPAD_INSERT]
 15C  32109                             JUMP Z, 109[ext_do_insert]
 15D  1D471                             COMPARE s4, 71[KEYPAD_DELETE]
 15E  320BE                             JUMP Z, 0BE[ext_do_delete]
 15F  1D47D                             COMPARE s4, 7D[KEYPAD_PGUP]
 160  3211E                             JUMP Z, 11E[ext_do_pgdn]
 161  1D47A                             COMPARE s4, 7A[KEYPAD_PGDN]
 162  3211E                             JUMP Z, 11E[ext_do_pgdn]
 163  1D475                             COMPARE s4, 75[KEYPAD_UP]
 164  320C5                             JUMP Z, 0C5[ext_do_up]
 165  1D472                             COMPARE s4, 72[KEYPAD_DOWN]
 166  320CB                             JUMP Z, 0CB[ext_do_down]
 167  1D46B                             COMPARE s4, 6B[KEYPAD_LEFT]
 168  320D7                             JUMP Z, 0D7[ext_do_left]
 169  1D474                             COMPARE s4, 74[KEYPAD_RIGHT]
 16A  320D1                             JUMP Z, 0D1[ext_do_right]
 16B  1D473                             COMPARE s4, 73[KEYPAD_DEAD]
 16C  320DB                             JUMP Z, 0DB[ext_do_dead]
 16D              special_non_extended: 
 16D                        F1_key_hit: 
 16D  1D405                             COMPARE s4, 05[KEY_F1]
 16E  36175                             JUMP NZ, 175[F2_key_hit]
 16F  0151B                             LOAD s5, 1B                                    ; ESC
 170  0154F                             LOAD s5, 4F["O"]
 171  2026B                             CALL 26B[print_the_char]
 172  200DF                             CALL 0DF[extended_modifiers]                   ; these are wrong, wrong ,wrong- should be CSI O (modifiers) P
 173  01550                             LOAD s5, 50["P"]
 174  2226B                             JUMP 26B[print_the_char]
 175                        F2_key_hit: 
 175  1D406                             COMPARE s4, 06[KEY_F2]
 176  3617D                             JUMP NZ, 17D[F3_key_hit]
 177  0151B                             LOAD s5, 1B                                    ; ESC
 178  0154F                             LOAD s5, 4F["O"]
 179  2026B                             CALL 26B[print_the_char]
 17A  200DF                             CALL 0DF[extended_modifiers]                   ; these are wrong, wrong ,wrong.
 17B  01551                             LOAD s5, 51["Q"]
 17C  2226B                             JUMP 26B[print_the_char]
 17D                        F3_key_hit: 
 17D  1D404                             COMPARE s4, 04[KEY_F3]
 17E  36185                             JUMP NZ, 185[F4_key_hit]
 17F  0151B                             LOAD s5, 1B                                    ; ESC
 180  0154F                             LOAD s5, 4F["O"]
 181  2026B                             CALL 26B[print_the_char]
 182  200DF                             CALL 0DF[extended_modifiers]                   ; these are wrong, wrong ,wrong.
 183  01552                             LOAD s5, 52["R"]
 184  2226B                             JUMP 26B[print_the_char]
 185                        F4_key_hit: 
 185  1D40C                             COMPARE s4, 0C[KEY_F4]
 186  3618D                             JUMP NZ, 18D[F5_key_hit]
 187  0151B                             LOAD s5, 1B                                    ; ESC
 188  0154F                             LOAD s5, 4F["O"]
 189  2026B                             CALL 26B[print_the_char]
 18A  200DF                             CALL 0DF[extended_modifiers]                   ; these are wrong, wrong ,wrong.
 18B  01553                             LOAD s5, 53["S"]
 18C  2226B                             JUMP 26B[print_the_char]
 18D                        F5_key_hit: 
 18D  1D403                             COMPARE s4, 03[KEY_F5]
 18E  36196                             JUMP NZ, 196[F6_key_hit]
 18F  20642                             CALL 642[send_csi]
 190  01531                             LOAD s5, 31["1"]
 191  2026B                             CALL 26B[print_the_char]
 192  01535                             LOAD s5, 35["5"]
 193  2026B                             CALL 26B[print_the_char]
 194  200DF                             CALL 0DF[extended_modifiers]
 195  22640                             JUMP 640[send_tilde]
 196                        F6_key_hit: 
 196  1D40B                             COMPARE s4, 0B[KEY_F6]
 197  3619F                             JUMP NZ, 19F[F7_key_hit]
 198  20642                             CALL 642[send_csi]
 199  01531                             LOAD s5, 31["1"]
 19A  2026B                             CALL 26B[print_the_char]
 19B  01537                             LOAD s5, 37["7"]
 19C  2026B                             CALL 26B[print_the_char]
 19D  200DF                             CALL 0DF[extended_modifiers]
 19E  22640                             JUMP 640[send_tilde]
 19F                        F7_key_hit: 
 19F  1D483                             COMPARE s4, 83[KEY_F7]
 1A0  361A8                             JUMP NZ, 1A8[F8_key_hit]
 1A1  20642                             CALL 642[send_csi]
 1A2  01531                             LOAD s5, 31["1"]
 1A3  2026B                             CALL 26B[print_the_char]
 1A4  01538                             LOAD s5, 38["8"]
 1A5  2026B                             CALL 26B[print_the_char]
 1A6  200DF                             CALL 0DF[extended_modifiers]
 1A7  22640                             JUMP 640[send_tilde]
 1A8                        F8_key_hit: 
 1A8  1D40A                             COMPARE s4, 0A[KEY_F8]
 1A9  361B1                             JUMP NZ, 1B1[F9_key_hit]
 1AA  20642                             CALL 642[send_csi]
 1AB  01531                             LOAD s5, 31["1"]
 1AC  2026B                             CALL 26B[print_the_char]
 1AD  01539                             LOAD s5, 39["9"]
 1AE  2026B                             CALL 26B[print_the_char]
 1AF  200DF                             CALL 0DF[extended_modifiers]
 1B0  22640                             JUMP 640[send_tilde]
 1B1                        F9_key_hit: 
 1B1  1D401                             COMPARE s4, 01[KEY_F9]
 1B2  361BA                             JUMP NZ, 1BA[F10_key_hit]
 1B3  20642                             CALL 642[send_csi]
 1B4  01532                             LOAD s5, 32["2"]
 1B5  2026B                             CALL 26B[print_the_char]
 1B6  01530                             LOAD s5, 30["0"]
 1B7  2026B                             CALL 26B[print_the_char]
 1B8  200DF                             CALL 0DF[extended_modifiers]
 1B9  22640                             JUMP 640[send_tilde]
 1BA                       F10_key_hit: 
 1BA  1D409                             COMPARE s4, 09[KEY_F10]
 1BB  361C3                             JUMP NZ, 1C3[F11_key_hit]
 1BC  20642                             CALL 642[send_csi]
 1BD  01532                             LOAD s5, 32["2"]
 1BE  2026B                             CALL 26B[print_the_char]
 1BF  01531                             LOAD s5, 31["1"]
 1C0  2026B                             CALL 26B[print_the_char]
 1C1  200DF                             CALL 0DF[extended_modifiers]
 1C2  22640                             JUMP 640[send_tilde]
 1C3                       F11_key_hit: 
 1C3  1D478                             COMPARE s4, 78[KEY_F11]
 1C4  361CC                             JUMP NZ, 1CC[F12_key_hit]
 1C5  20642                             CALL 642[send_csi]
 1C6  01532                             LOAD s5, 32["2"]
 1C7  2026B                             CALL 26B[print_the_char]
 1C8  01533                             LOAD s5, 33["3"]
 1C9  2026B                             CALL 26B[print_the_char]
 1CA  200DF                             CALL 0DF[extended_modifiers]
 1CB  22640                             JUMP 640[send_tilde]
 1CC                       F12_key_hit: 
 1CC  1D407                             COMPARE s4, 07[KEY_F12]
 1CD  361D5                             JUMP NZ, 1D5[pause_break]
 1CE  20642                             CALL 642[send_csi]
 1CF  01532                             LOAD s5, 32["2"]
 1D0  2026B                             CALL 26B[print_the_char]
 1D1  01534                             LOAD s5, 34["4"]
 1D2  2026B                             CALL 26B[print_the_char]
 1D3  200DF                             CALL 0DF[extended_modifiers]
 1D4  22640                             JUMP 640[send_tilde]
 1D5                       pause_break: 
 1D5                                    ;   COMPARE s4, PAUSE_BREAK_PREFIX ;PAUSE_BREAK_KEY ; pause/break- note that we get two of these each time the key is pressed
 1D5                                    ;   JUMP NZ, not_special
 1D5                                    ;   TEST KEY_FLAG_REG, EITHER_SHIFT
 1D5                                    ;   JUMP Z, not_special
 1D5                                    ;   CALL init_terminal
 1D5                                    ; LOAD s5, 11    ; this is a nice triangle. ANSI device control 1
 1D5                                    ; JUMP print_the_char
 1D5                       not_special: 
 1D5  1D47E                             COMPARE s4, 7E[LAST_SCAN_CODE]                 ; make sure we're in the valid range before jumping
 1D6  3D000                             RETURN NC
 1D7  01807                             LOAD s8[DIVISOR_LOW], 07[SCAN_CODES'upper]
 1D8  0190A                             LOAD s9[DIVISOR_HIGH], 0A[SCAN_CODES'lower]
 1D9  10940                             ADD s9[DIVISOR_HIGH], s4                       ; index offset
 1DA  13800                             ADDCY s8[DIVISOR_LOW], 00
 1DB  24890                             CALL@ (s8[DIVISOR_LOW], s9[DIVISOR_HIGH])      ; lookup our character code
 1DC                                    ;
 1DC                                    ; s5 now contains either a 0x00 or an ASCII character from our lookup table
 1DC                                    ; check for shift-[symbol] combinations
 1DC                    shifted_symbol: 
 1DC  0D706                             TEST s7[KEY_FLAG_REG], 06[EITHER_SHIFT]
 1DD  32240                             JUMP Z, 240[not_shifted]
 1DE                              key0: 
 1DE  1D509                             COMPARE s5, 09
 1DF  361E3                             JUMP NZ, 1E3[key1]
 1E0  20642                             CALL 642[send_csi]
 1E1  0155A                             LOAD s5, 5A["Z"]
 1E2  2226B                             JUMP 26B[print_the_char]
 1E3  1D531                       key1: COMPARE s5, 31["1"]
 1E4  361E7                             JUMP NZ, 1E7[key2]
 1E5  01521                             LOAD s5, 21["!"]
 1E6  22268                             JUMP 268[printable_char]
 1E7  1D532                       key2: COMPARE s5, 32["2"]
 1E8  361EB                             JUMP NZ, 1EB[key3]
 1E9  01540                             LOAD s5, 40["@"]
 1EA  22268                             JUMP 268[printable_char]
 1EB  1D533                       key3: COMPARE s5, 33["3"]
 1EC  361EF                             JUMP NZ, 1EF[key4]
 1ED  01523                             LOAD s5, 23["#"]
 1EE  22268                             JUMP 268[printable_char]
 1EF  1D534                       key4: COMPARE s5, 34["4"]
 1F0  361F3                             JUMP NZ, 1F3[key5]
 1F1  01524                             LOAD s5, 24["$"]
 1F2  22268                             JUMP 268[printable_char]
 1F3  1D535                       key5: COMPARE s5, 35["5"]
 1F4  361F7                             JUMP NZ, 1F7[key6]
 1F5  01525                             LOAD s5, 25["%"]
 1F6  22268                             JUMP 268[printable_char]
 1F7  1D536                       key6: COMPARE s5, 36["6"]
 1F8  361FE                             JUMP NZ, 1FE[key7]
 1F9  0155E                             LOAD s5, 5E["^"]
 1FA  0D760                             TEST s7[KEY_FLAG_REG], 60[EITHER_CONTROL]
 1FB  32268                             JUMP Z, 268[printable_char]
 1FC  0151E                             LOAD s5, 1E                                    ; ctrl-caret is code 0x1E, ECSCAPE+3
 1FD  22268                             JUMP 268[printable_char]
 1FE  1D537                       key7: COMPARE s5, 37["7"]
 1FF  36202                             JUMP NZ, 202[key8]
 200  01526                             LOAD s5, 26["&"]
 201  22268                             JUMP 268[printable_char]
 202  1D538                       key8: COMPARE s5, 38["8"]
 203  36206                             JUMP NZ, 206[key9]
 204  0152A                             LOAD s5, 2A["*"]
 205  22268                             JUMP 268[printable_char]
 206  1D539                       key9: COMPARE s5, 39["9"]
 207  3620A                             JUMP NZ, 20A[key10]
 208  01528                             LOAD s5, 28["("]
 209  22268                             JUMP 268[printable_char]
 20A  1D530                      key10: COMPARE s5, 30["0"]
 20B  3620E                             JUMP NZ, 20E[key11]
 20C  01529                             LOAD s5, 29[")"]
 20D  22268                             JUMP 268[printable_char]
 20E  1D560                      key11: COMPARE s5, 60                                 ; accent grave "'"
 20F  36212                             JUMP NZ, 212[key12]
 210  0157E                             LOAD s5, 7E["~"]
 211  22268                             JUMP 268[printable_char]
 212  1D52D                      key12: COMPARE s5, 2D["-"]
 213  36219                             JUMP NZ, 219[key13]
 214  0155F                             LOAD s5, 5F["_"]
 215  0D760                             TEST s7[KEY_FLAG_REG], 60[EITHER_CONTROL]
 216  32268                             JUMP Z, 268[printable_char]
 217  0151F                             LOAD s5, 1F                                    ; ctrl-underscore is 0x1F, ESCAPE+4
 218  22268                             JUMP 268[printable_char]
 219  1D53D                      key13: COMPARE s5, 3D["="]
 21A  3621D                             JUMP NZ, 21D[key14]
 21B  0152B                             LOAD s5, 2B["+"]
 21C  22268                             JUMP 268[printable_char]
 21D  1D53B                      key14: COMPARE s5, 3B[";"]
 21E  36221                             JUMP NZ, 221[key15]
 21F  0153A                             LOAD s5, 3A[":"]
 220  22268                             JUMP 268[printable_char]
 221  1D527                      key15: COMPARE s5, 27                                 ; single quote "'"
 222  36225                             JUMP NZ, 225[key16]
 223  01522                             LOAD s5, 22                                    ; double quotes
 224  22268                             JUMP 268[printable_char]
 225  1D55B                      key16: COMPARE s5, 5B["["]
 226  36229                             JUMP NZ, 229[key17]
 227  0157B                             LOAD s5, 7B["{"]
 228  22268                             JUMP 268[printable_char]
 229  1D55D                      key17: COMPARE s5, 5D["]"]
 22A  3622D                             JUMP NZ, 22D[key18]
 22B  0157D                             LOAD s5, 7D["}"]
 22C  22268                             JUMP 268[printable_char]
 22D  1D55C                      key18: COMPARE s5, 5C["\"]
 22E  36231                             JUMP NZ, 231[key19]
 22F  0157C                             LOAD s5, 7C["|"]
 230  22268                             JUMP 268[printable_char]
 231  1D52C                      key19: COMPARE s5, 2C[","]
 232  36235                             JUMP NZ, 235[key20]
 233  0153C                             LOAD s5, 3C["<"]
 234  22268                             JUMP 268[printable_char]
 235  1D52E                      key20: COMPARE s5, 2E["."]
 236  36239                             JUMP NZ, 239[key21]
 237  0153E                             LOAD s5, 3E[">"]
 238  22268                             JUMP 268[printable_char]
 239  1D52F                      key21: COMPARE s5, 2F["/"]
 23A  36256                             JUMP NZ, 256[check_special]
 23B  0153F                             LOAD s5, 3F["?"]
 23C  0D760                             TEST s7[KEY_FLAG_REG], 60[EITHER_CONTROL]
 23D  32268                             JUMP Z, 268[printable_char]
 23E  0157F                             LOAD s5, 7F                                    ; delete key (rubout, 0x7F) is also CTRL-question_mark
 23F  22268                             JUMP 268[printable_char]
 240                       not_shifted: 
 240                    control_symbol: 
 240  0D760                             TEST s7[KEY_FLAG_REG], 60[EITHER_CONTROL]
 241  32256                             JUMP Z, 256[check_special]
 242                                    ;
 242                                    ; at this point we know the control key is pressed and the shift keys are not pressed,
 242                                    ; so we handle a few special cases that are not alpha (A-Z) control codes
 242                                    ;
 242  1D55B                      key00: COMPARE s5, 5B["["]
 243  36246                             JUMP NZ, 246[key01]
 244  0151B                             LOAD s5, 1B                                    ; ESCAPE is also control-open_bracket
 245  22268                             JUMP 268[printable_char]
 246  1D55C                      key01: COMPARE s5, 5C["\"]
 247  3624A                             JUMP NZ, 24A[key02]
 248  0151C                             LOAD s5, 1C                                    ; ESCAPE +1, rarely used but we support it, control-backslash
 249  22268                             JUMP 268[printable_char]
 24A  1D55D                      key02: COMPARE s5, 5D["]"]
 24B  3624E                             JUMP NZ, 24E[key03]
 24C  0151D                             LOAD s5, 1D                                    ; ESCAPE +2, rarely used but we support it, control-close_bracket
 24D  22268                             JUMP 268[printable_char]
 24E  1D532                      key03: COMPARE s5, 32["2"]
 24F  36252                             JUMP NZ, 252[key04]
 250  01500                             LOAD s5, 00                                    ; NULL, rarely used but we support it for output to the host control-at_sign
 251  2226E                             JUMP 26E[output_to_host]                       ; we bypass the local echo. note that an undefined keyboard scan code (non-extended)
 252                                    ; will also send a NULL to the host.
 252  1D508                      key04: COMPARE s5, 08
 253  36256                             JUMP NZ, 256[check_special]
 254  0157F                             LOAD s5, 7F                                    ; we implement control-backspace as delete (rubout) char 127
 255  22268                             JUMP 268[printable_char]
 256                     check_special: 
 256                                    ; are we a letter of the alphabet?
 256  1D57B                             COMPARE s5, 7B                                 ; lower case 'z' plus one
 257  3E268                             JUMP NC, 268[printable_char]                   ; we're above z
 258  1D560                             COMPARE s5, 60                                 ; lower case 'a' minus one
 259  3A268                             JUMP C, 268[printable_char]
 25A  32268                             JUMP Z, 268[printable_char]                    ; we're below or equal to 'a' minus one
 25B  0D760                             TEST s7[KEY_FLAG_REG], 60[EITHER_CONTROL]
 25C  3225F                             JUMP Z, 25F[check_shift]
 25D  19560                             SUB s5, 60                                     ; we're a control character, so we start at 0
 25E  22268                             JUMP 268[printable_char]
 25F  0DC80                check_shift: TEST sC[ANSI_FLAG_REG], 80[ANSI_CAPS_LOCK]
 260  32265                             JUMP Z, 265[no_caps_lock]
 261  0D706                             TEST s7[KEY_FLAG_REG], 06[EITHER_SHIFT]
 262  36268                             JUMP NZ, 268[printable_char]                   ; we do the shift thing but we're NZ instead of Z
 263  19520                             SUB s5, 20
 264  22268                             JUMP 268[printable_char]
 265  0D706               no_caps_lock: TEST s7[KEY_FLAG_REG], 06[EITHER_SHIFT]
 266  32268                             JUMP Z, 268[printable_char]
 267  19520                             SUB s5, 20                                     ; we're upper case so we start at 40
 268                                    ;
 268                                    ; at this point we've processed everything and have a character in s5.
 268                                    ; here is where we actually DO something with the character code.
 268                                    ;
 268                                    ;
 268                                    ; we might want to consider the ALT modifier setting the high bit. This would make it possible to type
 268                                    ; all 256 possible values.
 268                                    ;
 268                                    ; we might also want to suppress NULLs here instead of printing them.
 268                                    ;
 268                                    ;
 268                    printable_char: 
 268  0D718                             TEST s7[KEY_FLAG_REG], 18[EITHER_ALT]
 269  3226B                             JUMP Z, 26B[print_the_char]                    ; if alt key is pressed then we set the high bit
 26A  05580                             OR s5, 80
 26B                    print_the_char: ; we do a local echo if scroll lock is on.
 26B  0DC20                             TEST sC[ANSI_FLAG_REG], 20[ANSI_SCROLL_LOCK]
 26C  3226E                             JUMP Z, 26E[output_to_host]
 26D  20270                             CALL 270[send_next]                            ; send it to the HDMI if the scroll lock is on
 26E                    output_to_host: 
 26E                                    ;FETCH s0, extra_flags
 26E                                    ;TEST s0, EXTRA_DEBUG  ; if we're in debug mode send control characters as upper case letters.
 26E                                    ;JUMP NZ, raw_uart_out
 26E                                    ;COMPARE s5, 20
 26E                                    ;JUMP NC, raw_uart_out
 26E                                    ;ADD s5, 40
 26E  2078B                             CALL 78B[UART_TX]                              ; sent it to the serial port
 26F  25000                             RETURN 
 270                                    ;
 270                                    ; send_next
 270                                    ; writes a character in s5 to the HDMI terminal. It processes control sequences and
 270                                    ; handles scrolling when appropriate.
 270                                    ;
 270                         send_next: 
 270  1D51B                             COMPARE s5, 1B                                 ; is it an escape?
 271  32275                             JUMP Z, 275[not_stored]
 272  0DC03                             TEST sC[ANSI_FLAG_REG], 03[ANSI_ESC_CSI]
 273  36275                             JUMP NZ, 275[not_stored]                       ; we don't store the character if it's part of a command sequence
 274  2F531                             STORE s5, 31[last_char]
 275                        not_stored: 
 275  0DC10                             TEST sC[ANSI_FLAG_REG], 10[ANSI_SSG2]
 276  36296                             JUMP NZ, 296[raw_char_out]
 277  1D500                             COMPARE s5, 00                                 ; if it's a NULL we do nothing, unless we're in SSG2 then we've already printed it.
 278  31000                             RETURN Z
 279  0DC01                             TEST sC[ANSI_FLAG_REG], 01[ANSI_CSI]           ; we're in the middle of a CSI sequence
 27A  362D5                             JUMP NZ, 2D5[parse_csi_digit]
 27B  0DC02                             TEST sC[ANSI_FLAG_REG], 02[ANSI_ESCAPE]        ; we're in the middle of an ESC sequence
 27C  362AE                             JUMP NZ, 2AE[escape_sequence]
 27D  2F03D                             STORE s0, 3D[scratchX]
 27E  0B018                             FETCH s0, 18[extra_flags]
 27F  0D001                             TEST s0, 01[EXTRA_DEBUG]                       ; if we're in debug mode we send the character in RAW mode
 280  36296                             JUMP NZ, 296[raw_char_out]
 281  0B03D                             FETCH s0, 3D[scratchX]
 282  1D51B                             COMPARE s5, 1B[ESC_CHAR]                       ; ESCAPE sequence begins
 283  322AC                             JUMP Z, 2AC[escape_received]
 284  1D508                             COMPARE s5, 08[BS]                             ; control-h is backspace
 285  3255E                             JUMP Z, 55E[backspace]                         ; non-destructive backspace
 286  1D57F                             COMPARE s5, 7F[RUBOUT_CHAR]
 287  3255F                             JUMP Z, 55F[rubout]                            ; destructive backspace
 288  1D509                             COMPARE s5, 09[TAB_CHAR]
 289  32563                             JUMP Z, 563[htab]                              ; non-destructive TAB
 28A  1D50D                             COMPARE s5, 0D[CR]                             ; carriage return 0x0D ctrl-m
 28B  325D1                             JUMP Z, 5D1[carriage_return]
 28C  1D50A                             COMPARE s5, 0A[LF]                             ; line feed 0x0A ctrl-j
 28D  32592                             JUMP Z, 592[line_feed]
 28E  1D50C                             COMPARE s5, 0C[FORM_FEED_CHAR]                 ; FORM FEED ^L 0x0C
 28F  325A9                             JUMP Z, 5A9[form_feed]
 290  1D505                             COMPARE s5, 05[ENQ_CHAR]
 291  3255B                             JUMP Z, 55B[enquiry]
 292  1D507                             COMPARE s5, 07[BEL_CHAR]
 293  32603                             JUMP Z, 603[ring_bell]
 294                                    ; this is for debugging only *************************
 294  1D501                             COMPARE s5, 01                                 ; control-A
 295  32638                             JUMP Z, 638[test_pattern]
 296                      raw_char_out: ; if you don't want to process any control or escape codes
 296  2F03D                             STORE s0, 3D[scratchX]
 297  0DC08                             TEST sC[ANSI_FLAG_REG], 08[ANSI_HIDDEN]
 298  3229A                             JUMP Z, 29A[raw_vt_graphics]
 299  01520                             LOAD s5, 20                                    ; if we're hidden we only print spaces
 29A                   raw_vt_graphics: 
 29A  0B018                             FETCH s0, 18[extra_flags]
 29B  0D004                             TEST s0, 04[EXTRA_VT_GRAPHICS]
 29C  322A0                             JUMP Z, 2A0[raw_output]
 29D                           vt100_a: 
 29D                                    ;   COMPARE s5, "a"
 29D                                    ;   JUMP NZ, vt100_j
 29D                                    ;   LOAD s5, B1   ; checker board stipple graphic, ASCII 177
 29D                                    ;   JUMP NZ, raw_output
 29D                           vt100_j: 
 29D                                    ;   COMPARE s5, "j"
 29D                                    ;   JUMP NZ, vt100_k
 29D                                    ;   LOAD s5, DA   ; lower right corner graphic, ASCII 218
 29D                                    ;   JUMP NZ, raw_output
 29D                           vt100_k: 
 29D                                    ;   COMPARE s5, "k"
 29D                                    ;   JUMP NZ, vt100_l
 29D                                    ;   LOAD s5, C0   ; upper right corner graphic, ASCII 192
 29D                                    ;   JUMP NZ, raw_output
 29D                           vt100_l: 
 29D                                    ;   COMPARE s5, "l"
 29D                                    ;   JUMP NZ, vt100_m
 29D                                    ;   LOAD s5, D9   ; upper left corner graphic, ASCII 217
 29D                                    ;   JUMP NZ, raw_output
 29D                           vt100_m: 
 29D                                    ;   COMPARE s5, "m"
 29D                                    ;   JUMP NZ, vt100_n
 29D                                    ;   LOAD s5, BF   ; lower left corner graphic, ASCII 191
 29D                                    ;   JUMP NZ, raw_output
 29D                           vt100_n: 
 29D                                    ;   COMPARE s5, "n"
 29D                                    ;   JUMP NZ, vt100_q
 29D                                    ;   LOAD s5, C5   ; plus (line draw) graphic, ASCII 197
 29D                                    ;   JUMP NZ, raw_output
 29D                           vt100_q: ; we NEED this (q) character for nethack. the others are optional
 29D  1D571                             COMPARE s5, 71["q"]
 29E  362A0                             JUMP NZ, 2A0[vt100_t]
 29F  015C4                             LOAD s5, C4                                    ; horizontal line graphic, ASCII 196
 2A0                                    ;   JUMP NZ, raw_output
 2A0                           vt100_t: 
 2A0                                    ;   COMPARE s5, "t"
 2A0                                    ;   JUMP NZ, vt100_u
 2A0                                    ;   LOAD s5, C3   ; left tee graphic, ASCII 195
 2A0                                    ;   JUMP NZ, raw_output
 2A0                           vt100_u: 
 2A0                                    ;   COMPARE s5, "u"
 2A0                                    ;   JUMP NZ, vt100_v
 2A0                                    ;   LOAD s5, B4   ; right tee graphic, ASCII 180
 2A0                                    ;   JUMP NZ, raw_output
 2A0                           vt100_v: 
 2A0                                    ;   COMPARE s5, "v"
 2A0                                    ;   JUMP NZ, vt100_w
 2A0                                    ;   LOAD s5, C1   ; bottom tee graphic, ASCII 193
 2A0                                    ;   JUMP NZ, raw_output
 2A0                           vt100_w: 
 2A0                                    ;   COMPARE s5, "w"
 2A0                                    ;   JUMP NZ, vt100_x
 2A0                                    ;   LOAD s5, C2   ; top tee (flat side top) graphic, ASCII 194
 2A0                                    ;   JUMP NZ, raw_output
 2A0                           vt100_x: 
 2A0                                    ;   COMPARE s5, "x"
 2A0                                    ;   JUMP NZ, vt100_tilde
 2A0                                    ;   LOAD s5, B3   ; vertical line graphic, ASCII 179
 2A0                                    ;   JUMP NZ, raw_output
 2A0                       vt100_tilde: 
 2A0                                    ;   COMPARE s5, "~"
 2A0                                    ;   JUMP NZ, raw_output
 2A0                                    ;   LOAD s5, F9   ; bullet graphic, ASCII 249?
 2A0                        raw_output: 
 2A0  0B03D                             FETCH s0, 3D[scratchX]
 2A1  03CEF                             AND sC[ANSI_FLAG_REG], EF[ANSI_SSG2_CLR]       ; we clear it even if it's not already set. it's cheaper than testing it.
 2A2  2D504                             OUTPUT s5, 04[CHAR_PORT]
 2A3  2D609                             OUTPUT s6[COLOR_REG], 09[ATTR_PORT]
 2A4  2003C                             CALL 03C[advance_cursor]
 2A5  1DB68                             COMPARE sB[CURSOR_LOW], 68[MAX_LINE_LOWER]
 2A6  1FA1F                             COMPARECY sA[CURSOR_HIGH], 1F[MAX_LINE_UPPER]  ; are we at the end of the screen?
 2A7  35000                             RETURN NZ                                      ; no, we return
 2A8  20039                             CALL 039[decrement_cursor]
 2A9  2003E                             CALL 03E[set_cursor]
 2AA  205BA                             CALL 5BA[home_cursor]                          ; move
 2AB  225DC                             JUMP 5DC[scroll_up]
 2AC                                    ; these are the ANSI/ASCII functions.
 2AC                                    ; This is where we process control characters like backspace, cursor movement, carriage return, etc.
 2AC                                    ;
 2AC                   escape_received: ; we're not escaped and we just got an escape character
 2AC  05C02                             OR sC[ANSI_FLAG_REG], 02[ANSI_ESCAPE]
 2AD  25000                             RETURN 
 2AE                   escape_sequence: ; we're currently escaped and we just got another character
 2AE  1D55B                             COMPARE s5, 5B["["]
 2AF  362B3                             JUMP NZ, 2B3[not_csi]
 2B0  05C01                             OR sC[ANSI_FLAG_REG], 01[ANSI_CSI]
 2B1  202CA                             CALL 2CA[parse_csi_init]
 2B2  25000                             RETURN 
 2B3                           not_csi: 
 2B3                       save_cursor: 
 2B3  1D537                             COMPARE s5, 37["7"]
 2B4  362BA                             JUMP NZ, 2BA[restore_cursor]
 2B5  2FB32                             STORE sB[CURSOR_LOW], 32[saved_cursor_low]
 2B6  2FA33                             STORE sA[CURSOR_HIGH], 33[saved_cursor_high]
 2B7  2F634                             STORE s6[COLOR_REG], 34[saved_color_reg]
 2B8  2FC35                             STORE sC[ANSI_FLAG_REG], 35[saved_ansi_reg]
 2B9  222C8                             JUMP 2C8[end_csi]
 2BA                    restore_cursor: 
 2BA  1D538                             COMPARE s5, 38["8"]
 2BB  362C2                             JUMP NZ, 2C2[RSI]
 2BC  0BB32                             FETCH sB[CURSOR_LOW], 32[saved_cursor_low]
 2BD  0BA33                             FETCH sA[CURSOR_HIGH], 33[saved_cursor_high]
 2BE  0B634                             FETCH s6[COLOR_REG], 34[saved_color_reg]
 2BF  0BC35                             FETCH sC[ANSI_FLAG_REG], 35[saved_ansi_reg]
 2C0  2003E                             CALL 03E[set_cursor]
 2C1  222C8                             JUMP 2C8[end_csi]
 2C2                               RSI: ; reset the terminal
 2C2  1D563                             COMPARE s5, 63["c"]
 2C3  362C5                             JUMP NZ, 2C5[SSG2]
 2C4  22002                             JUMP 002[init_terminal]                        ; we re-initialize everything but we don't blow our stack. parasitic return
 2C5                                    ; JUMP cold_start   ; note that this will permanently eat part of our return stack.
 2C5                                    ; a blown stack causes a reset.
 2C5                                    ; we could add a hardware port to trigger our own reset pin
 2C5                                    ; or we could set a flag and not do the reset jump until we're at the top level of the call stack.
 2C5                                    ; or we could just do nothing...
 2C5                              SSG2: ; ESC-N without a CSI bracket is "single shift graphics 2". the next character received is treated literally.
 2C5  1D54E                             COMPARE s5, 4E["N"]
 2C6  362C8                             JUMP NZ, 2C8[end_csi]
 2C7  05C10                             OR sC[ANSI_FLAG_REG], 10[ANSI_SSG2]
 2C8                                    ; LOAD s4,"X"
 2C8                                    ; CALL debug_s4
 2C8                                    ; right now we only support CSI escape codes, not other escape codes
 2C8                                    ; so if ESCAPE is not followed by [ then we abort.
 2C8                           end_csi: 
 2C8  03CFD                             AND sC[ANSI_FLAG_REG], FD[ANSI_ESCAPE_CLR]     ; OK, we got an escape but the following key was meaningless so we cancel the escape
 2C9  25000                             RETURN 
 2CA                                    ;
 2CA                                    ; Parse CSI parameters
 2CA                                    ;
 2CA                                    ;
 2CA                                    ;
 2CA                                    ; So we store two things in RAM here. The list of parameters (each can be 0-255) is stored starting at RAM08 (param_block).
 2CA                                    ; There is room for a maximum of eight parameters in RAM.
 2CA                                    ; The value stored at RAM07 is the parameter count which tells us how many valid parameters there are stored. It can be zero.
 2CA                                    ;
 2CA                                    ; As we're processing decimal digits while parsing parameters we store them at RAM12 (digit_block) through RAM15. We can
 2CA                                    ; store a maximum of four digits but only if the first digit is a leading zero. In most cases if the value is greater than 255
 2CA                                    ; things will not work correctly.
 2CA                                    ;
 2CA                                    ; The number of decimal digits (so far) in the current parameter is stored in RAM11 (digit_counter).
 2CA                    parse_csi_init: ; we've just received the CSI intro sequence ESC-[
 2CA  01000                             LOAD s0, 00
 2CB  2F007                             STORE s0, 07[param_counter]
 2CC  2F011                             STORE s0, 11[digit_counter]
 2CD  25000                             RETURN 
 2CE  01008                start_clear: LOAD s0, 08[param_block]
 2CF  01100                             LOAD s1, 00
 2D0  2E100               clear_params: STORE s1, (s0)
 2D1  11001                             ADD s0, 01
 2D2  1D010                             COMPARE s0, 10[max_param]
 2D3  362D0                             JUMP NZ, 2D0[clear_params]
 2D4  25000                             RETURN 
 2D5                   parse_csi_digit: ; we've received something after the CSI and it's in s5
 2D5  1D53A                             COMPARE s5, 3A                                 ; digit '9' plus one
 2D6  3E2E1                             JUMP NC, 2E1[not_a_digit]                      ; we're above 9
 2D7  1D52F                             COMPARE s5, 2F                                 ; digit '0' minus one
 2D8  3A2E1                             JUMP C, 2E1[not_a_digit]
 2D9  322E1                             JUMP Z, 2E1[not_a_digit]                       ; we're below or equal to '0' minus one
 2DA                                    ; OK, we're a decimal digit
 2DA                     process_digit: 
 2DA  01012                             LOAD s0, 12[digit_block]
 2DB  0B111                             FETCH s1, 11[digit_counter]
 2DC  10010                             ADD s0, s1                                     ; calculate the storage address
 2DD  2E500                             STORE s5, (s0)
 2DE  11101                             ADD s1, 01                                     ; increment the number of digits
 2DF                                    ; COMPARE s1, max_param
 2DF                                    ; JUMP Z, exit_escape  ; return without storing the incremented value if we're at the limit
 2DF                                    ; we should probably abort the whole escape sequence at this point too, but either way we've lost sync with the host application
 2DF  2F111                             STORE s1, 11[digit_counter]
 2E0  25000                             RETURN 
 2E1                       not_a_digit: 
 2E1  20533                             CALL 533[end_param]                            ; finish up any parameter we've started
 2E2                   check_semicolon: 
 2E2  1D53B                             COMPARE s5, 3B[";"]
 2E3  362E5                             JUMP NZ, 2E5[csi_delete_line]
 2E4  25000                             RETURN 
 2E5                   csi_delete_line: ; delete the current line and scroll everything up
 2E5  1D54D                             COMPARE s5, 4D["M"]
 2E6  36302                             JUMP NZ, 302[csi_insert_line]
 2E7  2FB00                             STORE sB[CURSOR_LOW], 00[scratchLOW]
 2E8  2FA01                             STORE sA[CURSOR_HIGH], 01[scratchHIGH]
 2E9  205BA                             CALL 5BA[home_cursor]
 2EA  1DBF0                             COMPARE sB[CURSOR_LOW], F0[LAST_LINE_LOWER]
 2EB  1FA1E                             COMPARECY sA[CURSOR_HIGH], 1E[LAST_LINE_UPPER]
 2EC  32300                             JUMP Z, 300[end_delete_line_loop]              ; we're on the last line, so we just nuke it.
 2ED  00EB0                             LOAD sE, sB[CURSOR_LOW]
 2EE  00FA0                             LOAD sF, sA[CURSOR_HIGH]
 2EF  10ED0                             ADD sE, sD[CHAR_PER_LINE]                      ; this assumes we're deleting only one line
 2F0  13F00                             ADDCY sF, 00
 2F1                  delete_line_loop: ;;;;
 2F1  2DE03                             OUTPUT sE, 03[LSB_PORT]                        ; move to the source
 2F2  2DF02                             OUTPUT sF, 02[MSB_PORT]
 2F3  00000                             LOAD s0, s0                                    ; NOP
 2F4  09405                             INPUT s4, 05[CHAR_READ_PORT]                   ; read the source
 2F5  0950A                             INPUT s5, 0A[ATTR_READ_PORT]
 2F6  2003E                             CALL 03E[set_cursor]                           ; move the to destination
 2F7  2D404                             OUTPUT s4, 04[CHAR_PORT]                       ; write the destination
 2F8  2D509                             OUTPUT s5, 09[ATTR_PORT]
 2F9  11B01                             ADD sB[CURSOR_LOW], 01                         ; increment destination
 2FA  13A00                             ADDCY sA[CURSOR_HIGH], 00
 2FB  11E01                             ADD sE, 01                                     ; increment source
 2FC  13F00                             ADDCY sF, 00
 2FD  1DE68                             COMPARE sE, 68[MAX_LINE_LOWER]                 ; continue to end of screen
 2FE  1FF1F                             COMPARECY sF, 1F[MAX_LINE_UPPER]
 2FF  362F1                             JUMP NZ, 2F1[delete_line_loop]
 300              end_delete_line_loop: 
 300  205E6                             CALL 5E6[clear_last_line]
 301  22530                             JUMP 530[exit_escape]
 302                   csi_insert_line: 
 302  1D54C                             COMPARE s5, 4C["L"]
 303  36323                             JUMP NZ, 323[csi_erase_char]
 304  2FB00                             STORE sB[CURSOR_LOW], 00[scratchLOW]
 305  2FA01                             STORE sA[CURSOR_HIGH], 01[scratchHIGH]
 306  205BA                             CALL 5BA[home_cursor]
 307  002B0                             LOAD s2[DIVIDEND_LOW], sB[CURSOR_LOW]
 308  003A0                             LOAD s3[DIVIDEND_HIGH], sA[CURSOR_HIGH]
 309  01E68                             LOAD sE, 68[MAX_LINE_LOWER]
 30A  01F1F                             LOAD sF, 1F[MAX_LINE_UPPER]
 30B  19E01                             SUB sE, 01
 30C  1BF00                             SUBCY sF, 00
 30D  00BE0                             LOAD sB[CURSOR_LOW], sE
 30E  00AF0                             LOAD sA[CURSOR_HIGH], sF
 30F  18BD0                             SUB sB[CURSOR_LOW], sD[CHAR_PER_LINE]
 310  1BA00                             SUBCY sA[CURSOR_HIGH], 00
 311                  insert_line_loop: 
 311  2003E                             CALL 03E[set_cursor]
 312  09405                             INPUT s4, 05[CHAR_READ_PORT]
 313  0950A                             INPUT s5, 0A[ATTR_READ_PORT]
 314  2DE03                             OUTPUT sE, 03[LSB_PORT]
 315  2DF02                             OUTPUT sF, 02[MSB_PORT]
 316  00000                             LOAD s0, s0                                    ; NOP
 317  2D404                             OUTPUT s4, 04[CHAR_PORT]
 318  2D509                             OUTPUT s5, 09[ATTR_PORT]
 319  20039                             CALL 039[decrement_cursor]
 31A  19E01                             SUB sE, 01
 31B  1BF00                             SUBCY sF, 00
 31C  1CE20                             COMPARE sE, s2[DIVIDEND_LOW]
 31D  1EF30                             COMPARECY sF, s3[DIVIDEND_HIGH]
 31E  36311                             JUMP NZ, 311[insert_line_loop]
 31F  00B20                             LOAD sB[CURSOR_LOW], s2[DIVIDEND_LOW]
 320  00A30                             LOAD sA[CURSOR_HIGH], s3[DIVIDEND_HIGH]
 321  205F5                             CALL 5F5[clear_current_line]
 322  22530                             JUMP 530[exit_escape]
 323                    csi_erase_char: 
 323  1D558                             COMPARE s5, 58["X"]
 324  36336                             JUMP NZ, 336[csi_insert_char]
 325  2FB00                             STORE sB[CURSOR_LOW], 00[scratchLOW]
 326  2FA01                             STORE sA[CURSOR_HIGH], 01[scratchHIGH]
 327  0B008                             FETCH s0, 08[param_block]                      ; repeat count
 328  1D000                             COMPARE s0, 00
 329  3632B                             JUMP NZ, 32B[erase_char_loop]
 32A  11001                             ADD s0, 01
 32B                   erase_char_loop: 
 32B  01520                             LOAD s5, 20
 32C  2D504                             OUTPUT s5, 04[CHAR_PORT]
 32D  2D609                             OUTPUT s6[COLOR_REG], 09[ATTR_PORT]
 32E  2003C                             CALL 03C[advance_cursor]
 32F  19001                             SUB s0, 01
 330  1D000                             COMPARE s0, 00
 331  3632B                             JUMP NZ, 32B[erase_char_loop]
 332  0BB00                             FETCH sB[CURSOR_LOW], 00[scratchLOW]
 333  0BA01                             FETCH sA[CURSOR_HIGH], 01[scratchHIGH]
 334  2003E                             CALL 03E[set_cursor]
 335  22530                             JUMP 530[exit_escape]
 336                   csi_insert_char: 
 336  1D540                             COMPARE s5, 40["@"]
 337  36359                             JUMP NZ, 359[csi_delete_char]
 338  0B108                             FETCH s1, 08[param_block]
 339  1D100                             COMPARE s1, 00
 33A  3633C                             JUMP NZ, 33C[insert_loop]
 33B  11101                             ADD s1, 01
 33C                       insert_loop: 
 33C  2FB00                             STORE sB[CURSOR_LOW], 00[scratchLOW]
 33D  2FA01                             STORE sA[CURSOR_HIGH], 01[scratchHIGH]
 33E  20693                             CALL 693[get_row_column_plus]
 33F  000D0                             LOAD s0, sD[CHAR_PER_LINE]
 340  180E0                             SUB s0, sE                                     ; s0 now contains the number of characters to the end of the line
 341  19001                             SUB s0, 01
 342  10B00                             ADD sB[CURSOR_LOW], s0
 343  13A00                             ADDCY sA[CURSOR_HIGH], 00
 344  2003E                             CALL 03E[set_cursor]
 345  11001                             ADD s0, 01
 346                       insert_next: 
 346  09405                             INPUT s4, 05[CHAR_READ_PORT]
 347  0950A                             INPUT s5, 0A[ATTR_READ_PORT]
 348  2003C                             CALL 03C[advance_cursor]
 349  2D404                             OUTPUT s4, 04[CHAR_PORT]
 34A  2D509                             OUTPUT s5, 09[ATTR_PORT]
 34B  19B02                             SUB sB[CURSOR_LOW], 02
 34C  1BA00                             SUBCY sA[CURSOR_HIGH], 00
 34D  2003E                             CALL 03E[set_cursor]
 34E  19001                             SUB s0, 01
 34F  1D000                             COMPARE s0, 00
 350  36346                             JUMP NZ, 346[insert_next]
 351  2003C                             CALL 03C[advance_cursor]
 352  01420                             LOAD s4, 20
 353  2D404                             OUTPUT s4, 04[CHAR_PORT]
 354  2D609                             OUTPUT s6[COLOR_REG], 09[ATTR_PORT]
 355  19101                             SUB s1, 01
 356  1D100                             COMPARE s1, 00
 357  3633C                             JUMP NZ, 33C[insert_loop]
 358  22530                             JUMP 530[exit_escape]
 359                                    ;FETCH CURSOR_LOW, scratchLOW
 359                                    ;FETCH CURSOR_HIGH, scratchHIGH
 359                                    ;CALL set_cursor
 359                   csi_delete_char: ; delete character forward and shift line
 359  1D550                             COMPARE s5, 50["P"]
 35A  3637B                             JUMP NZ, 37B[csi_clear]
 35B  0B108                             FETCH s1, 08[param_block]
 35C  1D100                             COMPARE s1, 00
 35D  3635F                             JUMP NZ, 35F[delete_loop]
 35E  11101                             ADD s1, 01
 35F                       delete_loop: 
 35F  2FB00                             STORE sB[CURSOR_LOW], 00[scratchLOW]
 360  2FA01                             STORE sA[CURSOR_HIGH], 01[scratchHIGH]
 361  20693                             CALL 693[get_row_column_plus]
 362  000D0                             LOAD s0, sD[CHAR_PER_LINE]
 363  180E0                             SUB s0, sE                                     ; s0 now contains the number of characters to the end of the line
 364                       delete_next: 
 364  2003C                             CALL 03C[advance_cursor]
 365  09405                             INPUT s4, 05[CHAR_READ_PORT]
 366  0950A                             INPUT s5, 0A[ATTR_READ_PORT]
 367  20039                             CALL 039[decrement_cursor]
 368  2003E                             CALL 03E[set_cursor]
 369  2D404                             OUTPUT s4, 04[CHAR_PORT]
 36A  2D509                             OUTPUT s5, 09[ATTR_PORT]
 36B  11B01                             ADD sB[CURSOR_LOW], 01
 36C  11A00                             ADD sA[CURSOR_HIGH], 00
 36D  19001                             SUB s0, 01
 36E  1D000                             COMPARE s0, 00
 36F  36364                             JUMP NZ, 364[delete_next]
 370  2003E                             CALL 03E[set_cursor]
 371  01420                             LOAD s4, 20
 372  2D404                             OUTPUT s4, 04[CHAR_PORT]
 373  2D609                             OUTPUT s6[COLOR_REG], 09[ATTR_PORT]
 374  0BB00                             FETCH sB[CURSOR_LOW], 00[scratchLOW]
 375  0BA01                             FETCH sA[CURSOR_HIGH], 01[scratchHIGH]
 376  2003E                             CALL 03E[set_cursor]
 377  19101                             SUB s1, 01
 378  1D100                             COMPARE s1, 00
 379  3635F                             JUMP NZ, 35F[delete_loop]
 37A  22530                             JUMP 530[exit_escape]
 37B                         csi_clear: ; we currently ignore the parameter. we're acting as if the parameter is "2".********************************************
 37B  1D54A                             COMPARE s5, 4A["J"]
 37C  36388                             JUMP NZ, 388[csi_sgr]
 37D                                    ;CALL form_feed
 37D  0B008                             FETCH s0, 08[param_block]
 37E  1D002                             COMPARE s0, 02
 37F  36382                             JUMP NZ, 382[partial_clear]
 380  205A9                             CALL 5A9[form_feed]
 381  22530                             JUMP 530[exit_escape]
 382                     partial_clear: 
 382  1D001                             COMPARE s0, 01
 383  36386                             JUMP NZ, 386[end_clear]
 384  20599                             CALL 599[clear_start_screen]
 385  22530                             JUMP 530[exit_escape]
 386                         end_clear: 
 386  205AB                             CALL 5AB[clear_end_screen]
 387  22530                             JUMP 530[exit_escape]
 388                           csi_sgr: ; select graphics rendition, this is the big one
 388  1D56D                             COMPARE s5, 6D["m"]
 389  36416                             JUMP NZ, 416[csi_move]
 38A  0B007                             FETCH s0, 07[param_counter]
 38B  01108                             LOAD s1, 08[param_block]
 38C  10010                             ADD s0, s1
 38D                         sgr_param: 
 38D  0A410                             FETCH s4, (s1)
 38E                         sgr_reset: 
 38E  1D400                             COMPARE s4, 00                                 ; 00 means reset all values
 38F  36399                             JUMP NZ, 399[sgr_bold]
 390  01670                             LOAD s6[COLOR_REG], 70                         ; default of dim white foreground black background
 391  03CFB                             AND sC[ANSI_FLAG_REG], FB[ANSI_INVERSE_CLR]
 392  03CF7                             AND sC[ANSI_FLAG_REG], F7[ANSI_HIDDEN_CLR]
 393  2F039                             STORE s0, 39[scratchT]
 394  0B018                             FETCH s0, 18[extra_flags]
 395  030FB                             AND s0, FB[EXTRA_VT_GRAPHICS_CLR]              ; is this right or do we require CSI 10 m instead?
 396  2F018                             STORE s0, 18[extra_flags]
 397  0B039                             FETCH s0, 39[scratchT]
 398  22412                             JUMP 412[sgr_next]
 399                          sgr_bold: ; setting the high bit of foreground color makes it "bold" by choosing brighter colors
 399  1D401                             COMPARE s4, 01
 39A  363A1                             JUMP NZ, 3A1[sgr_blink]
 39B  0DC04                             TEST sC[ANSI_FLAG_REG], 04[ANSI_INVERSE]
 39C  3454E                             CALL NZ, 54E[invert_colors]
 39D  05680                             OR s6[COLOR_REG], 80
 39E  0DC04                             TEST sC[ANSI_FLAG_REG], 04[ANSI_INVERSE]
 39F  3454E                             CALL NZ, 54E[invert_colors]
 3A0  22412                             JUMP 412[sgr_next]
 3A1                         sgr_blink: ; high bit of background color
 3A1  1D405                             COMPARE s4, 05
 3A2  363A9                             JUMP NZ, 3A9[sgr_inverse]
 3A3  0DC04                             TEST sC[ANSI_FLAG_REG], 04[ANSI_INVERSE]
 3A4  3454E                             CALL NZ, 54E[invert_colors]
 3A5  05608                             OR s6[COLOR_REG], 08
 3A6  0DC04                             TEST sC[ANSI_FLAG_REG], 04[ANSI_INVERSE]
 3A7  3454E                             CALL NZ, 54E[invert_colors]
 3A8  22412                             JUMP 412[sgr_next]
 3A9                       sgr_inverse: 
 3A9  1D407                             COMPARE s4, 07
 3AA  363B0                             JUMP NZ, 3B0[sgr_hidden]
 3AB  0DC04                             TEST sC[ANSI_FLAG_REG], 04[ANSI_INVERSE]       ; don't invert if we're already inverted
 3AC  36412                             JUMP NZ, 412[sgr_next]
 3AD  2054E                             CALL 54E[invert_colors]
 3AE  05C04                             OR sC[ANSI_FLAG_REG], 04[ANSI_INVERSE]
 3AF  22412                             JUMP 412[sgr_next]
 3B0                        sgr_hidden: ; turns on hidden mode- spaces will be printed instead of symbols
 3B0  1D408                             COMPARE s4, 08
 3B1  363B4                             JUMP NZ, 3B4[sgr_no_vt_graphics]
 3B2  05C08                             OR sC[ANSI_FLAG_REG], 08[ANSI_HIDDEN]
 3B3  22412                             JUMP 412[sgr_next]
 3B4                sgr_no_vt_graphics: 
 3B4  1D40A                             COMPARE s4, 0A
 3B5  363BC                             JUMP NZ, 3BC[sgr_vt_graphics]
 3B6  2F039                             STORE s0, 39[scratchT]
 3B7  0B018                             FETCH s0, 18[extra_flags]
 3B8  030FB                             AND s0, FB[EXTRA_VT_GRAPHICS_CLR]
 3B9  2F018                             STORE s0, 18[extra_flags]
 3BA  0B039                             FETCH s0, 39[scratchT]
 3BB  22412                             JUMP 412[sgr_next]
 3BC                   sgr_vt_graphics: 
 3BC  1D40B                             COMPARE s4, 0B
 3BD  363C4                             JUMP NZ, 3C4[sgr_reveal]
 3BE  2F039                             STORE s0, 39[scratchT]
 3BF  0B018                             FETCH s0, 18[extra_flags]
 3C0  05004                             OR s0, 04[EXTRA_VT_GRAPHICS]
 3C1  2F018                             STORE s0, 18[extra_flags]
 3C2  0B039                             FETCH s0, 39[scratchT]
 3C3  22412                             JUMP 412[sgr_next]
 3C4                        sgr_reveal: ; turns off hidden mode.
 3C4  1D41C                             COMPARE s4, 1C[28'd]
 3C5  363C8                             JUMP NZ, 3C8[sgr_normal_intensity]
 3C6  03CF7                             AND sC[ANSI_FLAG_REG], F7[ANSI_HIDDEN_CLR]
 3C7  22412                             JUMP 412[sgr_next]
 3C8              sgr_normal_intensity: ; turn off boldface
 3C8  1D416                             COMPARE s4, 16[22'd]
 3C9  363D0                             JUMP NZ, 3D0[sgr_blink_off]
 3CA  0DC04                             TEST sC[ANSI_FLAG_REG], 04[ANSI_INVERSE]
 3CB  3454E                             CALL NZ, 54E[invert_colors]
 3CC  0367F                             AND s6[COLOR_REG], 7F
 3CD  0DC04                             TEST sC[ANSI_FLAG_REG], 04[ANSI_INVERSE]
 3CE  3454E                             CALL NZ, 54E[invert_colors]
 3CF  22412                             JUMP 412[sgr_next]
 3D0                     sgr_blink_off: ; turn off blink
 3D0  1D419                             COMPARE s4, 19[25'd]
 3D1  363D8                             JUMP NZ, 3D8[sgr_positive]
 3D2  0DC04                             TEST sC[ANSI_FLAG_REG], 04[ANSI_INVERSE]
 3D3  3454E                             CALL NZ, 54E[invert_colors]
 3D4  036F7                             AND s6[COLOR_REG], F7
 3D5  0DC04                             TEST sC[ANSI_FLAG_REG], 04[ANSI_INVERSE]
 3D6  3454E                             CALL NZ, 54E[invert_colors]
 3D7  22412                             JUMP 412[sgr_next]
 3D8                      sgr_positive: ; turn off inverse video
 3D8  1D41B                             COMPARE s4, 1B[27'd]
 3D9  363DF                             JUMP NZ, 3DF[sgr_default_foreground]
 3DA  0DC04                             TEST sC[ANSI_FLAG_REG], 04[ANSI_INVERSE]
 3DB  32412                             JUMP Z, 412[sgr_next]
 3DC  2054E                             CALL 54E[invert_colors]
 3DD  03CFB                             AND sC[ANSI_FLAG_REG], FB[ANSI_INVERSE_CLR]
 3DE  22412                             JUMP 412[sgr_next]
 3DF            sgr_default_foreground: 
 3DF  1D427                             COMPARE s4, 27[39'd]
 3E0  363E8                             JUMP NZ, 3E8[sgr_default_background]
 3E1  0DC04                             TEST sC[ANSI_FLAG_REG], 04[ANSI_INVERSE]
 3E2  3454E                             CALL NZ, 54E[invert_colors]
 3E3  0360F                             AND s6[COLOR_REG], 0F
 3E4  05670                             OR s6[COLOR_REG], 70
 3E5  0DC04                             TEST sC[ANSI_FLAG_REG], 04[ANSI_INVERSE]
 3E6  3454E                             CALL NZ, 54E[invert_colors]
 3E7  22412                             JUMP 412[sgr_next]
 3E8            sgr_default_background: 
 3E8  1D431                             COMPARE s4, 31[49'd]
 3E9  363F0                             JUMP NZ, 3F0[sgr_foreground]
 3EA  0DC04                             TEST sC[ANSI_FLAG_REG], 04[ANSI_INVERSE]
 3EB  3454E                             CALL NZ, 54E[invert_colors]
 3EC  036F0                             AND s6[COLOR_REG], F0
 3ED  0DC04                             TEST sC[ANSI_FLAG_REG], 04[ANSI_INVERSE]
 3EE  3454E                             CALL NZ, 54E[invert_colors]
 3EF  22412                             JUMP 412[sgr_next]
 3F0                    sgr_foreground: 
 3F0  1D426                             COMPARE s4, 26[38'd]                           ; highest foreground color plus one
 3F1  3E403                             JUMP NC, 403[sgr_background]
 3F2  0151D                             LOAD s5, 1D[29'd]                              ; lowest foreground color minus one
 3F3  1C540                             COMPARE s5, s4
 3F4  3E403                             JUMP NC, 403[sgr_background]
 3F5                                    ; OK, we're in the range 30-37
 3F5  0DC04                             TEST sC[ANSI_FLAG_REG], 04[ANSI_INVERSE]       ; swap the colors if we need to
 3F6  3454E                             CALL NZ, 54E[invert_colors]
 3F7  2F43D                             STORE s4, 3D[scratchX]
 3F8  1941E                             SUB s4, 1E[30'd]                               ; normalize to zero
 3F9  0368F                             AND s6[COLOR_REG], 8F                          ; clear the three bits we're interested in
 3FA  14406                             SL0 s4
 3FB  14406                             SL0 s4
 3FC  14406                             SL0 s4
 3FD  14406                             SL0 s4
 3FE  10640                             ADD s6[COLOR_REG], s4                          ; and set the new value
 3FF  0DC04                             TEST sC[ANSI_FLAG_REG], 04[ANSI_INVERSE]       ; swap the colors back if we need to
 400  3454E                             CALL NZ, 54E[invert_colors]
 401  0B43D                             FETCH s4, 3D[scratchX]
 402  22412                             JUMP 412[sgr_next]
 403                    sgr_background: 
 403  1D430                             COMPARE s4, 30[48'd]                           ; highest background color plus one
 404  3E412                             JUMP NC, 412[sgr_other]
 405  01527                             LOAD s5, 27[39'd]                              ; lowest background color minus one
 406  1C540                             COMPARE s5, s4
 407  3E412                             JUMP NC, 412[sgr_other]
 408                                    ; OK, we're in the range 40-37
 408  0DC04                             TEST sC[ANSI_FLAG_REG], 04[ANSI_INVERSE]       ; swap the colors if we need to
 409  3454E                             CALL NZ, 54E[invert_colors]
 40A  2F43D                             STORE s4, 3D[scratchX]
 40B  19428                             SUB s4, 28[40'd]                               ; normalize to zero
 40C  036F8                             AND s6[COLOR_REG], F8                          ; clear the three bits we're interested in
 40D  10640                             ADD s6[COLOR_REG], s4                          ; and set the new value
 40E  0DC04                             TEST sC[ANSI_FLAG_REG], 04[ANSI_INVERSE]       ; swap the colors back if we need to
 40F  3454E                             CALL NZ, 54E[invert_colors]
 410  0B43D                             FETCH s4, 3D[scratchX]
 411  22412                             JUMP 412[sgr_next]
 412                         sgr_other: 
 412                          sgr_next: 
 412  11101                             ADD s1, 01
 413  1C100                             COMPARE s1, s0
 414  3638D                             JUMP NZ, 38D[sgr_param]                        ; get the next one until we're done
 415                           sgr_end: 
 415  22530                             JUMP 530[exit_escape]
 416                          csi_move: ; set cursor position Y,X
 416  1D548                             COMPARE s5, 48["H"]
 417  3241A                             JUMP Z, 41A[csi_move2]
 418  1D566                             COMPARE s5, 66["f"]
 419  3643A                             JUMP NZ, 43A[csi_set_row]
 41A                         csi_move2: 
 41A  0B007                             FETCH s0, 07[param_counter]
 41B  1D002                             COMPARE s0, 02                                 ; do we have exactly two parameters?
 41C  3241F                             JUMP Z, 41F[two_params]
 41D  01000                             LOAD s0, 00
 41E  2F009                             STORE s0, 09[param_two]
 41F  01008                 two_params: LOAD s0, 08[param_block]
 420  0A100                             FETCH s1, (s0)
 421  1D100                             COMPARE s1, 00                                 ; if we're already zero we don't subtract
 422  32424                             JUMP Z, 424[move_y0]
 423  19101                             SUB s1, 01                                     ; we're zero based
 424                           move_y0: 
 424  1D143                             COMPARE s1, 43[MAX_LINE]
 425  3A428                             JUMP C, 428[move_y00]                          ; clip to the bottom edge
 426  01143                             LOAD s1, 43[MAX_LINE]
 427  19101                             SUB s1, 01
 428                          move_y00: 
 428  00810                             LOAD s8[DIVISOR_LOW], s1
 429  009D0                             LOAD s9[DIVISOR_HIGH], sD[CHAR_PER_LINE]
 42A  206BD                             CALL 6BD[mult_8x8]
 42B  00A30                             LOAD sA[CURSOR_HIGH], s3[DIVIDEND_HIGH]
 42C  00B40                             LOAD sB[CURSOR_LOW], s4
 42D  11001                             ADD s0, 01
 42E  0A100                             FETCH s1, (s0)
 42F  1D100                             COMPARE s1, 00                                 ;if we're already zero we don't subtract
 430  32432                             JUMP Z, 432[move_x0]
 431  19101                             SUB s1, 01                                     ; we're zero based
 432                           move_x0: 
 432  1C1D0                             COMPARE s1, sD[CHAR_PER_LINE]
 433  3A436                             JUMP C, 436[move_x00]                          ; clip to the right edge
 434  001D0                             LOAD s1, sD[CHAR_PER_LINE]
 435  19101                             SUB s1, 01
 436                          move_x00: 
 436  10B10                             ADD sB[CURSOR_LOW], s1
 437  13A00                             ADDCY sA[CURSOR_HIGH], 00
 438  2003E                             CALL 03E[set_cursor]
 439  22530                             JUMP 530[exit_escape]
 43A                       csi_set_row: 
 43A  1D564                             COMPARE s5, 64["d"]
 43B  36450                             JUMP NZ, 450[csi_set_column]
 43C  0B008                             FETCH s0, 08[param_block]
 43D  1D000                             COMPARE s0, 00
 43E  32440                             JUMP Z, 440[row_0]
 43F  19001                             SUB s0, 01
 440                             row_0: 
 440  1D043                             COMPARE s0, 43[MAX_LINE]
 441  3A444                             JUMP C, 444[row_00]
 442  01043                             LOAD s0, 43[MAX_LINE]                          ; clip to the bottom edge
 443  19001                             SUB s0, 01
 444                            row_00: 
 444  2F03D                             STORE s0, 3D[scratchX]
 445  20698                             CALL 698[get_row_column]
 446  0B03D                             FETCH s0, 3D[scratchX]
 447  00800                             LOAD s8[DIVISOR_LOW], s0
 448  009D0                             LOAD s9[DIVISOR_HIGH], sD[CHAR_PER_LINE]
 449  206BD                             CALL 6BD[mult_8x8]
 44A  00A30                             LOAD sA[CURSOR_HIGH], s3[DIVIDEND_HIGH]
 44B  00B40                             LOAD sB[CURSOR_LOW], s4
 44C  10BE0                             ADD sB[CURSOR_LOW], sE
 44D  13A00                             ADDCY sA[CURSOR_HIGH], 00
 44E  2003E                             CALL 03E[set_cursor]
 44F  22530                             JUMP 530[exit_escape]
 450                    csi_set_column: 
 450  1D547                             COMPARE s5, 47["G"]
 451  36466                             JUMP NZ, 466[csi_repeat]
 452  0B008                             FETCH s0, 08[param_block]
 453  1D000                             COMPARE s0, 00
 454  32456                             JUMP Z, 456[column_0]
 455  19001                             SUB s0, 01
 456                          column_0: 
 456  1C0D0                             COMPARE s0, sD[CHAR_PER_LINE]
 457  3A45A                             JUMP C, 45A[column_00]
 458  000D0                             LOAD s0, sD[CHAR_PER_LINE]                     ; clip to the right edge
 459  19001                             SUB s0, 01
 45A                         column_00: 
 45A  2F03D                             STORE s0, 3D[scratchX]
 45B  20698                             CALL 698[get_row_column]
 45C  00820                             LOAD s8[DIVISOR_LOW], s2[DIVIDEND_LOW]
 45D  009D0                             LOAD s9[DIVISOR_HIGH], sD[CHAR_PER_LINE]
 45E  206BD                             CALL 6BD[mult_8x8]
 45F  00A30                             LOAD sA[CURSOR_HIGH], s3[DIVIDEND_HIGH]
 460  00B40                             LOAD sB[CURSOR_LOW], s4
 461  0B03D                             FETCH s0, 3D[scratchX]
 462  10B00                             ADD sB[CURSOR_LOW], s0
 463  13A00                             ADDCY sA[CURSOR_HIGH], 00
 464  2003E                             CALL 03E[set_cursor]
 465  22530                             JUMP 530[exit_escape]
 466                        csi_repeat: 
 466  1D562                             COMPARE s5, 62["b"]
 467  36478                             JUMP NZ, 478[csi_clear_line]
 468  03CFD                             AND sC[ANSI_FLAG_REG], FD[ANSI_ESCAPE_CLR]
 469  03CFE                             AND sC[ANSI_FLAG_REG], FE[ANSI_CSI_CLR]
 46A  2F537                             STORE s5, 37[scratchR]
 46B  0B008                             FETCH s0, 08[param_block]
 46C  1D000                             COMPARE s0, 00
 46D  3646F                             JUMP NZ, 46F[repeat_loop]
 46E  11001                             ADD s0, 01                                     ; treat zero as one
 46F                       repeat_loop: 
 46F  0B531                             FETCH s5, 31[last_char]                        ; do this every time?
 470  2F036                             STORE s0, 36[scratchQ]
 471  20296                             CALL 296[raw_char_out]
 472  0B036                             FETCH s0, 36[scratchQ]
 473  19001                             SUB s0, 01
 474  1D000                             COMPARE s0, 00
 475  3646F                             JUMP NZ, 46F[repeat_loop]
 476  0B537                             FETCH s5, 37[scratchR]
 477  25000                             RETURN 
 478                    csi_clear_line: 
 478  1D54B                             COMPARE s5, 4B["K"]                            ; ANSI.SYS ignores the parameter and always clears right
 479  364A4                             JUMP NZ, 4A4[csi_up]                           ; the spec says parameter 1 clears left, 2 clears whole line
 47A  2FB00                             STORE sB[CURSOR_LOW], 00[scratchLOW]
 47B  2FA01                             STORE sA[CURSOR_HIGH], 01[scratchHIGH]
 47C  20693                             CALL 693[get_row_column_plus]
 47D  0B408                             FETCH s4, 08[param_block]
 47E  1D400                             COMPARE s4, 00
 47F  32492                             JUMP Z, 492[clear_eol]                         ; end of line
 480  1D401                             COMPARE s4, 01
 481  32489                             JUMP Z, 489[clear_sol]                         ; start of line
 482                  clear_whole_line: 
 482  19E01                             SUB sE, 01
 483  18BE0                             SUB sB[CURSOR_LOW], sE
 484  1BA00                             SUBCY sA[CURSOR_HIGH], 00
 485  2003E                             CALL 03E[set_cursor]                           ; we're at the start of the line
 486  00ED0                             LOAD sE, sD[CHAR_PER_LINE]
 487  01400                             LOAD s4, 00
 488  2249A                             JUMP 49A[clear_eol_loop]
 489                         clear_sol: 
 489  01400                             LOAD s4, 00
 48A                                    ;ADD sE, 01
 48A                    clear_sol_loop: 
 48A  2D404                             OUTPUT s4, 04[CHAR_PORT]
 48B  2D609                             OUTPUT s6[COLOR_REG], 09[ATTR_PORT]
 48C  20039                             CALL 039[decrement_cursor]
 48D  2003E                             CALL 03E[set_cursor]
 48E  19E01                             SUB sE, 01
 48F  1DE00                             COMPARE sE, 00
 490  3648A                             JUMP NZ, 48A[clear_sol_loop]
 491  224A0                             JUMP 4A0[finish_clear_line]
 492                         clear_eol: 
 492  004D0                             LOAD s4, sD[CHAR_PER_LINE]
 493  11401                             ADD s4, 01                                     ; we should just define another constant and remove this instruction
 494  184E0                             SUB s4, sE                                     ; invert it to get remaining characters
 495  00E40                             LOAD sE, s4
 496  01400                             LOAD s4, 00
 497  1DE00                             COMPARE sE, 00
 498  3649A                             JUMP NZ, 49A[clear_eol_loop]
 499  00ED0                             LOAD sE, sD[CHAR_PER_LINE]                     ; we're at the beginning of the line so we do it all
 49A                    clear_eol_loop: 
 49A  2D404                             OUTPUT s4, 04[CHAR_PORT]
 49B  2D609                             OUTPUT s6[COLOR_REG], 09[ATTR_PORT]
 49C  2003C                             CALL 03C[advance_cursor]
 49D  19E01                             SUB sE, 01
 49E  1DE00                             COMPARE sE, 00                                 ; sE is the line remainder
 49F  3649A                             JUMP NZ, 49A[clear_eol_loop]
 4A0                 finish_clear_line: 
 4A0  0BB00                             FETCH sB[CURSOR_LOW], 00[scratchLOW]
 4A1  0BA01                             FETCH sA[CURSOR_HIGH], 01[scratchHIGH]
 4A2  2003E                             CALL 03E[set_cursor]
 4A3  22530                             JUMP 530[exit_escape]
 4A4                            csi_up: 
 4A4  1D541                             COMPARE s5, 41["A"]                            ; we're going UP
 4A5  364AE                             JUMP NZ, 4AE[csi_down]
 4A6  0B108                             FETCH s1, 08[param_block]
 4A7  1D100                             COMPARE s1, 00
 4A8  364AA                             JUMP NZ, 4AA[up_loop]
 4A9  11101                             ADD s1, 01
 4AA                           up_loop: 
 4AA  20584                             CALL 584[line_up]
 4AB  19101                             SUB s1, 01
 4AC  364AA                             JUMP NZ, 4AA[up_loop]
 4AD  22530                             JUMP 530[exit_escape]
 4AE                          csi_down: 
 4AE  1D542                             COMPARE s5, 42["B"]
 4AF  364B8                             JUMP NZ, 4B8[csi_right]
 4B0  0B108                             FETCH s1, 08[param_block]
 4B1  1D100                             COMPARE s1, 00
 4B2  364B4                             JUMP NZ, 4B4[down_loop]
 4B3  11101                             ADD s1, 01
 4B4                         down_loop: 
 4B4  2058B                             CALL 58B[line_down]
 4B5  19101                             SUB s1, 01
 4B6  364B4                             JUMP NZ, 4B4[down_loop]
 4B7  22530                             JUMP 530[exit_escape]
 4B8                         csi_right: 
 4B8  1D543                             COMPARE s5, 43["C"]
 4B9  364C6                             JUMP NZ, 4C6[csi_left]
 4BA  0B008                             FETCH s0, 08[param_block]
 4BB  1D000                             COMPARE s0, 00
 4BC  364BF                             JUMP NZ, 4BF[one_right]
 4BD  11001                             ADD s0, 01                                     ; if the param is zero make it one
 4BE  2F008                             STORE s0, 08[param_block]
 4BF                         one_right: 
 4BF  2057E                             CALL 57E[right_cursor]
 4C0  0B008                             FETCH s0, 08[param_block]
 4C1  19001                             SUB s0, 01
 4C2  2F008                             STORE s0, 08[param_block]
 4C3  1D000                             COMPARE s0, 00
 4C4  364BF                             JUMP NZ, 4BF[one_right]
 4C5  22530                             JUMP 530[exit_escape]                          ;
 4C6                          csi_left: 
 4C6  1D544                             COMPARE s5, 44["D"]
 4C7  364D4                             JUMP NZ, 4D4[csi_back_tab]
 4C8  0B008                             FETCH s0, 08[param_block]
 4C9  1D000                             COMPARE s0, 00
 4CA  364CD                             JUMP NZ, 4CD[one_left]
 4CB  11001                             ADD s0, 01                                     ; if the param is zero make it one
 4CC  2F008                             STORE s0, 08[param_block]
 4CD                          one_left: 
 4CD  20577                             CALL 577[left_cursor]
 4CE  0B008                             FETCH s0, 08[param_block]
 4CF  19001                             SUB s0, 01
 4D0  2F008                             STORE s0, 08[param_block]
 4D1  1D000                             COMPARE s0, 00
 4D2  364CD                             JUMP NZ, 4CD[one_left]
 4D3  22530                             JUMP 530[exit_escape]
 4D4                      csi_back_tab: 
 4D4  1D55A                             COMPARE s5, 5A["Z"]
 4D5  364E1                             JUMP NZ, 4E1[csi_tab]
 4D6  0B108                             FETCH s1, 08[param_block]
 4D7  1D100                             COMPARE s1, 00
 4D8  364DA                             JUMP NZ, 4DA[back_tab_loop]
 4D9  11101                             ADD s1, 01
 4DA                     back_tab_loop: 
 4DA  2F13D                             STORE s1, 3D[scratchX]
 4DB  2056A                             CALL 56A[backtab]
 4DC  0B13D                             FETCH s1, 3D[scratchX]
 4DD  19101                             SUB s1, 01
 4DE  1D100                             COMPARE s1, 00
 4DF  364DA                             JUMP NZ, 4DA[back_tab_loop]
 4E0  22530                             JUMP 530[exit_escape]
 4E1                           csi_tab: ; need to support paramter *****************************************
 4E1  1D549                             COMPARE s5, 49["I"]
 4E2  364EE                             JUMP NZ, 4EE[csi_device_status_report]
 4E3  0B108                             FETCH s1, 08[param_block]
 4E4  1D100                             COMPARE s1, 00
 4E5  364E7                             JUMP NZ, 4E7[tab_loop]
 4E6  11101                             ADD s1, 01
 4E7                          tab_loop: 
 4E7  2F13D                             STORE s1, 3D[scratchX]
 4E8  20563                             CALL 563[htab]
 4E9  0B13D                             FETCH s1, 3D[scratchX]
 4EA  19101                             SUB s1, 01
 4EB  1D100                             COMPARE s1, 00
 4EC  364E7                             JUMP NZ, 4E7[tab_loop]
 4ED  22530                             JUMP 530[exit_escape]
 4EE          csi_device_status_report: 
 4EE  1D56E                             COMPARE s5, 6E["n"]
 4EF  3650E                             JUMP NZ, 50E[csi_margins]
 4F0  0B008                             FETCH s0, 08[param_block]
 4F1  1D006                             COMPARE s0, 06
 4F2  3650D                             JUMP NZ, 50D[DSR_other]
 4F3              send_position_report: ; note that this will not be echoed locally- just remote.
 4F3  2FB00                             STORE sB[CURSOR_LOW], 00[scratchLOW]
 4F4  2FA01                             STORE sA[CURSOR_HIGH], 01[scratchHIGH]
 4F5  2F43D                             STORE s4, 3D[scratchX]
 4F6  2F53E                             STORE s5, 3E[scratchY]
 4F7  0151B                             LOAD s5, 1B
 4F8  2078B                             CALL 78B[UART_TX]                              ; send the CSI only to the serial port, no local echo for this
 4F9  0155B                             LOAD s5, 5B["["]
 4FA  2078B                             CALL 78B[UART_TX]
 4FB  20698                             CALL 698[get_row_column]
 4FC  2FE3F                             STORE sE, 3F[scratchZ]
 4FD  11201                             ADD s2[DIVIDEND_LOW], 01
 4FE  13300                             ADDCY s3[DIVIDEND_HIGH], 00
 4FF  206C8                             CALL 6C8[send_integer]
 500  0153B                             LOAD s5, 3B[";"]
 501  2078B                             CALL 78B[UART_TX]
 502  0B23F                             FETCH s2[DIVIDEND_LOW], 3F[scratchZ]
 503  01300                             LOAD s3[DIVIDEND_HIGH], 00
 504  11201                             ADD s2[DIVIDEND_LOW], 01
 505  13300                             ADDCY s3[DIVIDEND_HIGH], 00
 506                                    ;LOAD DIVIDEND_HIGH, 00
 506  206C8                             CALL 6C8[send_integer]
 507  01552                             LOAD s5, 52["R"]
 508  2078B                             CALL 78B[UART_TX]
 509  0BB00                             FETCH sB[CURSOR_LOW], 00[scratchLOW]
 50A  0BA01                             FETCH sA[CURSOR_HIGH], 01[scratchHIGH]
 50B  0B43D                             FETCH s4, 3D[scratchX]
 50C  0B53E                             FETCH s5, 3E[scratchY]
 50D                         DSR_other: ; the host has requested a DSR but it's not a position report request, so we ignore it right now
 50D  22530                             JUMP 530[exit_escape]
 50E                       csi_margins: ; VT100 command set margins. we accept this command but we ignore it. it is used by the linux "resize" command.
 50E  1D572                             COMPARE s5, 72["r"]
 50F  36511                             JUMP NZ, 511[csi_tilde]
 510                                    ; NOP
 510  22530                             JUMP 530[exit_escape]
 511                                    ;
 511                                    ; CSI tilde is non-standard. when we're in local echo mode it's nice to have the home/end/pgup/pgdn/insert/delete keys do something useful.
 511                                    ;
 511                         csi_tilde: ; these are the function keys,etc. we try do to the right thing when we're in loopback mode
 511  1D57E                             COMPARE s5, 7E["~"]
 512  3652E                             JUMP NZ, 52E[unknown_command]
 513  0B008                             FETCH s0, 08[param_block]
 514                        check_home: 
 514  1D001                             COMPARE s0, 01
 515  36518                             JUMP NZ, 518[check_insert]
 516  205BA                             CALL 5BA[home_cursor]
 517  22530                             JUMP 530[exit_escape]
 518                      check_insert: 
 518  1D002                             COMPARE s0, 02
 519  3651D                             JUMP NZ, 51D[check_delete]
 51A  01101                             LOAD s1, 01
 51B  2033C                             CALL 33C[insert_loop]
 51C  22530                             JUMP 530[exit_escape]
 51D                      check_delete: 
 51D  1D003                             COMPARE s0, 03
 51E  36522                             JUMP NZ, 522[check_end]
 51F  01101                             LOAD s1, 01
 520  2035F                             CALL 35F[delete_loop]
 521  22530                             JUMP 530[exit_escape]
 522                         check_end: 
 522  1D004                             COMPARE s0, 04
 523  36526                             JUMP NZ, 526[check_pgup]
 524  205C9                             CALL 5C9[end_of_line]
 525  22530                             JUMP 530[exit_escape]
 526                        check_pgup: 
 526  1D005                             COMPARE s0, 05
 527  3652A                             JUMP NZ, 52A[check_pgdn]
 528  205C1                             CALL 5C1[set_origin]
 529  22530                             JUMP 530[exit_escape]
 52A                        check_pgdn: 
 52A  1D006                             COMPARE s0, 06
 52B  3652E                             JUMP NZ, 52E[unknown_command]
 52C  205C5                             CALL 5C5[end_cursor]
 52D  22530                             JUMP 530[exit_escape]
 52E                   unknown_command: 
 52E  00450                             LOAD s4, s5                                    ; we used to print U but now we send the actual code
 52F  20674                             CALL 674[debug_s4]                             ; comment this line out for debugging **************************************
 530                       exit_escape: 
 530  03CFD                             AND sC[ANSI_FLAG_REG], FD[ANSI_ESCAPE_CLR]
 531  03CFE                             AND sC[ANSI_FLAG_REG], FE[ANSI_CSI_CLR]
 532  25000                             RETURN 
 533                         end_param: ; OK, we've already stored the decimal digits. now it's time to convert them to hex
 533  01E00                             LOAD sE, 00                                    ; empty parameters default to zero
 534  0B111                             FETCH s1, 11[digit_counter]
 535  1D100                             COMPARE s1, 00
 536  32544                             JUMP Z, 544[end_digits]                        ; no digits? just clean up with the zero value
 537  01012                             LOAD s0, 12[digit_block]
 538                          do_digit: ; convert decimal digits to hex value stored in sE
 538  0A400                             FETCH s4, (s0)                                 ; get the actual digit
 539  19430                             SUB s4, 30                                     ; convert ASCII character to integer
 53A  10E40                             ADD sE, s4                                     ; add the digit to the total
 53B  19101                             SUB s1, 01
 53C  1D100                             COMPARE s1, 00                                 ; is this the last digit?
 53D  32544                             JUMP Z, 544[end_digits]
 53E  11001                             ADD s0, 01                                     ; go to the next digit
 53F  008E0                             LOAD s8[DIVISOR_LOW], sE                       ; multiplicand
 540  0190A                             LOAD s9[DIVISOR_HIGH], 0A                      ; multiplier times 10
 541  206BD                             CALL 6BD[mult_8x8]                             ; multiply the whole thing by 10, place result back in s4, ignore overflow?
 542  00E40                             LOAD sE, s4
 543  22538                             JUMP 538[do_digit]
 544                        end_digits: ; we've done all the digits.
 544  004E0                             LOAD s4, sE
 545                                    ; store the parameter here and increment the parameter counter
 545  01008                             LOAD s0, 08[param_block]
 546  0B107                             FETCH s1, 07[param_counter]
 547  10010                             ADD s0, s1
 548  2EE00                             STORE sE, (s0)
 549  01000                             LOAD s0, 00
 54A  2F011                             STORE s0, 11[digit_counter]                    ; reset the digit counter to zero
 54B  11101                             ADD s1, 01                                     ; increment the parameter count
 54C                                    ; COMPARE s1,max_param  ; prevent overflow of parameter space
 54C                                    ; RETURN NC
 54C  2F107                             STORE s1, 07[param_counter]
 54D  25000                             RETURN 
 54E                     invert_colors: ; swap the foreground and background colors
 54E  2F43E                             STORE s4, 3E[scratchY]
 54F  00460                             LOAD s4, s6[COLOR_REG]
 550  1460E                             SR0 s6[COLOR_REG]
 551  1460E                             SR0 s6[COLOR_REG]
 552  1460E                             SR0 s6[COLOR_REG]
 553  1460E                             SR0 s6[COLOR_REG]
 554  14406                             SL0 s4
 555  14406                             SL0 s4
 556  14406                             SL0 s4
 557  14406                             SL0 s4
 558  04640                             OR s6[COLOR_REG], s4
 559  0B43E                             FETCH s4, 3E[scratchY]
 55A  25000                             RETURN 
 55B                                    ;
 55B                                    ; process various control codes
 55B                                    ;
 55B                                    ;
 55B                           enquiry: ; we respond to an ENQ with an ACK, but not locally
 55B  01506                             LOAD s5, 06[ACK_CHAR]
 55C  2078B                             CALL 78B[UART_TX]
 55D  25000                             RETURN 
 55E                         backspace: 
 55E  22577                             JUMP 577[left_cursor]
 55F                            rubout: ; rubout is a destructive non-wrapping backspace.
 55F  20577                             CALL 577[left_cursor]
 560  01520                             LOAD s5, 20
 561  20270                             CALL 270[send_next]                            ; this is recursive
 562  22577                             JUMP 577[left_cursor]
 563                                    ; the following code (not used) does a destructive backspace that wraps to the previous line.
 563                                    ;   SUB CURSOR_LOW, 01
 563                                    ;   SUBCY   CURSOR_HIGH, 00   ; 16 bit decrement (we do no range checking here. addresses will wrap from 0 to 8191)
 563                                    ;   CALL set_cursor
 563                                    ;   LOAD s4, 00
 563                                    ;   OUTPUT s4, CHAR_PORT
 563                                    ;   OUTPUT COLOR_REG, ATTR_PORT
 563                                    ;   RETURN
 563                                    ; tabs stops are every eight characters (0,8,16,24,32,40,48,56,64,72,80,88,96,104,112 (120)
 563                                    ; note that this wraps to the next line and it probably should not.. maybe? It depends on the mode. ****************************
 563  000B0                       htab: LOAD s0, sB[CURSOR_LOW]
 564  03007                             AND s0, 07
 565  01108                             LOAD s1, 08
 566  18100                             SUB s1, s0
 567  10B10                             ADD sB[CURSOR_LOW], s1
 568  13A00                             ADDCY sA[CURSOR_HIGH], 00
 569  2203E                             JUMP 03E[set_cursor]
 56A                           backtab: ; move to the previous tab stop (0,8...)
 56A  20698                             CALL 698[get_row_column]                       ; sE now contains the column
 56B  1DE00                             COMPARE sE, 00
 56C  31000                             RETURN Z                                       ; we're already at the left edge, so we do nothing
 56D  000E0                             LOAD s0, sE
 56E  03007                             AND s0, 07                                     ; round it to the nearest 8
 56F  1D000                             COMPARE s0, 00
 570  32574                             JUMP Z, 574[full_back]                         ; move back an entire 8 characters
 571  18B00                             SUB sB[CURSOR_LOW], s0
 572  1BA00                             SUBCY sA[CURSOR_HIGH], 00
 573  2203E                             JUMP 03E[set_cursor]
 574                         full_back: 
 574  19B08                             SUB sB[CURSOR_LOW], 08
 575  1BA00                             SUBCY sA[CURSOR_HIGH], 00
 576  2203E                             JUMP 03E[set_cursor]
 577                                    ; we used to have a destructive tab. this is the code for it:
 577                                    ; tab_space: LOAD s5," "
 577                                    ;   CALL send_next ; wrapping and scrolling is handled by send_next
 577                                    ;   SUB s1, 01
 577                                    ;   ;COMPARE s1, 00
 577                                    ;   JUMP NZ, tab_space
 577                                    ;   RETURN
 577                       left_cursor: 
 577  20698                             CALL 698[get_row_column]
 578  1DE00                             COMPARE sE, 00
 579  31000                             RETURN Z                                       ; do nothing if we're on the left edge
 57A  19B01                             SUB sB[CURSOR_LOW], 01
 57B  1BA00                             SUBCY sA[CURSOR_HIGH], 00
 57C  2003E                             CALL 03E[set_cursor]
 57D  25000                             RETURN 
 57E                      right_cursor: 
 57E  20698                             CALL 698[get_row_column]
 57F  11E01                             ADD sE, 01
 580  1CED0                             COMPARE sE, sD[CHAR_PER_LINE]
 581  31000                             RETURN Z                                       ; do nothing if we're on the right edge
 582  2003C                             CALL 03C[advance_cursor]
 583  25000                             RETURN 
 584                           line_up: 
 584  1CBD0                             COMPARE sB[CURSOR_LOW], sD[CHAR_PER_LINE]
 585  1FA00                             COMPARECY sA[CURSOR_HIGH], 00
 586  39000                             RETURN C                                       ; do nothing if we're on the top line
 587  18BD0                             SUB sB[CURSOR_LOW], sD[CHAR_PER_LINE]          ; move the cursor up one line, stopping at the top.
 588  1BA00                             SUBCY sA[CURSOR_HIGH], 00
 589  2003E                             CALL 03E[set_cursor]
 58A  25000                             RETURN 
 58B                         line_down: 
 58B  1DBF0                             COMPARE sB[CURSOR_LOW], F0[LAST_LINE_LOWER]    ; we don't move down if we're on the last line
 58C  1FA1E                             COMPARECY sA[CURSOR_HIGH], 1E[LAST_LINE_UPPER]
 58D  3D000                             RETURN NC
 58E  10BD0                             ADD sB[CURSOR_LOW], sD[CHAR_PER_LINE]
 58F  13A00                             ADDCY sA[CURSOR_HIGH], 00                      ; move the cursor down one line
 590  2003E                             CALL 03E[set_cursor]
 591  25000                             RETURN 
 592                         line_feed: 
 592  1DBF0                             COMPARE sB[CURSOR_LOW], F0[LAST_LINE_LOWER]    ; we scroll down if we're on the last line
 593  1FA1E                             COMPARECY sA[CURSOR_HIGH], 1E[LAST_LINE_UPPER]
 594  3E5DC                             JUMP NC, 5DC[scroll_up]
 595  10BD0                             ADD sB[CURSOR_LOW], sD[CHAR_PER_LINE]
 596  13A00                             ADDCY sA[CURSOR_HIGH], 00                      ; move the cursor down one line
 597  2003E                             CALL 03E[set_cursor]
 598  25000                             RETURN 
 599                clear_start_screen: ; clear from cursor position to the start of the screen.
 599  2FB00                             STORE sB[CURSOR_LOW], 00[scratchLOW]
 59A  2FA01                             STORE sA[CURSOR_HIGH], 01[scratchHIGH]
 59B  01420                             LOAD s4, 20
 59C                    clear_backward: 
 59C  2D404                             OUTPUT s4, 04[CHAR_PORT]
 59D  2D609                             OUTPUT s6[COLOR_REG], 09[ATTR_PORT]
 59E  20039                             CALL 039[decrement_cursor]
 59F  1DB00                             COMPARE sB[CURSOR_LOW], 00
 5A0  1FA00                             COMPARECY sA[CURSOR_HIGH], 00
 5A1  2003E                             CALL 03E[set_cursor]
 5A2  3659C                             JUMP NZ, 59C[clear_backward]
 5A3  2D404                             OUTPUT s4, 04[CHAR_PORT]                       ; do the last bit
 5A4  2D609                             OUTPUT s6[COLOR_REG], 09[ATTR_PORT]
 5A5  0BB00                             FETCH sB[CURSOR_LOW], 00[scratchLOW]
 5A6  0BA01                             FETCH sA[CURSOR_HIGH], 01[scratchHIGH]
 5A7  2003E                             CALL 03E[set_cursor]
 5A8  25000                             RETURN 
 5A9                         form_feed: 
 5A9  01B00                             LOAD sB[CURSOR_LOW], 00
 5AA  01A00                             LOAD sA[CURSOR_HIGH], 00
 5AB                  clear_end_screen: ; clear to end of screen inclusive
 5AB  2FB00                             STORE sB[CURSOR_LOW], 00[scratchLOW]
 5AC  2FA01                             STORE sA[CURSOR_HIGH], 01[scratchHIGH]
 5AD  01420                             LOAD s4, 20                                    ; fill the screen with spaces
 5AE                      clear_a_char: 
 5AE  2003E                             CALL 03E[set_cursor]                           ;;;; candidate for advance_cursor will a slight rework
 5AF  2D404                             OUTPUT s4, 04[CHAR_PORT]
 5B0  2D609                             OUTPUT s6[COLOR_REG], 09[ATTR_PORT]
 5B1  11B01                             ADD sB[CURSOR_LOW], 01                         ; increment
 5B2  13A00                             ADDCY sA[CURSOR_HIGH], 00
 5B3  1DB68                             COMPARE sB[CURSOR_LOW], 68[MAX_LINE_LOWER]
 5B4  1FA1F                             COMPARECY sA[CURSOR_HIGH], 1F[MAX_LINE_UPPER]
 5B5  365AE                             JUMP NZ, 5AE[clear_a_char]
 5B6  0BB00                             FETCH sB[CURSOR_LOW], 00[scratchLOW]           ; restore our cursor position
 5B7  0BA01                             FETCH sA[CURSOR_HIGH], 01[scratchHIGH]
 5B8  2003E                             CALL 03E[set_cursor]                           ;
 5B9  25000                             RETURN 
 5BA                       home_cursor: ; cursor to start of line
 5BA  20698                             CALL 698[get_row_column]
 5BB  1DE00                             COMPARE sE, 00                                 ; are we on the left edge?
 5BC  31000                             RETURN Z
 5BD  18BE0                             SUB sB[CURSOR_LOW], sE                         ; no, subtract the remainder to put us at the left edge
 5BE  1BA00                             SUBCY sA[CURSOR_HIGH], 00
 5BF  2003E                             CALL 03E[set_cursor]
 5C0  25000                             RETURN 
 5C1                        set_origin: ; put cursor in upper left corner
 5C1  01B00                             LOAD sB[CURSOR_LOW], 00
 5C2  01A00                             LOAD sA[CURSOR_HIGH], 00
 5C3  2003E                             CALL 03E[set_cursor]
 5C4  25000                             RETURN 
 5C5                        end_cursor: ; cursor to first character of last line
 5C5  01BF0                             LOAD sB[CURSOR_LOW], F0[LAST_LINE_LOWER]
 5C6  01A1E                             LOAD sA[CURSOR_HIGH], 1E[LAST_LINE_UPPER]
 5C7  2003E                             CALL 03E[set_cursor]
 5C8  25000                             RETURN 
 5C9                       end_of_line: ; cursor to end of line
 5C9  205BA                             CALL 5BA[home_cursor]
 5CA  20039                             CALL 039[decrement_cursor]
 5CB  10BD0                             ADD sB[CURSOR_LOW], sD[CHAR_PER_LINE]
 5CC  13A00                             ADDCY sA[CURSOR_HIGH], 00
 5CD  2003E                             CALL 03E[set_cursor]
 5CE  25000                             RETURN 
 5CF                              CRLF: 
 5CF  205D1                             CALL 5D1[carriage_return]
 5D0  225D3                             JUMP 5D3[cr_leftedge]
 5D1                   carriage_return: 
 5D1  205BA                             CALL 5BA[home_cursor]
 5D2  25000                             RETURN                                         ; uncomment this for no automatic CR/LF pair
 5D3  10BD0                cr_leftedge: ADD sB[CURSOR_LOW], sD[CHAR_PER_LINE]          ; add 80 characters
 5D4  13A00                             ADDCY sA[CURSOR_HIGH], 00
 5D5  1DB68                             COMPARE sB[CURSOR_LOW], 68[MAX_LINE_LOWER]     ; are we past the end? FA0 = 4000 decimal
 5D6  1FA1F                             COMPARECY sA[CURSOR_HIGH], 1F[MAX_LINE_UPPER]
 5D7  325DA                             JUMP Z, 5DA[cr_scroll_up]
 5D8  2003E               cr_regadjust: CALL 03E[set_cursor]
 5D9  25000                             RETURN 
 5DA                      cr_scroll_up: 
 5DA  01BF0                             LOAD sB[CURSOR_LOW], F0[LAST_LINE_LOWER]
 5DB  01A1E                             LOAD sA[CURSOR_HIGH], 1E[LAST_LINE_UPPER]
 5DC                         scroll_up: ; we know we're on the last line
 5DC                                    ; scrolling is done in hardware with an address offset register.
 5DC  2FB00                             STORE sB[CURSOR_LOW], 00[scratchLOW]
 5DD  2FA01                             STORE sA[CURSOR_HIGH], 01[scratchHIGH]
 5DE  0BE1E              scroll_offset: FETCH sE, 1E[offset_low]
 5DF  0BF1F                             FETCH sF, 1F[offset_high]
 5E0  10ED0                             ADD sE, sD[CHAR_PER_LINE]
 5E1  13F00                             ADDCY sF, 00
 5E2  2FE1E                             STORE sE, 1E[offset_low]
 5E3  2FF1F                             STORE sF, 1F[offset_high]
 5E4  2DE0F                             OUTPUT sE, 0F[OFFSET_LSB_PORT]
 5E5  2DF0E                             OUTPUT sF, 0E[OFFSET_MSB_PORT]
 5E6                   clear_last_line: 
 5E6  01BF0                             LOAD sB[CURSOR_LOW], F0[LAST_LINE_LOWER]
 5E7  01A1E                             LOAD sA[CURSOR_HIGH], 1E[LAST_LINE_UPPER]
 5E8  01500                             LOAD s5, 00
 5E9  2003E                 clear_loop: CALL 03E[set_cursor]                           ;;;; candidate for advance_cursor
 5EA  2D504                             OUTPUT s5, 04[CHAR_PORT]
 5EB  2D609                             OUTPUT s6[COLOR_REG], 09[ATTR_PORT]
 5EC  11B01                             ADD sB[CURSOR_LOW], 01
 5ED  13A00                             ADDCY sA[CURSOR_HIGH], 00
 5EE  1DB68                             COMPARE sB[CURSOR_LOW], 68[MAX_LINE_LOWER]
 5EF  1FA1F                             COMPARECY sA[CURSOR_HIGH], 1F[MAX_LINE_UPPER]
 5F0  365E9                             JUMP NZ, 5E9[clear_loop]
 5F1                    done_scrolling: 
 5F1  0BB00                             FETCH sB[CURSOR_LOW], 00[scratchLOW]
 5F2  0BA01                             FETCH sA[CURSOR_HIGH], 01[scratchHIGH]
 5F3  2003E                             CALL 03E[set_cursor]
 5F4  25000                             RETURN 
 5F5                clear_current_line: 
 5F5  01500                             LOAD s5, 00
 5F6  000D0                             LOAD s0, sD[CHAR_PER_LINE]
 5F7                   clear_line_loop: 
 5F7  2003E                             CALL 03E[set_cursor]                           ;;;; candidate for advance_cursor
 5F8  2D504                             OUTPUT s5, 04[CHAR_PORT]
 5F9  2D609                             OUTPUT s6[COLOR_REG], 09[ATTR_PORT]
 5FA  11B01                             ADD sB[CURSOR_LOW], 01
 5FB  13A00                             ADDCY sA[CURSOR_HIGH], 00
 5FC  19001                             SUB s0, 01
 5FD  1D000                             COMPARE s0, 00
 5FE  365F7                             JUMP NZ, 5F7[clear_line_loop]
 5FF  0BB00                             FETCH sB[CURSOR_LOW], 00[scratchLOW]
 600  0BA01                             FETCH sA[CURSOR_HIGH], 01[scratchHIGH]
 601  2003E                             CALL 03E[set_cursor]
 602  25000                             RETURN 
 603                         ring_bell: 
 603  2FB00                             STORE sB[CURSOR_LOW], 00[scratchLOW]
 604  2FA01                             STORE sA[CURSOR_HIGH], 01[scratchHIGH]
 605  2F63D                             STORE s6[COLOR_REG], 3D[scratchX]
 606  2060E                             CALL 60E[invert_screen]
 607  206B0                             CALL 6B0[delay_100ms]                          ; this might be too long ********************
 608  2060E                             CALL 60E[invert_screen]
 609  0BB00                             FETCH sB[CURSOR_LOW], 00[scratchLOW]
 60A  0BA01                             FETCH sA[CURSOR_HIGH], 01[scratchHIGH]
 60B  0B63D                             FETCH s6[COLOR_REG], 3D[scratchX]
 60C  2003E                             CALL 03E[set_cursor]
 60D  25000                             RETURN 
 60E                     invert_screen: 
 60E  01B00                             LOAD sB[CURSOR_LOW], 00
 60F  01A00                             LOAD sA[CURSOR_HIGH], 00
 610                         bell_loop: 
 610  2003E                             CALL 03E[set_cursor]                           ;;;; candidate for advance_cursor
 611  0960A                             INPUT s6[COLOR_REG], 0A[ATTR_READ_PORT]
 612  2054E                             CALL 54E[invert_colors]
 613  2D609                             OUTPUT s6[COLOR_REG], 09[ATTR_PORT]
 614  11B01                             ADD sB[CURSOR_LOW], 01
 615  13A00                             ADDCY sA[CURSOR_HIGH], 00
 616  1DB68                             COMPARE sB[CURSOR_LOW], 68[MAX_LINE_LOWER]
 617  1FA1F                             COMPARECY sA[CURSOR_HIGH], 1F[MAX_LINE_UPPER]
 618  36610                             JUMP NZ, 610[bell_loop]
 619  25000                             RETURN 
 61A                                    ;
 61A                                    ; setting the PS/2 keyboard LEDs does not work reliably so it's commented out until I can
 61A                                    ; sort out the problem.
 61A                                    ;
 61A                       caps_led_on: 
 61A  0B030                             FETCH s0, 30[mode_flags]
 61B  05008                             OR s0, 08[MODE_CAPS_LOCK]
 61C  2F030                             STORE s0, 30[mode_flags]
 61D  2D00B                             OUTPUT s0, 0B[MODE_PORT]
 61E  25000                             RETURN 
 61F                      caps_led_off: 
 61F  0B030                             FETCH s0, 30[mode_flags]
 620  030F7                             AND s0, F7[MODE_CAPS_LOCK_CLR]
 621  2F030                             STORE s0, 30[mode_flags]
 622  2D00B                             OUTPUT s0, 0B[MODE_PORT]
 623  25000                             RETURN 
 624                        num_led_on: 
 624  0B030                             FETCH s0, 30[mode_flags]
 625  05010                             OR s0, 10[MODE_NUM_LOCK]
 626  2F030                             STORE s0, 30[mode_flags]
 627  2D00B                             OUTPUT s0, 0B[MODE_PORT]
 628  25000                             RETURN 
 629                       num_led_off: 
 629  0B030                             FETCH s0, 30[mode_flags]
 62A  030EF                             AND s0, EF[MODE_NUM_LOCK_CLR]
 62B  2F030                             STORE s0, 30[mode_flags]
 62C  2D00B                             OUTPUT s0, 0B[MODE_PORT]
 62D  25000                             RETURN 
 62E                     scroll_led_on: 
 62E  0B030                             FETCH s0, 30[mode_flags]
 62F  05020                             OR s0, 20[MODE_SCROLL_LOCK]
 630  2F030                             STORE s0, 30[mode_flags]
 631  2D00B                             OUTPUT s0, 0B[MODE_PORT]
 632  25000                             RETURN 
 633                    scroll_led_off: 
 633  0B030                             FETCH s0, 30[mode_flags]
 634  030DF                             AND s0, DF[MODE_SCROLL_LOCK_CLR]
 635  2F030                             STORE s0, 30[mode_flags]
 636  2D00B                             OUTPUT s0, 0B[MODE_PORT]
 637  25000                             RETURN 
 638                                    ;;;;
 638                                    ; caps_led_off:
 638                                    ;   LOAD s0, ED
 638                                    ;   OUTPUT s0, PS2_WRITE_PORT
 638                                    ;   CALL delay_4ms
 638                                    ;   LOAD s0,00   ; this turns off all three LEDs
 638                                    ;   OUTPUT s0, PS2_WRITE_PORT
 638                                    ;   CALL delay_4ms
 638                                    ; off_again:     ; we have to do it twice or it doesn't work.
 638                                    ;   LOAD s0, ED
 638                                    ;   OUTPUT s0, PS2_WRITE_PORT
 638                                    ;   CALL delay_4ms
 638                                    ;   LOAD s0,00
 638                                    ;   OUTPUT s0, PS2_WRITE_PORT
 638                                    ;   RETURN
 638                                    ; caps_led_on:
 638                                    ;   LOAD s0, ED
 638                                    ;   OUTPUT s0,PS2_WRITE_PORT
 638                                    ;   CALL delay_4ms
 638                                    ;   LOAD s0, 04   ; this turns on the CAPS lock LED only (2=NUM, 1= SCROLL)
 638                                    ;   OUTPUT s0,PS2_WRITE_PORT
 638                                    ;   CALL delay_4ms
 638                                    ; on_again:     ; we have to do it twice or it doesn't work.
 638                                    ;   LOAD s0, ED
 638                                    ;   OUTPUT s0,PS2_WRITE_PORT
 638                                    ;   CALL delay_4ms
 638                                    ;   LOAD s0, 04   ; 4 is CAPS lock, 2 is NUMLOCK, 1 is SCROLL lock
 638                                    ;   OUTPUT s0,PS2_WRITE_PORT
 638                                    ;   RETURN
 638                                    ;   CALL delay_4ms
 638                                    ;   INPUT s0, PS2_WRITE_STATUS_PORT
 638                                    ; poll_ps2:
 638                                    ;   LOAD s0,s0 ; do we need a NOP here? maybe
 638                                    ;   COMPARE s0, 01
 638                                    ;   JUMP NZ, poll_ps2
 638                      test_pattern: ; dumps all 256 characters to the console in RAW mode.
 638  01500                             LOAD s5, 00
 639                         ascii_set: 
 639  2F501                             STORE s5, 01
 63A  20296                             CALL 296[raw_char_out]
 63B  0B501                             FETCH s5, 01
 63C  11501                             ADD s5, 01
 63D  1D500                             COMPARE s5, 00
 63E  31000                             RETURN Z
 63F  22639                             JUMP 639[ascii_set]
 640                        send_tilde: 
 640  0157E                             LOAD s5, 7E["~"]
 641  2226B                             JUMP 26B[print_the_char]
 642                          send_csi: ; send the ESCAPE-[ sequence to the appropriate place
 642  0151B                             LOAD s5, 1B[ESC]
 643  2026B                             CALL 26B[print_the_char]
 644  0155B                             LOAD s5, 5B["["]
 645  2226B                             JUMP 26B[print_the_char]
 646                                    ; print_string:
 646                                    ; sends NULL terminated STRING to the HDMI character display
 646                                    ; string pointer is passed in s8s9
 646                                    ; returns with s8s9 pointing to NUL terminator at end of string
 646                                    ; does not affect other registers
 646  24890               print_string: CALL@ (s8[DIVISOR_LOW], s9[DIVISOR_HIGH])
 647  1D500                             COMPARE s5, 00                                 ;terminate on NUL character
 648  31000                             RETURN Z
 649  2F800                             STORE s8[DIVISOR_LOW], 00[scratchLOW]
 64A  2F901                             STORE s9[DIVISOR_HIGH], 01[scratchHIGH]
 64B  20270                             CALL 270[send_next]
 64C  0B800                             FETCH s8[DIVISOR_LOW], 00[scratchLOW]
 64D  0B901                             FETCH s9[DIVISOR_HIGH], 01[scratchHIGH]
 64E  11901                             ADD s9[DIVISOR_HIGH], 01[1'd]
 64F  13800                             ADDCY s8[DIVISOR_LOW], 00[0'd]
 650  22646                             JUMP 646[print_string]
 651                                    ; hex_byte
 651                                    ; echo the 8 bit value of s4 to the serial port in hexadecimal
 651                                    ; followed by a space (three characters total are sent)
 651                                    ; the s5 register is corrupted by this function
 651                          hex_byte: 
 651  00540                             LOAD s5, s4                                    ;isolate upper nibble
 652  1450E                             SR0 s5
 653  1450E                             SR0 s5
 654  1450E                             SR0 s5
 655  1450E                             SR0 s5
 656  2066F                             CALL 66F[hex_to_text]                          ; convert to ASCII
 657  2078B                             CALL 78B[UART_TX]                              ;send upper digit to UART
 658  00540                             LOAD s5, s4                                    ;isolate lower nibble
 659  0350F                             AND s5, 0F
 65A  2066F                             CALL 66F[hex_to_text]                          ; convert to ASCII
 65B  2078B                             CALL 78B[UART_TX]                              ;send lower digit to UART
 65C  25000                             RETURN 
 65D                                    ;
 65D                                    ; debug hex dumps a hex value in s4 to the character display
 65D                                    ;
 65D                         debug_hex: 
 65D  0157B                             LOAD s5, 7B["{"]
 65E  20296                             CALL 296[raw_char_out]
 65F  20663                             CALL 663[print_hex]
 660  0157D                             LOAD s5, 7D["}"]
 661  20296                             CALL 296[raw_char_out]
 662  25000                             RETURN 
 663                         print_hex: 
 663  00540                             LOAD s5, s4                                    ;isolate upper nibble
 664  1450E                             SR0 s5
 665  1450E                             SR0 s5
 666  1450E                             SR0 s5
 667  1450E                             SR0 s5
 668  2066F                             CALL 66F[hex_to_text]                          ; convert to ASCII
 669  20296                             CALL 296[raw_char_out]
 66A  00540                             LOAD s5, s4                                    ;isolate lower nibble
 66B  0350F                             AND s5, 0F
 66C  2066F                             CALL 66F[hex_to_text]                          ; convert to ASCII
 66D  20296                             CALL 296[raw_char_out]
 66E  25000                             RETURN 
 66F                                    ; Convert value 00 to 0F provided in 's5' into ASCII character in 's5'
 66F                                    ; Register used s5
 66F  1950A                hex_to_text: SUB s5, 0A                                     ;test if value is in range 0 to 9
 670  3A672                             JUMP C, 672[number_to_char]
 671  11507                             ADD s5, 07                                     ;ASCII char A to F in range 41 to 46
 672  1153A             number_to_char: ADD s5, 3A                                     ;ASCII char 0 to 9 in range 30 to 40
 673  25000                             RETURN 
 674                                    STRING hello$, "QuackTerm V1.0   "
 674  2F500                   debug_s4: STORE s5, 00
 675  0153C                             LOAD s5, 3C["<"]
 676  20296                             CALL 296[raw_char_out]
 677  2F400                             STORE s4, 00[scratchLOW]
 678  0B408                             FETCH s4, 08[param_block]
 679  2065D                             CALL 65D[debug_hex]
 67A  0B400                             FETCH s4, 00[scratchLOW]
 67B  00540                             LOAD s5, s4
 67C  20296                             CALL 296[raw_char_out]
 67D  0153E                             LOAD s5, 3E[">"]
 67E  20296                             CALL 296[raw_char_out]
 67F  01500                             LOAD s5, 00
 680  25000                             RETURN 
 681  21551                  hello_msg: LOAD&RETURN s5, 51[hello$:"Q"]
 682  21575                             LOAD&RETURN s5, 75[hello$:"u"]
 683  21561                             LOAD&RETURN s5, 61[hello$:"a"]
 684  21563                             LOAD&RETURN s5, 63[hello$:"c"]
 685  2156B                             LOAD&RETURN s5, 6B[hello$:"k"]
 686  21554                             LOAD&RETURN s5, 54[hello$:"T"]
 687  21565                             LOAD&RETURN s5, 65[hello$:"e"]
 688  21572                             LOAD&RETURN s5, 72[hello$:"r"]
 689  2156D                             LOAD&RETURN s5, 6D[hello$:"m"]
 68A  21520                             LOAD&RETURN s5, 20[hello$:" "]
 68B  21556                             LOAD&RETURN s5, 56[hello$:"V"]
 68C  21531                             LOAD&RETURN s5, 31[hello$:"1"]
 68D  2152E                             LOAD&RETURN s5, 2E[hello$:"."]
 68E  21530                             LOAD&RETURN s5, 30[hello$:"0"]
 68F  21520                             LOAD&RETURN s5, 20[hello$:" "]
 690  21520                             LOAD&RETURN s5, 20[hello$:" "]
 691  21520                             LOAD&RETURN s5, 20[hello$:" "]
 692                                    ;LOAD&RETURN s5, CR
 692  21500                             LOAD&RETURN s5, 00[NUL]
 693               get_row_column_plus: 
 693  002B0                             LOAD s2[DIVIDEND_LOW], sB[CURSOR_LOW]
 694  003A0                             LOAD s3[DIVIDEND_HIGH], sA[CURSOR_HIGH]
 695  11201                             ADD s2[DIVIDEND_LOW], 01
 696  13300                             ADDCY s3[DIVIDEND_HIGH], 00
 697  2269A                             JUMP 69A[finish_row_column]
 698                    get_row_column: ;returns the ROW in DIVIDEND_LOW and the COLUMN in sE
 698  002B0                             LOAD s2[DIVIDEND_LOW], sB[CURSOR_LOW]
 699  003A0                             LOAD s3[DIVIDEND_HIGH], sA[CURSOR_HIGH]
 69A                 finish_row_column: 
 69A  009D0                             LOAD s9[DIVISOR_HIGH], sD[CHAR_PER_LINE]
 69B  01800                             LOAD s8[DIVISOR_LOW], 00
 69C  2269D                             JUMP 69D[divide_16bit_by_any]                  ; sE is now the line (column) position
 69D                                    ; parasitic RETURN
 69D                                    ; Divide 16-bit binary integer
 69D                                    ;
 69D                                    ; The value to be divided by should be provided in register set [DIVIDEND_HIGH,DIVIDEND_LOW].
 69D                                    ; The divisor should be placed in DIVISOR_LOW,DIVISOR_HIGH
 69D                                    ; The routine will return the integer result [DIVIDEND_HIGH,s2]/80 back in[DIVIDEND_HIGH,DIVIDEND_LOW]
 69D                                    ; with any remainder in register sE.
 69D                                    ; Registers used s0,DIVIDEND_LOW,DIVIDEND_HIGH,DIVISOR_LOW,DIVISOR_HIGH,sE,sF
 69D                                    ;
 69D                                    ; NOTE: this is NOT a general purpose divide function. It works for the values we are interested in (divisors of 80 and 120).
 69D                                    ;
 69D  00E20        divide_16bit_by_any: LOAD sE, s2[DIVIDEND_LOW]                      ;copy input value into [CURSOR_LOW,sA]
 69E  00F30                             LOAD sF, s3[DIVIDEND_HIGH]
 69F  01200                             LOAD s2[DIVIDEND_LOW], 00                      ;clear division result
 6A0  01300                             LOAD s3[DIVIDEND_HIGH], 00
 6A1                                    ;LOAD DIVISOR_HIGH, 78   ; OK, so we actually always divide by 120 right now. could also divide by 80 (0x50)
 6A1                                    ; LOAD DIVISOR_LOW, 00
 6A1  01009                             LOAD s0, 09[9'd]                               ;9 subtract and shift iterations to be performed (0x50 uses 7 bits for a total of 16)
 6A2                                    ; a general purpose subtract function would perform all 16 shifts and would have the
 6A2                                    ; 8-bit divisor loaded straight into s8 with s9 being 00 (the MSB)
 6A2  18E80                   div_loop: SUB sE, s8[DIVISOR_LOW]                        ;perform 16-bit subtract [CURSOR_LOW,sA]-[DIVISOR_HIGH,DIVISOR_LOW]
 6A3  1AF90                             SUBCY sF, s9[DIVISOR_HIGH]
 6A4  3A6A7                             JUMP C, 6A7[div_restore]                       ;if carry then could not subtract from total
 6A5  14207                             SL1 s2[DIVIDEND_LOW]                           ;shift '1' into result because subtract ok
 6A6  226AA                             JUMP 6AA[div_shifts]
 6A7  10E80                div_restore: ADD sE, s8[DIVISOR_LOW]                        ;perform 16-bit addition [CURSOR_LOW,sA]+[DIVISOR_HIGH,DIVISOR_LOW]
 6A8  12F90                             ADDCY sF, s9[DIVISOR_HIGH]                     ;to restore total
 6A9  14206                             SL0 s2[DIVIDEND_LOW]                           ;shift '0' into result because could no subtract
 6AA  14300                 div_shifts: SLA s3[DIVIDEND_HIGH]                          ;complete 16-bit shift left into [DIVIDEND_HIGH,s2]
 6AB  1490E                             SR0 s9[DIVISOR_HIGH]                           ;divide '10' value by 2 (shift right 1 place)
 6AC  14808                             SRA s8[DIVISOR_LOW]
 6AD  19001                             SUB s0, 01                                     ;count iterations
 6AE  31000                             RETURN Z                                       ;on return the remainder of division is in sA
 6AF  226A2                             JUMP 6A2[div_loop]
 6B0                                    ; delay for one second
 6B0                                    ;1s is 50,000,000 clock cycles requiring 6,250,000 delay iterations
 6B0                                    ; (5F5E10)
 6B0                                    ;          delay_1s: LOAD DIVIDEND_LOW, 5F
 6B0                                    ;                    LOAD s1, 5E
 6B0                                    ;                    LOAD s0, 10
 6B0                                    ;                    JUMP software_delay
 6B0                                    ;
 6B0                                    ; The delay loop decrements [DIVIDEND_LOW,s1,s0] until it reaches zero
 6B0                                    ; Each decrement cycle is 4 instructions which is 8 clock cycles (160ns at 50MHz)
 6B0                                    ; 100 milliseconds is 0x98968
 6B0                                    ;
 6B0                                    ;
 6B0                       delay_100ms: 
 6B0  01209                             LOAD s2[DIVIDEND_LOW], 09
 6B1  01189                             LOAD s1, 89
 6B2  01068                             LOAD s0, 68
 6B3  226B8                             JUMP 6B8[software_delay]
 6B4                                    ; 2 ms is 2 milliseconds, requiring
 6B4                                    ; 12,500 delay iterations (0030D4)
 6B4                                    ; 4  ms is 61A8
 6B4                                    ;
 6B4                         delay_4ms: 
 6B4  01200                             LOAD s2[DIVIDEND_LOW], 00
 6B5  01161                             LOAD s1, 61
 6B6  010A8                             LOAD s0, A8
 6B7  226B8                             JUMP 6B8[software_delay]
 6B8                                    ;
 6B8  19001             software_delay: SUB s0, 01[1'd]
 6B9  1B100                             SUBCY s1, 00[0'd]
 6BA  1B200                             SUBCY s2[DIVIDEND_LOW], 00[0'd]
 6BB  366B8                             JUMP NZ, 6B8[software_delay]
 6BC  25000                             RETURN 
 6BD                                    ; Multiplier Routine (8-bit x 8-bit = 16-bit product)
 6BD                                    ; ==================================================
 6BD                                    ; Shift and add algorithm
 6BD                                    ;
 6BD                          mult_8x8: 
 6BD                                    NAMEREG DIVISOR_LOW, multiplicand              ; preserved
 6BD                                    NAMEREG DIVISOR_HIGH, multiplier               ; preserved
 6BD                                    NAMEREG DIVIDEND_LOW, bit_mask                 ; modified
 6BD                                    NAMEREG DIVIDEND_HIGH, result_msb              ; most-significant byte (MSB) of result, modified
 6BD                                    NAMEREG s4, result_lsb                         ; least-significant byte (LSB) of result, modified
 6BD                                    ;
 6BD  01201                             LOAD s2[bit_mask], 01                          ; start with least-significant bit (lsb)
 6BE  01300                             LOAD s3[result_msb], 00                        ; clear product MSB
 6BF  01400                             LOAD s4[result_lsb], 00                        ; clear product LSB (not required)
 6C0                                    ;
 6C0                                    ; loop through all bits in multiplier
 6C0                         mult_loop: 
 6C0  0C920                             TEST s9[multiplier], s2[bit_mask]              ; check if bit is set
 6C1  326C3                             JUMP Z, 6C3[no_add]                            ; if bit is not set, skip addition
 6C2                                    ;
 6C2  10380                             ADD s3[result_msb], s8[multiplicand]           ; addition only occurs in MSB
 6C3                                    ;
 6C3  14308                     no_add: SRA s3[result_msb]                             ; shift MSB right, CARRY into bit 7,
 6C4                                    ; lsb into CARRY
 6C4  14408                             SRA s4[result_lsb]                             ; shift LSB right,
 6C5                                    ; lsb from result_msb into bit 7
 6C5                                    ;
 6C5  14206                             SL0 s2[bit_mask]                               ; shift bit_mask left to examine
 6C6                                    ; next bit in multiplier
 6C6                                    ;
 6C6  366C0                             JUMP NZ, 6C0[mult_loop]                        ; if all bit examined, then bit_mask = 0
 6C7  25000                             RETURN 
 6C8                                    ;
 6C8                                    ; the following code uses normal register names, it's taken from the Xilinx example more or less
 6C8                                    ; so we use NAMEREG to restore our registers to their original names more or less
 6C8                                    NAMEREG multiplicand, DIVISOR_LOW
 6C8                                    NAMEREG multiplier, DIVISOR_HIGH
 6C8                                    NAMEREG bit_mask, s2
 6C8                                    NAMEREG result_msb, s3
 6C8                                    NAMEREG result_lsb, s4
 6C8                                    NAMEREG COLOR_REG, s6
 6C8                                    NAMEREG KEY_FLAG_REG, s7
 6C8                                    NAMEREG CURSOR_LOW, sB
 6C8                                    NAMEREG CURSOR_HIGH, sA
 6C8                                    NAMEREG DIVISOR_LOW, s8
 6C8                                    NAMEREG DIVISOR_HIGH, s9
 6C8                                    ;
 6C8                                    ; sends a 16 bit integer value in s2s3 to the serial port in decimal format.
 6C8                                    ;
 6C8                                    ;;
 6C8  1D200               send_integer: COMPARE s2, 00                                 ;test for special case of zero
 6C9  1F300                             COMPARECY s3, 00
 6CA  326D8                             JUMP Z, 6D8[zero_integer]
 6CB                                    ;
 6CB  206EE                             CALL 6EE[integer16_to_BCD]                     ;Convert to BCD in SPM
 6CC                                    ;
 6CC  01E06                             LOAD sE, 06[decimal4]                          ;pointer to BCD in SPM
 6CD  01F00                             LOAD sF, 00[0'd]                               ;flag for leading zero blanking
 6CE  0A5E0          send_integer_loop: FETCH s5, (sE)
 6CF  10F50                             ADD sF, s5                                     ;make sF non-zero to stop blanking
 6D0  1DF00                             COMPARE sF, 00[0'd]                            ;Test for blanking
 6D1  326D4                             JUMP Z, 6D4[next_int_digit]
 6D2  11530                             ADD s5, 30["0"]                                ;convert to ASCII
 6D3  2078B                             CALL 78B[UART_TX]                              ;send digit
 6D4  1DE02             next_int_digit: COMPARE sE, 02[decimal0]
 6D5  31000                             RETURN Z
 6D6  19E01                             SUB sE, 01[1'd]                                ;move pointer to next digit
 6D7  226CE                             JUMP 6CE[send_integer_loop]
 6D8                                    ;
 6D8  01530               zero_integer: LOAD s5, 30["0"]                               ;special response for zero
 6D9  2078B                             CALL 78B[UART_TX]
 6DA  25000                             RETURN 
 6DB                     print_integer: 
 6DB  1D200                             COMPARE s2, 00                                 ;test for special case of zero
 6DC  1F300                             COMPARECY s3, 00
 6DD  326EB                             JUMP Z, 6EB[zero_printeger]
 6DE  206EE                             CALL 6EE[integer16_to_BCD]                     ;Convert to BCD in SPM
 6DF  01E06                             LOAD sE, 06[decimal4]                          ;pointer to BCD in SPM
 6E0  01F00                             LOAD sF, 00[0'd]                               ;flag for leading zero blanking
 6E1                print_integer_loop: 
 6E1  0A5E0                             FETCH s5, (sE)
 6E2  10F50                             ADD sF, s5                                     ;make sF non-zero to stop blanking
 6E3  1DF00                             COMPARE sF, 00[0'd]                            ;Test for blanking
 6E4  326E7                             JUMP Z, 6E7[next_print_digit]
 6E5  11530                             ADD s5, 30["0"]                                ;convert to ASCII
 6E6  20270                             CALL 270[send_next]
 6E7                  next_print_digit: 
 6E7  1DE02                             COMPARE sE, 02[decimal0]
 6E8  31000                             RETURN Z
 6E9  19E01                             SUB sE, 01[1'd]                                ;move pointer to next digit
 6EA  226E1                             JUMP 6E1[print_integer_loop]
 6EB                    zero_printeger: 
 6EB  01530                             LOAD s5, 30["0"]                               ;special response for zero
 6EC  20270                             CALL 270[send_next]
 6ED  25000                             RETURN 
 6EE  01402           integer16_to_BCD: LOAD s4, 02[decimal0]                          ;pointer for LS-Digit in scratch pad memory
 6EF  206F5            int_to_BCD_loop: CALL 6F5[divide_16bit_by_10]
 6F0  2EE40                             STORE sE, (s4)                                 ;remainder is the digit value
 6F1  1D406                             COMPARE s4, 06[decimal4]                       ;test for MS-Digit completed
 6F2  31000                             RETURN Z
 6F3  11401                             ADD s4, 01[1'd]                                ;advance pointer to next digit
 6F4  226EF                             JUMP 6EF[int_to_BCD_loop]
 6F5                                    ;
 6F5                                    ; Divide 16-bit binary integer by 10
 6F5                                    ;
 6F5                                    ; The value to be divided by 10 should be provided in register set [s3,s2].
 6F5                                    ; The routine will return the integer result [s3,s2]/10 back in[s3,s2]
 6F5                                    ; with any remainder in (0 to 9) in register sA.
 6F5                                    ;
 6F5                                    ; Registers used s0,s2,s3,s8,s9,sA,sB
 6F5                                    ;
 6F5  00E20         divide_16bit_by_10: LOAD sE, s2                                    ;copy input value into [sB,sA]
 6F6  00F30                             LOAD sF, s3
 6F7  01200                             LOAD s2, 00                                    ;clear division result
 6F8  01300                             LOAD s3, 00
 6F9  019A0                             LOAD s9, A0                                    ;initialise [s9,s8] with '10' in MSBs
 6FA  01800                             LOAD s8, 00
 6FB  0100D                             LOAD s0, 0D[13'd]                              ;13 subtract and shift iterations to be performed
 6FC  18E80                 div10_loop: SUB sE, s8                                     ;perform 16-bit subtract [sB,sA]-[s9,s8]
 6FD  1AF90                             SUBCY sF, s9
 6FE  3A701                             JUMP C, 701[div10_restore]                     ;if carry then could not subtract from total
 6FF  14207                             SL1 s2                                         ;shift '1' into result because subtract ok
 700  22704                             JUMP 704[div10_shifts]
 701  10E80              div10_restore: ADD sE, s8                                     ;perform 16-bit addition [sB,sA]+[s9,s8]
 702  12F90                             ADDCY sF, s9                                   ;to restore total
 703  14206                             SL0 s2                                         ;shift '0' into result because could no subtract
 704  14300               div10_shifts: SLA s3                                         ;complete 16-bit shift left into [s3,s2]
 705  1490E                             SR0 s9                                         ;divide '10' value by 2 (shift right 1 place)
 706  14808                             SRA s8
 707  19001                             SUB s0, 01                                     ;count iterations
 708  31000                             RETURN Z                                       ;on return the remainder of division is in sA
 709  226FC                             JUMP 6FC[div10_loop]
 70A                                    ;
 70A                                    ; the scan code table lists the natural unshifted ASCII value associated with each code from
 70A                                    ; the SCAN CODE 2 table.
 70A                                    ;
 70A                                    ; Non-printable keys are assigned a value of 0x00 and are handled separately from within PS2CHECK.
 70A                                    ;
 70A                                    ; The numeric keypad keys are intercepted before this table when the NUMLOCK flag is set.
 70A                                    ;
 70A                                    ; the exceptions are:
 70A                                    ; ESC which is assigned the non-printable value of 0x1B.
 70A                                    ; RETURN which is assigned the non-printable value of 0x0D (CR, ^M)
 70A                                    ; TAB which is assigned the non-printable value of 0x09 (^I)
 70A                                    ; BACKSPACE which is assigned the non-printable value of 0x08 (^H)
 70A                                    ;
 70A                                    ; this table does not encode any of the extended keys (scan codes with prefix E0 or E1). Those
 70A                                    ; are also handled separately by PS2CHECK.
 70A                                    ;
 70A                                    ; we wanted to use the PicoBlaze-6 TABLE directive to simplify this code but it's brain dead
 70A                                    ; and will not accept a mixture of hex and character values so we did it the long way.
 70A                                    ;
 70A  21500                 SCAN_CODES: LOAD&RETURN s5, 00                             ; 00
 70B  21500                             LOAD&RETURN s5, 00                             ; 01 F9 (99)
 70C  21500                             LOAD&RETURN s5, 00                             ; 02
 70D  21500                             LOAD&RETURN s5, 00                             ; 03 F5
 70E  21500                             LOAD&RETURN s5, 00                             ; 04 F3
 70F  21500                             LOAD&RETURN s5, 00                             ; 05 F1
 710  21500                             LOAD&RETURN s5, 00                             ; 06 F2
 711  21500                             LOAD&RETURN s5, 00                             ; 07 F12
 712  21500                             LOAD&RETURN s5, 00                             ;
 713  21500                             LOAD&RETURN s5, 00                             ; 09 F10 (9A)
 714  21500                             LOAD&RETURN s5, 00                             ; 0A F8 (98)
 715  21500                             LOAD&RETURN s5, 00                             ; 0B F6 (96)
 716  21500                             LOAD&RETURN s5, 00                             ; 0C F4
 717  21509                             LOAD&RETURN s5, 09                             ; 0D Tab
 718  21560                             LOAD&RETURN s5, 60                             ; 0E ' not sure about this one. ''' accent grave
 719  21500                             LOAD&RETURN s5, 00                             ; 0F
 71A  21500                             LOAD&RETURN s5, 00                             ; 10
 71B  21500                             LOAD&RETURN s5, 00                             ; 11 left alt
 71C  21500                             LOAD&RETURN s5, 00                             ; 12 left shift
 71D  21500                             LOAD&RETURN s5, 00                             ; 13
 71E  21500                             LOAD&RETURN s5, 00                             ; 14 left CTRL
 71F  21571                             LOAD&RETURN s5, 71["q"]                        ; 15 q
 720  21531                             LOAD&RETURN s5, 31["1"]                        ; 16 1 (one)
 721  21500                             LOAD&RETURN s5, 00                             ; 17
 722  21500                             LOAD&RETURN s5, 00                             ; 18
 723  21500                             LOAD&RETURN s5, 00                             ; 19
 724  2157A                             LOAD&RETURN s5, 7A["z"]                        ; 1A z
 725  21573                             LOAD&RETURN s5, 73["s"]                        ; 1B s
 726  21561                             LOAD&RETURN s5, 61["a"]                        ; 1C a
 727  21577                             LOAD&RETURN s5, 77["w"]                        ; 1D w
 728  21532                             LOAD&RETURN s5, 32["2"]                        ; 1E 2
 729  21500                             LOAD&RETURN s5, 00                             ; 1F
 72A  21500                             LOAD&RETURN s5, 00                             ; 20
 72B  21563                             LOAD&RETURN s5, 63["c"]                        ; 21 c
 72C  21578                             LOAD&RETURN s5, 78["x"]                        ; 22 x
 72D  21564                             LOAD&RETURN s5, 64["d"]                        ; 23 d
 72E  21565                             LOAD&RETURN s5, 65["e"]                        ; 24 e
 72F  21534                             LOAD&RETURN s5, 34["4"]                        ; 25 4
 730  21533                             LOAD&RETURN s5, 33["3"]                        ; 26 3
 731  21500                             LOAD&RETURN s5, 00                             ; 27
 732  21500                             LOAD&RETURN s5, 00                             ; 28
 733  21520                             LOAD&RETURN s5, 20[" "]                        ; 29 space
 734  21576                             LOAD&RETURN s5, 76["v"]                        ; 2A v
 735  21566                             LOAD&RETURN s5, 66["f"]                        ; 2B f
 736  21574                             LOAD&RETURN s5, 74["t"]                        ; 2C t
 737  21572                             LOAD&RETURN s5, 72["r"]                        ; 2D r
 738  21535                             LOAD&RETURN s5, 35["5"]                        ; 2E 5
 739  21500                             LOAD&RETURN s5, 00                             ; 2F
 73A  21500                             LOAD&RETURN s5, 00                             ; 30
 73B  2156E                             LOAD&RETURN s5, 6E["n"]                        ; 31 n
 73C  21562                             LOAD&RETURN s5, 62["b"]                        ; 32 b
 73D  21568                             LOAD&RETURN s5, 68["h"]                        ; 33 h
 73E  21567                             LOAD&RETURN s5, 67["g"]                        ; 34 g
 73F  21579                             LOAD&RETURN s5, 79["y"]                        ; 35 y
 740  21536                             LOAD&RETURN s5, 36["6"]                        ; 36 6
 741  21500                             LOAD&RETURN s5, 00                             ; 37
 742  21500                             LOAD&RETURN s5, 00                             ; 38
 743  21500                             LOAD&RETURN s5, 00                             ; 39 (grave?)
 744  2156D                             LOAD&RETURN s5, 6D["m"]                        ; 3A m
 745  2156A                             LOAD&RETURN s5, 6A["j"]                        ; 3B j
 746  21575                             LOAD&RETURN s5, 75["u"]                        ; 3C u
 747  21537                             LOAD&RETURN s5, 37["7"]                        ; 3D 7
 748  21538                             LOAD&RETURN s5, 38["8"]                        ; 3E 8
 749  21500                             LOAD&RETURN s5, 00                             ; 3F
 74A  21500                             LOAD&RETURN s5, 00                             ; 40
 74B  2152C                             LOAD&RETURN s5, 2C[","]                        ; 41 ,
 74C  2156B                             LOAD&RETURN s5, 6B["k"]                        ; 42 k
 74D  21569                             LOAD&RETURN s5, 69["i"]                        ; 43 i
 74E  2156F                             LOAD&RETURN s5, 6F["o"]                        ; 44 o
 74F  21530                             LOAD&RETURN s5, 30["0"]                        ; 45 0 (zero)
 750  21539                             LOAD&RETURN s5, 39["9"]                        ; 46 9
 751  21500                             LOAD&RETURN s5, 00                             ; 47
 752  21500                             LOAD&RETURN s5, 00                             ; 48
 753  2152E                             LOAD&RETURN s5, 2E["."]                        ; 49 .
 754  2152F                             LOAD&RETURN s5, 2F["/"]                        ; 4A /
 755  2156C                             LOAD&RETURN s5, 6C["l"]                        ; 4B l (L)
 756  2153B                             LOAD&RETURN s5, 3B[";"]                        ; 4C ;
 757  21570                             LOAD&RETURN s5, 70["p"]                        ; 4D p
 758  2152D                             LOAD&RETURN s5, 2D["-"]                        ; 4E -
 759  21500                             LOAD&RETURN s5, 00                             ; 4F
 75A  21500                             LOAD&RETURN s5, 00                             ; 50
 75B  21500                             LOAD&RETURN s5, 00                             ; 51
 75C  21527                             LOAD&RETURN s5, 27                             ; 52 single quote "'", ascii 0x27
 75D  21500                             LOAD&RETURN s5, 00                             ; 53
 75E  2155B                             LOAD&RETURN s5, 5B["["]                        ; 54 [
 75F  2153D                             LOAD&RETURN s5, 3D["="]                        ; 55 =
 760  21500                             LOAD&RETURN s5, 00                             ; 56
 761  21500                             LOAD&RETURN s5, 00                             ; 57
 762  21500                             LOAD&RETURN s5, 00                             ; 58 caps lock
 763  21500                             LOAD&RETURN s5, 00                             ; 59 right shift
 764  2150D                             LOAD&RETURN s5, 0D[CR]                         ; 5A enter
 765  2155D                             LOAD&RETURN s5, 5D["]"]                        ; 5B ]
 766  21500                             LOAD&RETURN s5, 00                             ; 5C
 767  2155C                             LOAD&RETURN s5, 5C["\"]                        ; 5D \
 768  21500                             LOAD&RETURN s5, 00                             ; 5E
 769  21500                             LOAD&RETURN s5, 00                             ; 5F
 76A  21500                             LOAD&RETURN s5, 00                             ; 60
 76B  21500                             LOAD&RETURN s5, 00                             ; 61
 76C  21500                             LOAD&RETURN s5, 00                             ; 62
 76D  21500                             LOAD&RETURN s5, 00                             ; 63
 76E  21500                             LOAD&RETURN s5, 00                             ; 64
 76F  21500                             LOAD&RETURN s5, 00                             ; 65
 770  21508                             LOAD&RETURN s5, 08                             ; 66 BACKSPACE
 771  21500                             LOAD&RETURN s5, 00                             ; 67
 772  21500                             LOAD&RETURN s5, 00                             ; 68
 773  21531                             LOAD&RETURN s5, 31["1"]                        ; 69 1(KEYPAD END)
 774  21500                             LOAD&RETURN s5, 00                             ; 6A
 775  21534                             LOAD&RETURN s5, 34["4"]                        ; 6B 4(KEYPAD LEFT)
 776  21537                             LOAD&RETURN s5, 37["7"]                        ; 6C 7(KEYPAD HOME)
 777  21500                             LOAD&RETURN s5, 00                             ; 6D
 778  21500                             LOAD&RETURN s5, 00                             ; 6E
 779  21500                             LOAD&RETURN s5, 00                             ; 6F
 77A  21530                             LOAD&RETURN s5, 30["0"]                        ; 70 0(KEYPAD INS)
 77B  2152E                             LOAD&RETURN s5, 2E["."]                        ; 71 .(KEYPAD DEL)
 77C  21532                             LOAD&RETURN s5, 32["2"]                        ; 72 2(KEYPAD DOWN)
 77D  21535                             LOAD&RETURN s5, 35["5"]                        ; 73 5(KEYPAD)
 77E  21536                             LOAD&RETURN s5, 36["6"]                        ; 74 6(KEYPAD RIGHT)
 77F  21538                             LOAD&RETURN s5, 38["8"]                        ; 75 8(KEYPAD UP)
 780  2151B                             LOAD&RETURN s5, 1B                             ; 76 ESC
 781  21500                             LOAD&RETURN s5, 00                             ; 77 NUM LOCK
 782  21500                             LOAD&RETURN s5, 00                             ; 78 F11 (9B)
 783  2152B                             LOAD&RETURN s5, 2B["+"]                        ; 79 +(KEYPAD)
 784  21533                             LOAD&RETURN s5, 33["3"]                        ; 7A 3(KEYPAD PdDn)
 785  2152D                             LOAD&RETURN s5, 2D["-"]                        ; 7B -(KEYPAD)
 786  2152A                             LOAD&RETURN s5, 2A["*"]                        ; 7C *(KEYPAD)
 787  21539                             LOAD&RETURN s5, 39["9"]                        ; 7D 9(KEYPAD PgUp)
 788                                    CONSTANT LAST_SCAN_CODE, 7E
 788                                    ;LOAD&RETURN s5,00 ; 7E SCROLL LOCK
 788                                    ;LOAD&RETURN s5,00 ; 7F
 788                                    ;LOAD&RETURN s5,00 ; 80
 788                                    ;LOAD&RETURN s5,00 ; 81
 788                                    ;LOAD&RETURN s5,00 ; 82
 788                                    ;LOAD&RETURN s5,DC ; 83 F7 (97)
 788                                    CONSTANT UART_status_port, 00                  ; Read status
 788                                    CONSTANT UART_Tx_full, 00000100'b              ; full - bit2
 788                                    CONSTANT UART_TX6_output_port, 01
 788                                    CONSTANT reset_UART_port, 01
 788                                    CONSTANT UART_reset, 00000011'b                ; reset Tx and Rx
 788                                    CONSTANT UART_operate, 00000000'b              ; Tx and Rx free to operate
 788                 reset_UART_macros: 
 788  2B031                             OUTPUTK 03[UART_reset], 1[reset_UART_port]
 789  2B001                             OUTPUTK 00[UART_operate], 1[reset_UART_port]
 78A  25000                             RETURN 
 78B                           UART_TX: 
 78B  09000                             INPUT s0, 00[UART_status_port]                 ;Check if buffer is full
 78C  0D004                             TEST s0, 04[UART_Tx_full]
 78D  3678B                             JUMP NZ, 78B[UART_TX]                          ;wait if full
 78E  2D501                             OUTPUT s5, 01[UART_TX6_output_port]
 78F  25000                             RETURN 
 790                                    ;INCLUDE "uart_interface_routines.psm"
 790                                    ;
 790                                    ;
 790                                    ;------------------------------------------------------------------------------------------
 790                                    ; End of Program
 790                                    ;------------------------------------------------------------------------------------------
 790                                    ;


All unused memory locations contain zero (equivalent to 'LOAD s0, s0')



List of PSM files that have been assembled

C:\Users\equack\Documents\Xilinx\DVI-1080p\dvid_test_hd\PicoBlaze\uart_control.psm



List of defined constants

 CONSTANT name         Value        Source PSM File

 timestamp_hours       12'd         
 timestamp_minutes     47'd         
 timestamp_seconds     09'd         
 datestamp_year        17'd         
 datestamp_month       4'd          
 datestamp_day         15'd         
 NUL                   00           
 BEL                   07           
 BS                    08           
 HT                    09           
 LF                    0A           
 VT                    0B           
 CR                    0D           
 ESC                   1B           
 DEL                   7F           
 DCS                   90           
 ST                    9C           
 EXTKEY_END            69           uart_control.psm
 EXTKEY_LEFT           6B           uart_control.psm
 EXTKEY_HOME           6C           uart_control.psm
 EXTKEY_INSERT         70           uart_control.psm
 EXTKEY_DELETE         71           uart_control.psm
 EXTKEY_DOWN           72           uart_control.psm
 EXTKEY_RIGHT          74           uart_control.psm
 EXTKEY_UP             75           uart_control.psm
 EXTKEY_PGDN           7A           uart_control.psm
 EXTKEY_PGUP           7D           uart_control.psm
 EXTKEY_KEYPAD_ENTER   5A           uart_control.psm
 EXTKEY_KEYPAD_SLASH   4A           uart_control.psm
 EXTKEY_WINDOWS        5B           uart_control.psm
 EXTKEY_MENU           5C           uart_control.psm
 EXTKEY_RIGHT_ALT      11           uart_control.psm
 EXTKEY_PRINT_SCREEN   12           uart_control.psm
 EXTKEY_PRINT_SCREEN2  7C           uart_control.psm
 KEYPAD_END            69           uart_control.psm
 KEYPAD_LEFT           6B           uart_control.psm
 KEYPAD_HOME           6C           uart_control.psm
 KEYPAD_INSERT         70           uart_control.psm
 KEYPAD_DELETE         71           uart_control.psm
 KEYPAD_DOWN           72           uart_control.psm
 KEYPAD_DEAD           73           uart_control.psm
 KEYPAD_RIGHT          74           uart_control.psm
 KEYPAD_UP             75           uart_control.psm
 KEYPAD_PGDN           7A           uart_control.psm
 KEYPAD_PGUP           7D           uart_control.psm
 PAUSE_BREAK_PREFIX    E1           uart_control.psm
 KEY_LEFT_SHIFT        12           uart_control.psm
 KEY_RIGHT_SHIFT       59           uart_control.psm
 KEY_LEFT_CONTROL      14           uart_control.psm
 KEY_LEFT_ALT          11           uart_control.psm
 KEY_RIGHT_CONTROL     14           uart_control.psm
 KEY_RIGHT_ALT         11           uart_control.psm
 KEY_CAPSLOCK          58           uart_control.psm
 KEY_NUMLOCK           77           uart_control.psm
 KEY_SCROLLLOCK        7E           uart_control.psm
 KEY_F1                05           uart_control.psm
 KEY_F2                06           uart_control.psm
 KEY_F3                04           uart_control.psm
 KEY_F4                0C           uart_control.psm
 KEY_F5                03           uart_control.psm
 KEY_F6                0B           uart_control.psm
 KEY_F7                83           uart_control.psm
 KEY_F8                0A           uart_control.psm
 KEY_F9                01           uart_control.psm
 KEY_F10               09           uart_control.psm
 KEY_F11               78           uart_control.psm
 KEY_F12               07           uart_control.psm
 MAX_LINE_LOWER        68           uart_control.psm
 MAX_LINE_UPPER        1F           uart_control.psm
 LAST_LINE_LOWER       F0           uart_control.psm
 LAST_LINE_UPPER       1E           uart_control.psm
 MAX_LINE              43           uart_control.psm
 scratchLOW            00           uart_control.psm
 scratchHIGH           01           uart_control.psm
 decimal0              02           uart_control.psm
 decimal1              03           uart_control.psm
 decimal2              04           uart_control.psm
 decimal3              05           uart_control.psm
 decimal4              06           uart_control.psm
 param_counter         07           uart_control.psm
 param_block           08           uart_control.psm
 param_two             09           uart_control.psm
 max_param             10           uart_control.psm
 digit_counter         11           uart_control.psm
 digit_block           12           uart_control.psm
 max_digit             05           uart_control.psm
 hidden_color          17           uart_control.psm
 extra_flags           18           uart_control.psm
 RAM_19                19           uart_control.psm
 RAM_1A                1A           uart_control.psm
 RAM_1B                1B           uart_control.psm
 RAM_1C                1C           uart_control.psm
 RAM_1D                1D           uart_control.psm
 offset_low            1E           uart_control.psm
 offset_high           1F           uart_control.psm
 mode_flags            30           uart_control.psm
 last_char             31           uart_control.psm
 saved_cursor_low      32           uart_control.psm
 saved_cursor_high     33           uart_control.psm
 saved_color_reg       34           uart_control.psm
 saved_ansi_reg        35           uart_control.psm
 scratchQ              36           uart_control.psm
 scratchR              37           uart_control.psm
 scratchS              38           uart_control.psm
 scratchT              39           uart_control.psm
 scratchU              3A           uart_control.psm
 scratchV              3B           uart_control.psm
 scratchW              3C           uart_control.psm
 scratchX              3D           uart_control.psm
 scratchY              3E           uart_control.psm
 scratchZ              3F           uart_control.psm
 MODE_TALL             01           uart_control.psm
 MODE_EIGHTY           02           uart_control.psm
 MODE_FIFTY            04           uart_control.psm
 MODE_CAPS_LOCK        08           uart_control.psm
 MODE_NUM_LOCK         10           uart_control.psm
 MODE_SCROLL_LOCK      20           uart_control.psm
 MODE_40               40           uart_control.psm
 MODE_80               80           uart_control.psm
 MODE_CAPS_LOCK_CLR    F7           uart_control.psm
 MODE_NUM_LOCK_CLR     EF           uart_control.psm
 MODE_SCROLL_LOCK_CLR  DF           uart_control.psm
 MSB_PORT              02           uart_control.psm
 LSB_PORT              03           uart_control.psm
 CHAR_PORT             04           uart_control.psm
 CHAR_READ_PORT        05           uart_control.psm
 PS2_READ_PORT         06           uart_control.psm
 PS2_STATUS_PORT       07           uart_control.psm
 ATTR_PORT             09           uart_control.psm
 ATTR_READ_PORT        0A           uart_control.psm
 MODE_PORT             0B           uart_control.psm
 UART_STATUS_PORT      0C           uart_control.psm
 UART_READ_FIFO_PORT   0D           uart_control.psm
 UART_FIFO_EMPTY       01           uart_control.psm
 UART_FIFO_FULL        02           uart_control.psm
 OFFSET_MSB_PORT       0E           uart_control.psm
 OFFSET_LSB_PORT       0F           uart_control.psm
 TYPEMATIC_PORT        10           uart_control.psm
 KEY_RELEASE           01           uart_control.psm
 LEFT_SHIFT            02           uart_control.psm
 RIGHT_SHIFT           04           uart_control.psm
 EITHER_SHIFT          06           uart_control.psm
 LEFT_ALT              08           uart_control.psm
 RIGHT_ALT             10           uart_control.psm
 EITHER_ALT            18           uart_control.psm
 LEFT_CONTROL          20           uart_control.psm
 RIGHT_CONTROL         40           uart_control.psm
 EITHER_CONTROL        60           uart_control.psm
 EXTENDED              80           uart_control.psm
 KEY_RELEASE_CLR       FE           uart_control.psm
 LEFT_SHIFT_CLR        FD           uart_control.psm
 RIGHT_SHIFT_CLR       FB           uart_control.psm
 LEFT_ALT_CLR          F7           uart_control.psm
 RIGHT_ALT_CLR         EF           uart_control.psm
 LEFT_CONTROL_CLR      DF           uart_control.psm
 RIGHT_CONTROL_CLR     BF           uart_control.psm
 EXTENDED_CLR          7F           uart_control.psm
 RELEASE_EXT_CLR       7E           uart_control.psm
 ANSI_CSI              01           uart_control.psm
 ANSI_ESCAPE           02           uart_control.psm
 ANSI_ESC_CSI          03           uart_control.psm
 ANSI_INVERSE          04           uart_control.psm
 ANSI_HIDDEN           08           uart_control.psm
 ANSI_SSG2             10           uart_control.psm
 ANSI_SCROLL_LOCK      20           uart_control.psm
 ANSI_NUM_LOCK         40           uart_control.psm
 ANSI_CAPS_LOCK        80           uart_control.psm
 ANSI_CSI_CLR          FE           uart_control.psm
 ANSI_ESCAPE_CLR       FD           uart_control.psm
 ANSI_INVERSE_CLR      FB           uart_control.psm
 ANSI_HIDDEN_CLR       F7           uart_control.psm
 ANSI_SSG2_CLR         EF           uart_control.psm
 ANSI_SCROLL_LOCK_CLR  DF           uart_control.psm
 ANSI_NUM_LOCK_CLR     BF           uart_control.psm
 ANSI_CAPS_LOCK_CLR    7F           uart_control.psm
 EXTRA_DEBUG           01           uart_control.psm
 EXTRA_NETHACK         02           uart_control.psm
 EXTRA_VT_GRAPHICS     04           uart_control.psm
 EXTRA_VT_GRAPHICS_CLR FB           uart_control.psm
 EXTRA_NETHACK_CLR     FE           uart_control.psm
 EXTRA_DEBUG_CLR       FF           uart_control.psm
 ENQ_CHAR              05           uart_control.psm
 ACK_CHAR              06           uart_control.psm
 BEL_CHAR              07           uart_control.psm
 TAB_CHAR              09           uart_control.psm
 FORM_FEED_CHAR        0C           uart_control.psm
 ESC_CHAR              1B           uart_control.psm
 RUBOUT_CHAR           7F           uart_control.psm
 LAST_SCAN_CODE        7E           uart_control.psm
 UART_status_port      00           uart_control.psm
 UART_Tx_full          00000100'b   uart_control.psm
 UART_TX6_output_port  01           uart_control.psm
 reset_UART_port       01           uart_control.psm
 UART_reset            00000011'b   uart_control.psm
 UART_operate          00000000'b   uart_control.psm



No TABLEs defined



List of text strings

 STRING name       String               Source PSM File

 KCPSM6_version$   "v2.70"              
 datestamp$        "15 Apr 2017"        
 timestamp$        "12:47:09"           
 hello$            "QuackTerm V1.0   "  uart_control.psm



List of line labels

   Label                       Addr  Source PSM File

 * cold_start                  000   uart_control.psm
   init_terminal               002   uart_control.psm
 * soft_boot                   012   uart_control.psm
   color_loop                  020   uart_control.psm
   echo_loop                   029   uart_control.psm
   UART_FIFO_RX                02E   uart_control.psm
   UART_TIMEOUT                02F   uart_control.psm
   read_fifo_Rx                035   uart_control.psm
   decrement_cursor            039   uart_control.psm
   advance_cursor              03C   uart_control.psm
   set_cursor                  03E   uart_control.psm
   PS2CHECK                    041   uart_control.psm
 * check_release               045   uart_control.psm
 * left_shift_up               047   uart_control.psm
   right_shift_up              04D   uart_control.psm
   right_control_up            051   uart_control.psm
   right_alt_up                057   uart_control.psm
   left_control_up             05D   uart_control.psm
   left_alt_up                 061   uart_control.psm
   finish_release              065   uart_control.psm
   check_prefix                067   uart_control.psm
   release_code                06B   uart_control.psm
   standard_code               06F   uart_control.psm
 * scroll_lock_hit             06F   uart_control.psm
   num_lock_hit                078   uart_control.psm
 * shift_numlock               07C   uart_control.psm
   control_numlock             080   uart_control.psm
   normal_numlock              086   uart_control.psm
   caps_lock_hit               08B   uart_control.psm
   left_shift                  092   uart_control.psm
   right_shift                 098   uart_control.psm
   right_control               09C   uart_control.psm
   left_control                0A3   uart_control.psm
   right_alt                   0A7   uart_control.psm
   left_alt                    0AE   uart_control.psm
   actual_key                  0B2   uart_control.psm
 * ext_enter                   0B4   uart_control.psm
   ext_slash                   0B8   uart_control.psm
   ext_delete                  0BC   uart_control.psm
   ext_do_delete               0BE   uart_control.psm
   ext_up                      0C3   uart_control.psm
   ext_do_up                   0C5   uart_control.psm
   ext_down                    0C9   uart_control.psm
   ext_do_down                 0CB   uart_control.psm
   ext_right                   0CF   uart_control.psm
   ext_do_right                0D1   uart_control.psm
   ext_left                    0D5   uart_control.psm
   ext_do_left                 0D7   uart_control.psm
   ext_do_dead                 0DB   uart_control.psm
   extended_modifiers          0DF   uart_control.psm
   extended_modifiers_single   0E9   uart_control.psm
   test_modifiers              0F5   uart_control.psm
 * test_shift                  0F6   uart_control.psm
   test_alt                    0F9   uart_control.psm
   test_control                0FC   uart_control.psm
   test_end                    0FF   uart_control.psm
   ext_home                    100   uart_control.psm
   ext_do_home                 102   uart_control.psm
   ext_insert                  107   uart_control.psm
   ext_do_insert               109   uart_control.psm
   ext_end                     10E   uart_control.psm
   ext_do_end                  110   uart_control.psm
   ext_pgup                    115   uart_control.psm
 * ext_do_pgup                 117   uart_control.psm
   ext_pgdn                    11C   uart_control.psm
   ext_do_pgdn                 11E   uart_control.psm
   ext_other                   123   uart_control.psm
 * extended_code               123   uart_control.psm
   not_extended                125   uart_control.psm
 * numlock_on                  127   uart_control.psm
   hack_dot                    141   uart_control.psm
   hack_0                      143   uart_control.psm
   hack_1                      145   uart_control.psm
   hack_2                      147   uart_control.psm
   hack_3                      149   uart_control.psm
   hack_4                      14B   uart_control.psm
   hack_5                      14D   uart_control.psm
   hack_6                      14F   uart_control.psm
   hack_7                      151   uart_control.psm
   hack_8                      153   uart_control.psm
   hack_9                      155   uart_control.psm
   keypad_navigation           157   uart_control.psm
   special_non_extended        16D   uart_control.psm
 * F1_key_hit                  16D   uart_control.psm
   F2_key_hit                  175   uart_control.psm
   F3_key_hit                  17D   uart_control.psm
   F4_key_hit                  185   uart_control.psm
   F5_key_hit                  18D   uart_control.psm
   F6_key_hit                  196   uart_control.psm
   F7_key_hit                  19F   uart_control.psm
   F8_key_hit                  1A8   uart_control.psm
   F9_key_hit                  1B1   uart_control.psm
   F10_key_hit                 1BA   uart_control.psm
   F11_key_hit                 1C3   uart_control.psm
   F12_key_hit                 1CC   uart_control.psm
   pause_break                 1D5   uart_control.psm
 * not_special                 1D5   uart_control.psm
 * shifted_symbol              1DC   uart_control.psm
 * key0                        1DE   uart_control.psm
   key1                        1E3   uart_control.psm
   key2                        1E7   uart_control.psm
   key3                        1EB   uart_control.psm
   key4                        1EF   uart_control.psm
   key5                        1F3   uart_control.psm
   key6                        1F7   uart_control.psm
   key7                        1FE   uart_control.psm
   key8                        202   uart_control.psm
   key9                        206   uart_control.psm
   key10                       20A   uart_control.psm
   key11                       20E   uart_control.psm
   key12                       212   uart_control.psm
   key13                       219   uart_control.psm
   key14                       21D   uart_control.psm
   key15                       221   uart_control.psm
   key16                       225   uart_control.psm
   key17                       229   uart_control.psm
   key18                       22D   uart_control.psm
   key19                       231   uart_control.psm
   key20                       235   uart_control.psm
   key21                       239   uart_control.psm
   not_shifted                 240   uart_control.psm
 * control_symbol              240   uart_control.psm
 * key00                       242   uart_control.psm
   key01                       246   uart_control.psm
   key02                       24A   uart_control.psm
   key03                       24E   uart_control.psm
   key04                       252   uart_control.psm
   check_special               256   uart_control.psm
   check_shift                 25F   uart_control.psm
   no_caps_lock                265   uart_control.psm
   printable_char              268   uart_control.psm
   print_the_char              26B   uart_control.psm
   output_to_host              26E   uart_control.psm
   send_next                   270   uart_control.psm
   not_stored                  275   uart_control.psm
   raw_char_out                296   uart_control.psm
   raw_vt_graphics             29A   uart_control.psm
 * vt100_a                     29D   uart_control.psm
 * vt100_j                     29D   uart_control.psm
 * vt100_k                     29D   uart_control.psm
 * vt100_l                     29D   uart_control.psm
 * vt100_m                     29D   uart_control.psm
 * vt100_n                     29D   uart_control.psm
 * vt100_q                     29D   uart_control.psm
   vt100_t                     2A0   uart_control.psm
 * vt100_u                     2A0   uart_control.psm
 * vt100_v                     2A0   uart_control.psm
 * vt100_w                     2A0   uart_control.psm
 * vt100_x                     2A0   uart_control.psm
 * vt100_tilde                 2A0   uart_control.psm
   raw_output                  2A0   uart_control.psm
   escape_received             2AC   uart_control.psm
   escape_sequence             2AE   uart_control.psm
   not_csi                     2B3   uart_control.psm
 * save_cursor                 2B3   uart_control.psm
   restore_cursor              2BA   uart_control.psm
   RSI                         2C2   uart_control.psm
   SSG2                        2C5   uart_control.psm
   end_csi                     2C8   uart_control.psm
   parse_csi_init              2CA   uart_control.psm
 * start_clear                 2CE   uart_control.psm
   clear_params                2D0   uart_control.psm
   parse_csi_digit             2D5   uart_control.psm
 * process_digit               2DA   uart_control.psm
   not_a_digit                 2E1   uart_control.psm
 * check_semicolon             2E2   uart_control.psm
   csi_delete_line             2E5   uart_control.psm
   delete_line_loop            2F1   uart_control.psm
   end_delete_line_loop        300   uart_control.psm
   csi_insert_line             302   uart_control.psm
   insert_line_loop            311   uart_control.psm
   csi_erase_char              323   uart_control.psm
   erase_char_loop             32B   uart_control.psm
   csi_insert_char             336   uart_control.psm
   insert_loop                 33C   uart_control.psm
   insert_next                 346   uart_control.psm
   csi_delete_char             359   uart_control.psm
   delete_loop                 35F   uart_control.psm
   delete_next                 364   uart_control.psm
   csi_clear                   37B   uart_control.psm
   partial_clear               382   uart_control.psm
   end_clear                   386   uart_control.psm
   csi_sgr                     388   uart_control.psm
   sgr_param                   38D   uart_control.psm
 * sgr_reset                   38E   uart_control.psm
   sgr_bold                    399   uart_control.psm
   sgr_blink                   3A1   uart_control.psm
   sgr_inverse                 3A9   uart_control.psm
   sgr_hidden                  3B0   uart_control.psm
   sgr_no_vt_graphics          3B4   uart_control.psm
   sgr_vt_graphics             3BC   uart_control.psm
   sgr_reveal                  3C4   uart_control.psm
   sgr_normal_intensity        3C8   uart_control.psm
   sgr_blink_off               3D0   uart_control.psm
   sgr_positive                3D8   uart_control.psm
   sgr_default_foreground      3DF   uart_control.psm
   sgr_default_background      3E8   uart_control.psm
   sgr_foreground              3F0   uart_control.psm
   sgr_background              403   uart_control.psm
   sgr_other                   412   uart_control.psm
   sgr_next                    412   uart_control.psm
 * sgr_end                     415   uart_control.psm
   csi_move                    416   uart_control.psm
   csi_move2                   41A   uart_control.psm
   two_params                  41F   uart_control.psm
   move_y0                     424   uart_control.psm
   move_y00                    428   uart_control.psm
   move_x0                     432   uart_control.psm
   move_x00                    436   uart_control.psm
   csi_set_row                 43A   uart_control.psm
   row_0                       440   uart_control.psm
   row_00                      444   uart_control.psm
   csi_set_column              450   uart_control.psm
   column_0                    456   uart_control.psm
   column_00                   45A   uart_control.psm
   csi_repeat                  466   uart_control.psm
   repeat_loop                 46F   uart_control.psm
   csi_clear_line              478   uart_control.psm
 * clear_whole_line            482   uart_control.psm
   clear_sol                   489   uart_control.psm
   clear_sol_loop              48A   uart_control.psm
   clear_eol                   492   uart_control.psm
   clear_eol_loop              49A   uart_control.psm
   finish_clear_line           4A0   uart_control.psm
   csi_up                      4A4   uart_control.psm
   up_loop                     4AA   uart_control.psm
   csi_down                    4AE   uart_control.psm
   down_loop                   4B4   uart_control.psm
   csi_right                   4B8   uart_control.psm
   one_right                   4BF   uart_control.psm
   csi_left                    4C6   uart_control.psm
   one_left                    4CD   uart_control.psm
   csi_back_tab                4D4   uart_control.psm
   back_tab_loop               4DA   uart_control.psm
   csi_tab                     4E1   uart_control.psm
   tab_loop                    4E7   uart_control.psm
   csi_device_status_report    4EE   uart_control.psm
 * send_position_report        4F3   uart_control.psm
   DSR_other                   50D   uart_control.psm
   csi_margins                 50E   uart_control.psm
   csi_tilde                   511   uart_control.psm
 * check_home                  514   uart_control.psm
   check_insert                518   uart_control.psm
   check_delete                51D   uart_control.psm
   check_end                   522   uart_control.psm
   check_pgup                  526   uart_control.psm
   check_pgdn                  52A   uart_control.psm
   unknown_command             52E   uart_control.psm
   exit_escape                 530   uart_control.psm
   end_param                   533   uart_control.psm
   do_digit                    538   uart_control.psm
   end_digits                  544   uart_control.psm
   invert_colors               54E   uart_control.psm
   enquiry                     55B   uart_control.psm
   backspace                   55E   uart_control.psm
   rubout                      55F   uart_control.psm
   htab                        563   uart_control.psm
   backtab                     56A   uart_control.psm
   full_back                   574   uart_control.psm
   left_cursor                 577   uart_control.psm
   right_cursor                57E   uart_control.psm
   line_up                     584   uart_control.psm
   line_down                   58B   uart_control.psm
   line_feed                   592   uart_control.psm
   clear_start_screen          599   uart_control.psm
   clear_backward              59C   uart_control.psm
   form_feed                   5A9   uart_control.psm
   clear_end_screen            5AB   uart_control.psm
   clear_a_char                5AE   uart_control.psm
   home_cursor                 5BA   uart_control.psm
   set_origin                  5C1   uart_control.psm
   end_cursor                  5C5   uart_control.psm
   end_of_line                 5C9   uart_control.psm
   CRLF                        5CF   uart_control.psm
   carriage_return             5D1   uart_control.psm
   cr_leftedge                 5D3   uart_control.psm
 * cr_regadjust                5D8   uart_control.psm
   cr_scroll_up                5DA   uart_control.psm
   scroll_up                   5DC   uart_control.psm
 * scroll_offset               5DE   uart_control.psm
   clear_last_line             5E6   uart_control.psm
   clear_loop                  5E9   uart_control.psm
 * done_scrolling              5F1   uart_control.psm
   clear_current_line          5F5   uart_control.psm
   clear_line_loop             5F7   uart_control.psm
   ring_bell                   603   uart_control.psm
   invert_screen               60E   uart_control.psm
   bell_loop                   610   uart_control.psm
   caps_led_on                 61A   uart_control.psm
   caps_led_off                61F   uart_control.psm
   num_led_on                  624   uart_control.psm
   num_led_off                 629   uart_control.psm
   scroll_led_on               62E   uart_control.psm
   scroll_led_off              633   uart_control.psm
   test_pattern                638   uart_control.psm
   ascii_set                   639   uart_control.psm
   send_tilde                  640   uart_control.psm
   send_csi                    642   uart_control.psm
   print_string                646   uart_control.psm
 * hex_byte                    651   uart_control.psm
   debug_hex                   65D   uart_control.psm
   print_hex                   663   uart_control.psm
   hex_to_text                 66F   uart_control.psm
   number_to_char              672   uart_control.psm
   debug_s4                    674   uart_control.psm
   hello_msg                   681   uart_control.psm
   get_row_column_plus         693   uart_control.psm
   get_row_column              698   uart_control.psm
   finish_row_column           69A   uart_control.psm
   divide_16bit_by_any         69D   uart_control.psm
   div_loop                    6A2   uart_control.psm
   div_restore                 6A7   uart_control.psm
   div_shifts                  6AA   uart_control.psm
   delay_100ms                 6B0   uart_control.psm
 * delay_4ms                   6B4   uart_control.psm
   software_delay              6B8   uart_control.psm
   mult_8x8                    6BD   uart_control.psm
   mult_loop                   6C0   uart_control.psm
   no_add                      6C3   uart_control.psm
   send_integer                6C8   uart_control.psm
   send_integer_loop           6CE   uart_control.psm
   next_int_digit              6D4   uart_control.psm
   zero_integer                6D8   uart_control.psm
   print_integer               6DB   uart_control.psm
   print_integer_loop          6E1   uart_control.psm
   next_print_digit            6E7   uart_control.psm
   zero_printeger              6EB   uart_control.psm
   integer16_to_BCD            6EE   uart_control.psm
   int_to_BCD_loop             6EF   uart_control.psm
   divide_16bit_by_10          6F5   uart_control.psm
   div10_loop                  6FC   uart_control.psm
   div10_restore               701   uart_control.psm
   div10_shifts                704   uart_control.psm
   SCAN_CODES                  70A   uart_control.psm
   reset_UART_macros           788   uart_control.psm
   UART_TX                     78B   uart_control.psm

      * Line label has not been referenced in any instructions.
        Hint - This may indicate unused code that could be
               removed to reduce the size of this program.



Instruction usage statistics

 Instruction    Instances

 LOAD            245
 STAR              -

 AND              35
 OR               22
 XOR               5

 ADD              71
 ADDCY            24
 SUB              57
 SUBCY            15

 TEST             59
 TESTCY            -
 COMPARE         230
 COMPARECY        14

 SL0              11
 SL1               2
 SLX               -
 SLA               2
 RL                -
 SR0              14
 SR1               -
 SRX               -
 SRA               4
 RR                -

 REGBANK           -

 INPUT            14
 OUTPUT           48
 OUTPUTK           2

 STORE            93
 FETCH            93

 DISABLE           -
 ENABLE            -
 RETURNI           -

 JUMP            415
 JUMP@             -
 CALL            234
 CALL@             2
 RETURN           88
 LOAD&RETURN     144

 HWBUILD           -



End of KCPSM6 log file.
