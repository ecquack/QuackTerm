KCPSM6 Assembler log file for program 'C:\Users\equack\Documents\Xilinx\DVI-1080p\dvid_test_hd\PicoBlaze\quackterm.psm'.
Generated by KCPSM6 version v2.70
Ken Chapman - Xilinx Ltd - 16th May 2014

Assembly datestamp: 22 May 2017
Assembly timestamp: 16:13:31

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: 639 hex
Nominal program memory size: 2K (2048)   address(10:0)
Actual memory size: 2048
  (Memory size defined by -c option)
Occupied memory locations: 1594
Memory locations available: 454


Assembly listing

 Addr Code                                Instruction

 000                                      ;Copyright (C) 2017 Erik C. Quackenbush erikcq@quackenbush.com
 000                                      ;
 000                                      ; this is an ANSI terminal emulation program.
 000                                      ;
 000                                      ; this Picoblaze-6 program implements an ANSI display terminal which talks to a host over the USB to serial
 000                                      ; converter and generates an HDMI 120x67 (or 80x50) character display with input from a keyboard processor.
 000                                      ;
 000                                      ; MAX_LINE_upper/lower is one character beyond the last visible character in the last line of the screen.
 000                                      ; LAST_LINE is the first character of the last line on the screen
 000                                      ; MAX_LINE is the number of lines on the screen.
 000                                      ;
 000                                      ; RAM ADDRESS assignments
 000                                      ; this is our memory map.
 000                                      CONSTANT scratchLOW, 00
 000                                      CONSTANT scratchHIGH, 01
 000                                      CONSTANT decimal0, 02                           ;  5 digit decimal value
 000                                      CONSTANT decimal1, 03                           ;  Suitable for 16-bit values up to
 000                                      CONSTANT decimal2, 04                           ;  65,536, used to print integer values
 000                                      CONSTANT decimal3, 05
 000                                      CONSTANT decimal4, 06
 000                                      CONSTANT param_counter, 07                      ; the number of CSI parameters is stored in 0x07
 000                                      CONSTANT param_block, 08                        ; the parameter block is stored at location 0x08-0x0F
 000                                      CONSTANT param_two, 09                          ; second parameter
 000                                      CONSTANT max_param, 10                          ; the last valid entry in the parameter block is 0x0F (0x10-1)
 000                                      CONSTANT digit_counter, 11                      ; the number of digits in the current parameter (so far) is stored in 0x11
 000                                      CONSTANT digit_block, 12                        ; the string of digits
 000                                      CONSTANT max_digit, 05                          ; we only allow 4 digit decimal parameters & we only process three of those digits. (this is not a RAM location)
 000                                      CONSTANT RAM_17, 17
 000                                      CONSTANT RAM_18, 18
 000                                      CONSTANT RAM_19, 19
 000                                      CONSTANT RAM_1A, 1A                             ; these are unused
 000                                      CONSTANT RAM_1B, 1B
 000                                      CONSTANT RAM_1C, 1C
 000                                      CONSTANT RAM_1D, 1D
 000                                      CONSTANT offset_low, 1E                         ; scrolling offset used for hardware scrolling
 000                                      CONSTANT offset_high, 1F                        ; this address gets added in hardware to the cursor address.
 000                                      CONSTANT MAX_LINE_LOWER, 20
 000                                      CONSTANT MAX_LINE_UPPER, 21
 000                                      CONSTANT LAST_LINE_LOWER, 22
 000                                      CONSTANT LAST_LINE_UPPER, 23
 000                                      CONSTANT video_mode, 2F
 000                                      CONSTANT mode_flags, 30
 000                                      CONSTANT last_char, 31                          ; the last character transmitted
 000                                      CONSTANT saved_cursor_low, 32
 000                                      CONSTANT saved_cursor_high, 33
 000                                      CONSTANT saved_color_reg, 34
 000                                      CONSTANT saved_ansi_reg, 35
 000                                      CONSTANT scratchQ, 36
 000                                      CONSTANT scratchR, 37
 000                                      CONSTANT scratchS, 38
 000                                      CONSTANT scratchT, 39
 000                                      CONSTANT scratchU, 3A
 000                                      CONSTANT scratchV, 3B
 000                                      CONSTANT scratchW, 3C
 000                                      CONSTANT scratchX, 3D
 000                                      CONSTANT scratchY, 3E
 000                                      CONSTANT scratchZ, 3F                           ; the top of memory unless we change the picoblaze-6 generic in VHDL
 000                                      ; these bits are used by video_mode
 000                                      CONSTANT VIDEO_TALL, 01                         ; 67/50 or 33/25 lines (these bits define the video mode)
 000                                      CONSTANT VIDEO_EIGHTY, 02                       ; width 120 or 80
 000                                      CONSTANT VIDEO_FIFTY, 04                        ; height 67 or 50 (or 33/25 in tall mode)
 000                                      CONSTANT CURSOR_BLOCK, 08                       ; block cursor or underline cursor?
 000                                      CONSTANT CURSOR_HIDDEN, 10                      ; hidden cursor is not a hardware feature- the software just moves it off the visibile screen when idle.
 000                                      CONSTANT CURSOR_BLOCK_CLR, F7
 000                                      CONSTANT CURSOR_HIDDEN_CLR, EF
 000                                      ; thses bits are used by mode_flags
 000                                      CONSTANT MODE_ALTERNATE_FONT, 01                ; ninth bit of character memory
 000                                      CONSTANT MODE_UNDERLINE, 02                     ; ninth bit of attribute memory
 000                                      CONSTANT MODE_04, 04                            ; bit reserved.
 000                                      CONSTANT MODE_08, 08                            ; bit reserved.
 000                                      CONSTANT MODE_10, 10                            ; bit reserved.
 000                                      CONSTANT MODE_SET_FONT, 20
 000                                      CONSTANT MODE_META, 40
 000                                      CONSTANT MODE_LOCAL, 80
 000                                      CONSTANT MODE_ALTERNATE_FONT_CLR, FE
 000                                      CONSTANT MODE_UNDERLINE_CLR, FD
 000                                      CONSTANT MODE_SET_FONT_CLR, DF
 000                                      CONSTANT MODE_META_CLR, BF
 000                                      CONSTANT MODE_LOCAL_CLR, 7F
 000                                      ; these are the 8 possible video modes
 000                                      ;
 000                                      ; 0x00  120x67 * default
 000                                      ; 0x01  120x33
 000                                      ; 0x02   80x67
 000                                      ; 0x03   80x33
 000                                      ; 0x04  120x50
 000                                      ; 0x05  120x25
 000                                      ; 0x06  80x50
 000                                      ; 0x07  80x25
 000                                      ; these are the I/O port addresses.
 000                                      ;
 000                                      CONSTANT MSB_PORT, 02                           ; write the MSB of the cursor position here
 000                                      CONSTANT LSB_PORT, 03                           ; write the LSB of the cursor position here
 000                                      CONSTANT CHAR_PORT, 04                          ; write the character value here
 000                                      CONSTANT CHAR_READ_PORT, 05                     ; read the character value here
 000                                      CONSTANT ATTR_PORT, 09                          ; write to this to set the colors
 000                                      CONSTANT ATTR_READ_PORT, 0A                     ; read from this to see the colors
 000                                      CONSTANT MODE_PORT, 0B                          ; sets the video mode bits (120/80,50/25,50/67)
 000                                      CONSTANT UART_STATUS_PORT, 0C
 000                                      CONSTANT UART_READ_FIFO_PORT, 0D
 000                                      CONSTANT KEYBOARD_FIFO_PORT, 40
 000                                      CONSTANT KEYBOARD_STATUS_PORT, 41
 000                                      CONSTANT EXTRA_READ_PORT, 50
 000                                      CONSTANT EXTRA_PORT, 51
 000                                      CONSTANT FIFO_EMPTY, 01
 000                                      CONSTANT FIFO_FULL, 02
 000                                      CONSTANT OFFSET_MSB_PORT, 0E                    ; scrolling offset gets added to the cursor address
 000                                      CONSTANT OFFSET_LSB_PORT, 0F                    ; so try to set these to a multiple of CHAR_PER_LINE
 000                                      ; ANSI_FLAG_REG contains these command processing state flag bigs
 000                                      ; OR these with the register to set the bits
 000                                      CONSTANT ANSI_CSI, 01                           ; did we receive an ESC followed by a [ prefix?
 000                                      CONSTANT ANSI_ESCAPE, 02                        ; did we receive an ESC prefix?
 000                                      CONSTANT ANSI_ESC_CSI, 03                       ; either ESC and/or CSI
 000                                      CONSTANT ANSI_INVERSE, 04                       ; are the foreground and background colors revered?
 000                                      CONSTANT ANSI_HIDDEN, 08                        ; is the foreground color set to the background color?
 000                                      CONSTANT ANSI_SSG2, 10                          ; single shift 2: the next character is to be printed RAW
 000                                      CONSTANT ANSI_DEBUG, 20                         ; we output characters RAW for debugging
 000                                      CONSTANT ANSI_VT_GRAPHICS, 40                   ; VT100 graphics characters instead of lower case
 000                                      CONSTANT ANSI_SSG3, 80                          ; single shift 3
 000                                      CONSTANT ANSI_SSG, 90                           ; either single shift
 000                                      ; AND these with the register to clear the bits
 000                                      CONSTANT ANSI_CSI_CLR, FE
 000                                      CONSTANT ANSI_ESCAPE_CLR, FD
 000                                      CONSTANT ANSI_INVERSE_CLR, FB
 000                                      CONSTANT ANSI_HIDDEN_CLR, F7
 000                                      CONSTANT ANSI_SSG2_CLR, EF
 000                                      CONSTANT ANSI_DEBUG_CLR, DF
 000                                      CONSTANT ANSI_VT_GRAPHICS_CLR, BF
 000                                      CONSTANT ANSI_SSG3_CLR, 7F
 000                                      ; a few special characters
 000                                      CONSTANT ENQ_CHAR, 05
 000                                      CONSTANT ACK_CHAR, 06
 000                                      CONSTANT BEL_CHAR, 07
 000                                      CONSTANT TAB_CHAR, 09
 000                                      CONSTANT VT_CHAR, 0B                            ; vertical tab
 000                                      CONSTANT FORM_FEED_CHAR, 0C
 000                                      CONSTANT ESC_CHAR, 1B
 000                                      CONSTANT RUBOUT_CHAR, 7F
 000                                      CONSTANT META_CHAR, 9E                          ; special char used for in-band signalling from the keyboard
 000                                      ;
 000                                      ; the meta char precedes one of these which indicates which modifiers were used with the scroll_lock key.
 000                                      ; if the meta key occurs twice in a row it's treated as a single literal 0x9E (control-alt-^) and forwarded to the host.
 000                                      ;
 000                                      CONSTANT META_PLAIN, 73                         ; lower case s - meta key (scroll lock) with no modifiers
 000                                      CONSTANT META_SHIFT, 53                         ; upper case S - meta key with shift modifier
 000                                      CONSTANT META_CONTROL, 13                       ; control-s - meta key with control modifier
 000                                      CONSTANT META_ALT, F3                           ; lower case s with high bit set
 000                                      CONSTANT META_CONTROL_ALT, 93                   ; control-s with high bit set
 000                                      CONSTANT META_SHIFT_ALT, D3                     ; upper case S with high bit set
 000                                      CONSTANT META_CONTROL_SHIFT, 24                 ; dollar sign
 000                                      CONSTANT META_CONTROL_ALT_SHIFT, A4             ; dollar sign with high bit set
 000                                      ; registers s0 and s1 are used for local scratch.
 000                                      ; registers s4 and s5 are used for parameters
 000                                      ;
 000                                      ; registers sE is used as the column position (remainder)
 000                                      ; registers sE and sF are used for copies.
 000                                      ;
 000                                      NAMEREG s2, DIVIDEND_LOW
 000                                      NAMEREG s3, DIVIDEND_HIGH
 000                                      NAMEREG s6, COLOR_REG
 000                                      NAMEREG s7, MAX_LINE
 000                                      NAMEREG s8, DIVISOR_LOW
 000                                      NAMEREG s9, DIVISOR_HIGH
 000                                      NAMEREG sA, CURSOR_HIGH
 000                                      NAMEREG sB, CURSOR_LOW
 000                                      NAMEREG sC, ANSI_FLAG_REG
 000                                      NAMEREG sD, CHAR_PER_LINE
 000                                      ;------------------------------------------------------------------------------------------
 000                                      ; Main Program
 000                                      ;------------------------------------------------------------------------------------------
 000                          cold_start: 
 000  20002                               CALL 002[init_terminal]
 001  22042                               JUMP 042[echo_loop]
 002                       init_terminal: 
 002  01D78                               LOAD sD[CHAR_PER_LINE], 78                      ; we default to 120 columns
 003  01743                               LOAD s7[MAX_LINE], 43
 004  01000                               LOAD s0, 00
 005  2F02F                               STORE s0, 2F[video_mode]                        ; set video mode to 120x67 with underline cursor
 006  2D00B                               OUTPUT s0, 0B[MODE_PORT]
 007                           init_mode: 
 007  01000                               LOAD s0, 00
 008  2F032                               STORE s0, 32[saved_cursor_low]                  ; clear the saved (alternate) cursor position
 009  2F033                               STORE s0, 33[saved_cursor_high]
 00A  2F01E                               STORE s0, 1E[offset_low]                        ; clear the scrolling offset
 00B  2F01F                               STORE s0, 1F[offset_high]
 00C  2D00F                               OUTPUT s0, 0F[OFFSET_LSB_PORT]                  ; set the hardware scrolling registers to zero
 00D  2D00E                               OUTPUT s0, 0E[OFFSET_MSB_PORT]
 00E  2F031                               STORE s0, 31[last_char]                         ; set last character to NULL
 00F  2F030                               STORE s0, 30[mode_flags]                        ; clear assorted mode bits
 010  20632                               CALL 632[reset_UART_macros]                     ; Reset buffers in UART macros
 011  01C00                               LOAD sC[ANSI_FLAG_REG], 00                      ; set ANSI parsing flags
 012  2FC35                               STORE sC[ANSI_FLAG_REG], 35[saved_ansi_reg]
 013  01670                               LOAD s6[COLOR_REG], 70                          ; standard intensity white on black  (change to F0 for high intensity)
 014  2F634                               STORE s6[COLOR_REG], 34[saved_color_reg]
 015  20038                               CALL 038[set_maximums]
 016                           soft_boot: 
 016  204BB                               CALL 4BB[form_feed]                             ; clear the screen
 017  01805                               LOAD s8[DIVISOR_LOW], 05[hello_msg'upper]
 018  019A8                               LOAD s9[DIVISOR_HIGH], A8[hello_msg'lower]
 019  20568                               CALL 568[print_string]                          ; print our Hello message
 01A  0B22F                               FETCH s2[DIVIDEND_LOW], 2F[video_mode]
 01B  01300                               LOAD s3[DIVIDEND_HIGH], 00
 01C  20603                               CALL 603[print_integer]
 01D  01520                               LOAD s5, 20[" "]
 01E  200B8                               CALL 0B8[send_next]
 01F  01528                               LOAD s5, 28["("]
 020  200B8                               CALL 0B8[send_next]
 021  002D0                               LOAD s2[DIVIDEND_LOW], sD[CHAR_PER_LINE]
 022  01300                               LOAD s3[DIVIDEND_HIGH], 00
 023  20603                               CALL 603[print_integer]
 024  01578                               LOAD s5, 78["x"]
 025  200B8                               CALL 0B8[send_next]
 026  00270                               LOAD s2[DIVIDEND_LOW], s7[MAX_LINE]
 027  01300                               LOAD s3[DIVIDEND_HIGH], 00
 028  20603                               CALL 603[print_integer]
 029  01529                               LOAD s5, 29[")"]
 02A  200B8                               CALL 0B8[send_next]
 02B  01520                               LOAD s5, 20                                     ; fill with spaces
 02C  01010                               LOAD s0, 10                                     ; display 15 mini color bars
 02D                          color_loop: 
 02D  2F03B                               STORE s0, 3B[scratchV]
 02E  200B8                               CALL 0B8[send_next]
 02F  200B8                               CALL 0B8[send_next]
 030  11601                               ADD s6[COLOR_REG], 01
 031  0B03B                               FETCH s0, 3B[scratchV]
 032  19001                               SUB s0, 01
 033  1D000                               COMPARE s0, 00
 034  3602D                               JUMP NZ, 02D[color_loop]
 035  01670                               LOAD s6[COLOR_REG], 70                          ; restore the default colors
 036  204E4                               CALL 4E4[CRLF]                                  ; carriage_return
 037  25000                               RETURN 
 038                        set_maximums: 
 038  008D0                               LOAD s8[DIVISOR_LOW], sD[CHAR_PER_LINE]
 039  00970                               LOAD s9[DIVISOR_HIGH], s7[MAX_LINE]
 03A  205E5                               CALL 5E5[mult_8x8]
 03B  2F420                               STORE s4, 20[MAX_LINE_LOWER]
 03C  2F321                               STORE s3[DIVIDEND_HIGH], 21[MAX_LINE_UPPER]
 03D  184D0                               SUB s4, sD[CHAR_PER_LINE]
 03E  1B300                               SUBCY s3[DIVIDEND_HIGH], 00
 03F  2F422                               STORE s4, 22[LAST_LINE_LOWER]
 040  2F323                               STORE s3[DIVIDEND_HIGH], 23[LAST_LINE_UPPER]
 041  25000                               RETURN 
 042                                      ; OK, we've initialized things and sent our welcome message to the screen. Now we process characters from the
 042                                      ; UART and PS/2 ports in an endless loop.
 042                                      ;
 042                                      ; The CURSOR_LOW and CURSOR_HIGH registers hold the cursor address (linear).
 042                                      ; The COLOR_REG register holds the current color attributes (MSB 16 foreground, LSB 16 background)
 042                                      ; The ANSI flags register stores state information
 042                                      ;
 042                                      ;
 042                           echo_loop: 
 042  0B02F                               FETCH s0, 2F[video_mode]
 043  0D010                               TEST s0, 10[CURSOR_HIDDEN]
 044  340B3                               CALL NZ, 0B3[hide_cursor]
 045  20060                               CALL 060[KEYBOARD_CHECK]
 046  2004A                               CALL 04A[UART_FIFO_RX]                          ; use the new FIFO instead of the built in FIFO
 047  32042                               JUMP Z, 042[echo_loop]
 048  200B8                               CALL 0B8[send_next]
 049                                      ; LOAD s4,s5   ; uncomment these for debugging if you want a hex output of each code. note that it can't possibly keep up
 049                                      ; CALL hex_byte  ; with a full speed data feed since it's sending 3 bytes for every one received.
 049                                      ; LOAD s5," "
 049                                      ; CALL UART_TX
 049  22042                               JUMP 042[echo_loop]
 04A                        UART_FIFO_RX: ; read a character from the primary FIFO. Set Z flag if present
 04A  011A7                               LOAD s1, A7                                     ;Timeout = 167 x (6 instructions x 2 clock cycles)
 04B                        UART_TIMEOUT: 
 04B  0900C                               INPUT s0, 0C[UART_STATUS_PORT]
 04C  0D001                               TEST s0, 01[FIFO_EMPTY]                         ;Z=0 and C=1 when data present
 04D  32051                               JUMP Z, 051[read_fifo_Rx]
 04E  19101                               SUB s1, 01
 04F  31000                               RETURN Z                                        ;Timeout returns with Z=1 and C=0
 050  2204B                               JUMP 04B[UART_TIMEOUT]
 051  0950D                 read_fifo_Rx: INPUT s5, 0D[UART_READ_FIFO_PORT]               ;read character from buffer
 052  01000                               LOAD s0, 00
 053  11001                               ADD s0, 01                                      ; force clear the zero flag to indicate that we have a character in s5.
 054  25000                               RETURN 
 055                    KEYBOARD_FIFO_RX: ; read a character from the keyboard FIFO. Set Z flag if present
 055  011A7                               LOAD s1, A7
 056                    KEYBOARD_TIMEOUT: 
 056  09041                               INPUT s0, 41[KEYBOARD_STATUS_PORT]
 057  0D001                               TEST s0, 01[FIFO_EMPTY]
 058  3205C                               JUMP Z, 05C[keyboard_rx]
 059  19101                               SUB s1, 01
 05A  31000                               RETURN Z
 05B  22056                               JUMP 056[KEYBOARD_TIMEOUT]
 05C                         keyboard_rx: 
 05C  09540                               INPUT s5, 40[KEYBOARD_FIFO_PORT]
 05D  01000                               LOAD s0, 00                                     ; force clear the Z flag
 05E  11001                               ADD s0, 01
 05F  25000                               RETURN 
 060                                      ;
 060                                      ; PS2CHECK reads a byte from the PS/2 keyboard processor port. If it's a special
 060                                      ; key it sets the appropriate flags, otherwise it sends it to the host.
 060                                      ;
 060                      KEYBOARD_CHECK: 
 060  20055                               CALL 055[KEYBOARD_FIFO_RX]
 061  31000                               RETURN Z
 062  0B030                               FETCH s0, 30[mode_flags]
 063  0D040                               TEST s0, 40[MODE_META]
 064  3606A                               JUMP NZ, 06A[meta_command]                      ; META is set so this is a command
 065  1D59E                               COMPARE s5, 9E[META_CHAR]
 066  360A6                               JUMP NZ, 0A6[KEYBOARD_TX]                       ; normal char
 067  05040                               OR s0, 40[MODE_META]                            ; meta char- set the flag and store it
 068  2F030                               STORE s0, 30[mode_flags]
 069  25000                               RETURN 
 06A                        meta_command: 
 06A  030BF                               AND s0, BF[MODE_META_CLR]                       ; clear the flag and store it
 06B  2F030                               STORE s0, 30[mode_flags]
 06C  1D59E                               COMPARE s5, 9E[META_CHAR]                       ; if it's a second META_CHAR we just forward it to the host
 06D  320A6                               JUMP Z, 0A6[KEYBOARD_TX]
 06E  1D5A4                               COMPARE s5, A4[META_CONTROL_ALT_SHIFT]
 06F  32002                               JUMP Z, 002[init_terminal]                      ; control-alt-shift-scroll_lock resets the terminal
 070  1D5F3                               COMPARE s5, F3[META_ALT]
 071  3207B                               JUMP Z, 07B[mode_next]                          ; alt-scroll_lock changes the video mode
 072  1D553                               COMPARE s5, 53[META_SHIFT]
 073  36077                               JUMP NZ, 077[meta_next]
 074  07080                               XOR s0, 80[MODE_LOCAL]
 075  2F030                               STORE s0, 30[mode_flags]
 076  25000                               RETURN 
 077  1D513                    meta_next: COMPARE s5, 13[META_CONTROL]
 078  35000                               RETURN NZ
 079  07C20                               XOR sC[ANSI_FLAG_REG], 20[ANSI_DEBUG]
 07A  25000                               RETURN 
 07B                           mode_next: ; increment the video mode
 07B  0B02F                               FETCH s0, 2F[video_mode]
 07C  11001                               ADD s0, 01
 07D  03007                               AND s0, 07                                      ; clear the high bits (resets MODE_BLOCK)
 07E                           vmode_set: 
 07E  2F02F                               STORE s0, 2F[video_mode]
 07F  2D00B                               OUTPUT s0, 0B[MODE_PORT]
 080                             video_0: ; 120x67
 080  1D000                               COMPARE s0, 00
 081  36085                               JUMP NZ, 085[video_1]
 082  01743                               LOAD s7[MAX_LINE], 43
 083  01D78                               LOAD sD[CHAR_PER_LINE], 78
 084  22007                               JUMP 007[init_mode]
 085                             video_1: ; 120x33 (just tall)
 085  1D001                               COMPARE s0, 01
 086  3608A                               JUMP NZ, 08A[video_2]
 087  01721                               LOAD s7[MAX_LINE], 21
 088  01D78                               LOAD sD[CHAR_PER_LINE], 78
 089  22007                               JUMP 007[init_mode]
 08A                             video_2: ; 80x67 (just eighty)
 08A  1D002                               COMPARE s0, 02
 08B  3608F                               JUMP NZ, 08F[video_3]
 08C  01743                               LOAD s7[MAX_LINE], 43
 08D  01D50                               LOAD sD[CHAR_PER_LINE], 50
 08E  22007                               JUMP 007[init_mode]
 08F                             video_3: ; 80x33 (tall & eighty)
 08F  1D003                               COMPARE s0, 03
 090  36094                               JUMP NZ, 094[video_4]
 091  01721                               LOAD s7[MAX_LINE], 21
 092  01D50                               LOAD sD[CHAR_PER_LINE], 50
 093  22007                               JUMP 007[init_mode]
 094                             video_4: ; 120x50 (just fifty)
 094  1D004                               COMPARE s0, 04
 095  36099                               JUMP NZ, 099[video_5]
 096  01732                               LOAD s7[MAX_LINE], 32
 097  01D78                               LOAD sD[CHAR_PER_LINE], 78
 098  22007                               JUMP 007[init_mode]
 099                             video_5: ; 120x25 (tall & fifty)
 099  1D005                               COMPARE s0, 05
 09A  3609E                               JUMP NZ, 09E[video_6]
 09B  01719                               LOAD s7[MAX_LINE], 19
 09C  01D78                               LOAD sD[CHAR_PER_LINE], 78
 09D  22007                               JUMP 007[init_mode]
 09E                             video_6: ; 80x50 (eighty & fifty)
 09E  1D006                               COMPARE s0, 06
 09F  360A3                               JUMP NZ, 0A3[video_7]
 0A0  01732                               LOAD s7[MAX_LINE], 32
 0A1  01D50                               LOAD sD[CHAR_PER_LINE], 50
 0A2  22007                               JUMP 007[init_mode]
 0A3                             video_7: ; 80x25 (tall & eighty & fifty)
 0A3  01719                               LOAD s7[MAX_LINE], 19
 0A4  01D50                               LOAD sD[CHAR_PER_LINE], 50
 0A5  22007                               JUMP 007[init_mode]
 0A6                         KEYBOARD_TX: ; send a char from the keyboard
 0A6  20635                               CALL 635[UART_TX]
 0A7  0B030                               FETCH s0, 30[mode_flags]
 0A8  0D080                               TEST s0, 80[MODE_LOCAL]                         ; local echo flag
 0A9  360B8                               JUMP NZ, 0B8[send_next]
 0AA  25000                               RETURN 
 0AB                                      ; set_cursor
 0AB                                      ; sets the cursor address for the HDMI character display to sAsB
 0AB                                      ; returns without affecting any registers
 0AB                                      ;
 0AB                                      ; note that you need a NOP or some other instruction after setting the address (the RETURN is sufficient)
 0AB                                      ; before you read or write the memory.
 0AB                                      ;
 0AB                    decrement_cursor: 
 0AB  19B01                               SUB sB[CURSOR_LOW], 01
 0AC  1BA00                               SUBCY sA[CURSOR_HIGH], 00
 0AD  25000                               RETURN 
 0AE                      advance_cursor: 
 0AE  11B01                               ADD sB[CURSOR_LOW], 01
 0AF  13A00                               ADDCY sA[CURSOR_HIGH], 00
 0B0                          set_cursor: 
 0B0  2DA02                               OUTPUT sA[CURSOR_HIGH], 02[MSB_PORT]            ; set MSB of address
 0B1  2DB03                               OUTPUT sB[CURSOR_LOW], 03[LSB_PORT]             ; set LSB of address
 0B2  25000                               RETURN 
 0B3                         hide_cursor: 
 0B3  0B020                               FETCH s0, 20[MAX_LINE_LOWER]
 0B4  2D003                               OUTPUT s0, 03[LSB_PORT]
 0B5  0B021                               FETCH s0, 21[MAX_LINE_UPPER]
 0B6  2D002                               OUTPUT s0, 02[MSB_PORT]
 0B7  25000                               RETURN 
 0B8                                      ;
 0B8                                      ; send_next
 0B8                                      ; writes a character in s5 to the HDMI terminal. It processes control sequences and
 0B8                                      ; handles scrolling when appropriate.
 0B8                                      ;
 0B8                           send_next: 
 0B8  200B0                               CALL 0B0[set_cursor]
 0B9  1D51B                               COMPARE s5, 1B                                  ; is it an escape?
 0BA  320BE                               JUMP Z, 0BE[not_stored]
 0BB  0DC03                               TEST sC[ANSI_FLAG_REG], 03[ANSI_ESC_CSI]
 0BC  360BE                               JUMP NZ, 0BE[not_stored]                        ; we don't store the character if it's part of a command sequence
 0BD  2F531                               STORE s5, 31[last_char]
 0BE                          not_stored: 
 0BE  0DC90                               TEST sC[ANSI_FLAG_REG], 90[ANSI_SSG]
 0BF  360DC                               JUMP NZ, 0DC[raw_char_out]                      ; is SS2 in effect? print it raw
 0C0  1D500                               COMPARE s5, 00                                  ; if it's a NULL we do nothing, unless we're in SSG2 then we've already printed it.
 0C1  31000                               RETURN Z
 0C2  0DC01                               TEST sC[ANSI_FLAG_REG], 01[ANSI_CSI]            ; we're in the middle of a CSI sequence
 0C3  36154                               JUMP NZ, 154[parse_csi_digit]
 0C4  0DC02                               TEST sC[ANSI_FLAG_REG], 02[ANSI_ESCAPE]         ; we're in the middle of an ESC sequence
 0C5  360FB                               JUMP NZ, 0FB[escape_sequence]
 0C6  0DC20                               TEST sC[ANSI_FLAG_REG], 20[ANSI_DEBUG]          ; if we're in debug mode we send the character in RAW mode
 0C7  360DC                               JUMP NZ, 0DC[raw_char_out]
 0C8                   control_character: 
 0C8  1D51B                               COMPARE s5, 1B[ESC_CHAR]                        ; ESCAPE sequence begins
 0C9  320F9                               JUMP Z, 0F9[escape_received]
 0CA  1D508                               COMPARE s5, 08[BS]                              ; control-h is backspace
 0CB  3246A                               JUMP Z, 46A[backspace]                          ; non-destructive backspace
 0CC  1D57F                               COMPARE s5, 7F[RUBOUT_CHAR]
 0CD  32472                               JUMP Z, 472[rubout]                             ; destructive backspace ctrl-?
 0CE  1D509                               COMPARE s5, 09[TAB_CHAR]
 0CF  32476                               JUMP Z, 476[htab]                               ; non-destructive TAB ctrl-i
 0D0  1D50D                               COMPARE s5, 0D[CR]                              ; carriage return 0x0D ctrl-m
 0D1  324E6                               JUMP Z, 4E6[carriage_return]
 0D2  1D50A                               COMPARE s5, 0A[LF]                              ; line feed 0x0A ctrl-j
 0D3  324A3                               JUMP Z, 4A3[line_feed]
 0D4  1D50B                               COMPARE s5, 0B[VT_CHAR]                         ; vertical tab does a line feed ctrl-k
 0D5  324A3                               JUMP Z, 4A3[line_feed]
 0D6  1D50C                               COMPARE s5, 0C[FORM_FEED_CHAR]                  ; FORM FEED  0x0C ctrl-L
 0D7  324BB                               JUMP Z, 4BB[form_feed]
 0D8  1D505                               COMPARE s5, 05[ENQ_CHAR]                        ; ctrl-E
 0D9  32467                               JUMP Z, 467[enquiry]
 0DA  1D507                               COMPARE s5, 07[BEL_CHAR]                        ; ctrl-G
 0DB  32538                               JUMP Z, 538[ring_bell]
 0DC                                      ; COMPARE s5, 01   ; ctrl-a
 0DC                                      ; JUMP Z, test_pattern  ; this is for debugging only ****
 0DC                        raw_char_out: ; if you don't want to process any control or escape codes
 0DC  2F03D                               STORE s0, 3D[scratchX]
 0DD  0DC08                               TEST sC[ANSI_FLAG_REG], 08[ANSI_HIDDEN]
 0DE  320E0                               JUMP Z, 0E0[raw_vt_graphics]
 0DF  01520                               LOAD s5, 20                                     ; if we're hidden we only print spaces
 0E0                     raw_vt_graphics: 
 0E0  0DC40                               TEST sC[ANSI_FLAG_REG], 40[ANSI_VT_GRAPHICS]
 0E1  320ED                               JUMP Z, 0ED[raw_output]
 0E2                                      ;
 0E2                                      ; if we're using the "standard" codepage 1252 font with VT100 characters in the ANSI "C0" control character range (0-31)
 0E2                                      ; these we use the following code
 0E2                                      ;
 0E2                   check_lower_alpha: ; if we're not in the lower case alpha range 0x60-0x7E then we just print it raw
 0E2  1D57F                               COMPARE s5, 7F                                  ; lower case 'z' plus one
 0E3  3E0ED                               JUMP NC, 0ED[raw_output]                        ; we're above z
 0E4  1D55F                               COMPARE s5, 5F                                  ; lower case 'a' minus one
 0E5  3A0ED                               JUMP C, 0ED[raw_output]
 0E6  320ED                               JUMP Z, 0ED[raw_output]                         ; we're below or equal to 'a' minus one
 0E7                          VT_graphic: ; we're a VT100 graphics character
 0E7  1D560                               COMPARE s5, 60
 0E8  360EB                               JUMP NZ, 0EB[VT_shift]
 0E9  0151F                               LOAD s5, 1F                                     ; accent grave is a special case- we use 0x1F instead of 0x00
 0EA  220ED                               JUMP 0ED[raw_output]
 0EB                            VT_shift: ; shift the characters down to the 0-31 control character range.
 0EB  19560                               SUB s5, 60
 0EC  220ED                               JUMP 0ED[raw_output]
 0ED                          raw_output: 
 0ED  03CEF                               AND sC[ANSI_FLAG_REG], EF[ANSI_SSG2_CLR]        ; we clear it even if it's not already set. it's cheaper than testing it.
 0EE  0B030                               FETCH s0, 30[mode_flags]
 0EF  2D051                               OUTPUT s0, 51[EXTRA_PORT]
 0F0  2D504                               OUTPUT s5, 04[CHAR_PORT]
 0F1  2D609                               OUTPUT s6[COLOR_REG], 09[ATTR_PORT]
 0F2  200AE                               CALL 0AE[advance_cursor]
 0F3  2054E                               CALL 54E[compare_cursor_max]                    ; are we past the end of the screen?
 0F4  35000                               RETURN NZ                                       ; no, we return
 0F5  200AB                               CALL 0AB[decrement_cursor]
 0F6  200B0                               CALL 0B0[set_cursor]
 0F7  204CF                               CALL 4CF[home_cursor]                           ; move
 0F8  224F0                               JUMP 4F0[scroll_up]
 0F9                                      ; these are the ANSI/ASCII functions.
 0F9                                      ; This is where we process control characters like backspace, cursor movement, carriage return, etc.
 0F9                                      ;
 0F9                     escape_received: ; we're not escaped and we just got an escape character
 0F9  05C02                               OR sC[ANSI_FLAG_REG], 02[ANSI_ESCAPE]
 0FA  25000                               RETURN 
 0FB                     escape_sequence: ; we're currently escaped and we just got another character
 0FB  1D55B                               COMPARE s5, 5B["["]
 0FC  36100                               JUMP NZ, 100[not_csi]
 0FD  05C01                               OR sC[ANSI_FLAG_REG], 01[ANSI_CSI]
 0FE  20149                               CALL 149[parse_csi_init]
 0FF  25000                               RETURN 
 100                             not_csi: 
 100                         save_cursor: 
 100  1D537                               COMPARE s5, 37["7"]
 101  36107                               JUMP NZ, 107[restore_cursor]
 102  2FB32                               STORE sB[CURSOR_LOW], 32[saved_cursor_low]
 103  2FA33                               STORE sA[CURSOR_HIGH], 33[saved_cursor_high]
 104  2F634                               STORE s6[COLOR_REG], 34[saved_color_reg]
 105  2FC35                               STORE sC[ANSI_FLAG_REG], 35[saved_ansi_reg]
 106  22147                               JUMP 147[end_csi]
 107                      restore_cursor: 
 107  1D538                               COMPARE s5, 38["8"]
 108  3610F                               JUMP NZ, 10F[RSI]
 109  0BB32                               FETCH sB[CURSOR_LOW], 32[saved_cursor_low]
 10A  0BA33                               FETCH sA[CURSOR_HIGH], 33[saved_cursor_high]
 10B  0B634                               FETCH s6[COLOR_REG], 34[saved_color_reg]
 10C  0BC35                               FETCH sC[ANSI_FLAG_REG], 35[saved_ansi_reg]
 10D  200B0                               CALL 0B0[set_cursor]
 10E  22147                               JUMP 147[end_csi]
 10F                                 RSI: ; reset the terminal
 10F  0B030                               FETCH s0, 30[mode_flags]
 110  0D020                               TEST s0, 20[MODE_SET_FONT]
 111  36122                               JUMP NZ, 122[set_VT100]
 112  1D563                               COMPARE s5, 63["c"]
 113  36115                               JUMP NZ, 115[SSG2]
 114  22002                               JUMP 002[init_terminal]                         ; we re-initialize everything but we don't blow our stack. parasitic return
 115                                SSG2: ; ESC-N without a CSI bracket is "single shift graphics 2". the next character received is treated literally.
 115  1D54E                               COMPARE s5, 4E["N"]
 116  36119                               JUMP NZ, 119[clear_alternate_keypad]
 117  05C10                               OR sC[ANSI_FLAG_REG], 10[ANSI_SSG2]
 118  22147                               JUMP 147[end_csi]
 119              clear_alternate_keypad: ; clear alternate keypad mode, which we ignore.
 119  1D53E                               COMPARE s5, 3E[">"]
 11A  3611C                               JUMP NZ, 11C[set_font]
 11B  22147                               JUMP 147[end_csi]
 11C                            set_font: 
 11C  1D528                               COMPARE s5, 28["("]
 11D  36122                               JUMP NZ, 122[set_VT100]
 11E  0B030                               FETCH s0, 30[mode_flags]
 11F  05020                               OR s0, 20[MODE_SET_FONT]
 120  2F030                               STORE s0, 30[mode_flags]
 121  25000                               RETURN                                          ; we do not clear the ESC here because we're expecting an additional character
 122                           set_VT100: 
 122  0B030                               FETCH s0, 30[mode_flags]
 123  0D020                               TEST s0, 20[MODE_SET_FONT]
 124  32147                               JUMP Z, 147[unknown_escape]
 125  030DF                               AND s0, DF[MODE_SET_FONT_CLR]
 126  2F030                               STORE s0, 30[mode_flags]
 127  1D530                               COMPARE s5, 30["0"]
 128  3612D                               JUMP NZ, 12D[clear_VT100]
 129  05C40                               OR sC[ANSI_FLAG_REG], 40[ANSI_VT_GRAPHICS]
 12A  030FE                               AND s0, FE[MODE_ALTERNATE_FONT_CLR]
 12B  2F030                               STORE s0, 30[mode_flags]
 12C  22147                               JUMP 147[end_csi]
 12D                         clear_VT100: 
 12D                                      ; AND s0, MODE_SET_FONT_CLR
 12D                                      ; STORE s0, mode_flags
 12D  1D542                               COMPARE s5, 42["B"]
 12E  36133                               JUMP NZ, 133[set_alternate_font]
 12F  030FE                               AND s0, FE[MODE_ALTERNATE_FONT_CLR]
 130  2F030                               STORE s0, 30[mode_flags]
 131  03CBF                               AND sC[ANSI_FLAG_REG], BF[ANSI_VT_GRAPHICS_CLR]
 132  22147                               JUMP 147[end_csi]
 133                  set_alternate_font: 
 133                                      ; AND s0, MODE_SET_FONT_CLR
 133                                      ; STORE s0, mode_flags
 133  1D531                               COMPARE s5, 31["1"]
 134  36139                               JUMP NZ, 139[set_alternate_graphics]
 135  05001                               OR s0, 01[MODE_ALTERNATE_FONT]
 136  2F030                               STORE s0, 30[mode_flags]
 137  03CBF                               AND sC[ANSI_FLAG_REG], BF[ANSI_VT_GRAPHICS_CLR]
 138  22147                               JUMP 147[end_csi]
 139              set_alternate_graphics: 
 139                                      ; AND s0, MODE_SET_FONT_CLR
 139                                      ; STORE s0, mode_flags
 139  1D532                               COMPARE s5, 32["2"]
 13A  3613F                               JUMP NZ, 13F[set_video_mode]
 13B  05001                               OR s0, 01[MODE_ALTERNATE_FONT]
 13C  2F030                               STORE s0, 30[mode_flags]
 13D  05C40                               OR sC[ANSI_FLAG_REG], 40[ANSI_VT_GRAPHICS]
 13E  22147                               JUMP 147[end_csi]
 13F                      set_video_mode: 
 13F  1D569                               COMPARE s5, 69                                  ; are we less than "h" ?
 140  3E147                               JUMP NC, 147[end_csi]
 141  01460                               LOAD s4, 60
 142  1C450                               COMPARE s4, s5
 143  3E147                               JUMP NC, 147[end_csi]                           ; are we greater than or equal to "a"?
 144  19561                               SUB s5, 61                                      ; normalize, "a"=0
 145  00050                               LOAD s0, s5
 146  2207E                               JUMP 07E[vmode_set]
 147                      unknown_escape: 
 147                                      ; LOAD s4,s5
 147                                      ; CALL debug_s4e ; comment this line out unless debugging ****
 147                             end_csi: 
 147  03CFD                               AND sC[ANSI_FLAG_REG], FD[ANSI_ESCAPE_CLR]      ; OK, we got an escape but the following key was meaningless so we cancel the escape
 148  25000                               RETURN 
 149                                      ;
 149                                      ; Parse CSI parameters
 149                                      ;
 149                                      ;
 149                                      ;
 149                                      ; So we store two things in RAM here. The list of parameters (each can be 0-255) is stored starting at RAM08 (param_block).
 149                                      ; There is room for a maximum of eight parameters in RAM.
 149                                      ; The value stored at RAM07 is the parameter count which tells us how many valid parameters there are stored. It can be zero.
 149                                      ;
 149                                      ; As we're processing decimal digits while parsing parameters we store them at RAM12 (digit_block) through RAM15. We can
 149                                      ; store a maximum of four digits but only if the first digit is a leading zero. In most cases if the value is greater than 255
 149                                      ; things will not work correctly.
 149                                      ;
 149                                      ; The number of decimal digits (so far) in the current parameter is stored in RAM11 (digit_counter).
 149                      parse_csi_init: ; we've just received the CSI intro sequence ESC-[
 149  01000                               LOAD s0, 00
 14A  2F007                               STORE s0, 07[param_counter]
 14B  2F011                               STORE s0, 11[digit_counter]
 14C  25000                               RETURN 
 14D  01008                  start_clear: LOAD s0, 08[param_block]
 14E  01100                               LOAD s1, 00
 14F  2E100                 clear_params: STORE s1, (s0)
 150  11001                               ADD s0, 01
 151  1D010                               COMPARE s0, 10[max_param]
 152  3614F                               JUMP NZ, 14F[clear_params]
 153  25000                               RETURN 
 154                     parse_csi_digit: ; we've received something after the CSI and it's in s5
 154  1D53A                               COMPARE s5, 3A                                  ; digit '9' plus one
 155  3E160                               JUMP NC, 160[not_a_digit]                       ; we're above 9
 156  1D52F                               COMPARE s5, 2F                                  ; digit '0' minus one
 157  3A160                               JUMP C, 160[not_a_digit]
 158  32160                               JUMP Z, 160[not_a_digit]                        ; we're below or equal to '0' minus one
 159                                      ; OK, we're a decimal digit
 159                       process_digit: 
 159  01012                               LOAD s0, 12[digit_block]
 15A  0B111                               FETCH s1, 11[digit_counter]
 15B  10010                               ADD s0, s1                                      ; calculate the storage address
 15C  2E500                               STORE s5, (s0)
 15D  11101                               ADD s1, 01                                      ; increment the number of digits
 15E                                      ; COMPARE s1, max_param
 15E                                      ; JUMP Z, exit_escape  ; return without storing the incremented value if we're at the limit ****
 15E                                      ; we should probably abort the whole escape sequence at this point too, but either way we've lost sync with the host application
 15E  2F111                               STORE s1, 11[digit_counter]
 15F  25000                               RETURN 
 160                         not_a_digit: 
 160  2043F                               CALL 43F[end_param]                             ; finish up any parameter we've started
 161                     check_semicolon: 
 161  1D53B                               COMPARE s5, 3B[";"]
 162  36164                               JUMP NZ, 164[check_question_mark]
 163  25000                               RETURN 
 164                 check_question_mark: 
 164  1D53F                               COMPARE s5, 3F["?"]
 165  36167                               JUMP NZ, 167[csi_scroll_up]
 166  25000                               RETURN 
 167                       csi_scroll_up: 
 167  1D553                               COMPARE s5, 53["S"]
 168  36174                               JUMP NZ, 174[csi_scroll_down]
 169  0B008                               FETCH s0, 08[param_block]
 16A  1D000                               COMPARE s0, 00
 16B  3616D                               JUMP NZ, 16D[scroll_up_loop]
 16C  11001                               ADD s0, 01
 16D                      scroll_up_loop: 
 16D  2F037                               STORE s0, 37[scratchR]
 16E  204F0                               CALL 4F0[scroll_up]
 16F  0B037                               FETCH s0, 37[scratchR]
 170  19001                               SUB s0, 01
 171  1D000                               COMPARE s0, 00
 172  3616D                               JUMP NZ, 16D[scroll_up_loop]
 173  2243C                               JUMP 43C[exit_escape]
 174                     csi_scroll_down: 
 174  1D554                               COMPARE s5, 54["T"]
 175  3617F                               JUMP NZ, 17F[csi_set_mode]
 176  0B008                               FETCH s0, 08[param_block]
 177  1D000                               COMPARE s0, 00
 178  3617A                               JUMP NZ, 17A[scroll_down_loop]
 179  11001                               ADD s0, 01
 17A                    scroll_down_loop: 
 17A  2050C                               CALL 50C[scroll_down]
 17B  19001                               SUB s0, 01
 17C  1D000                               COMPARE s0, 00
 17D  3617A                               JUMP NZ, 17A[scroll_down_loop]
 17E  2243C                               JUMP 43C[exit_escape]
 17F                        csi_set_mode: 
 17F  1D568                               COMPARE s5, 68["h"]
 180  36190                               JUMP NZ, 190[csi_reset_mode]
 181  0B009                               FETCH s0, 09[param_two]                         ; second param because of the question mark
 182  1D00C                               COMPARE s0, 0C[12'd]                            ; CSI ? 12 h is block cursor mode
 183  3218B                               JUMP Z, 18B[block_cursor]
 184  1D019                               COMPARE s0, 19[25'd]
 185  3643C                               JUMP NZ, 43C[exit_escape]
 186                      cursor_visible: 
 186  0B02F                               FETCH s0, 2F[video_mode]
 187  030EF                               AND s0, EF[CURSOR_HIDDEN_CLR]
 188  2F02F                               STORE s0, 2F[video_mode]
 189  200B0                               CALL 0B0[set_cursor]
 18A  2243C                               JUMP 43C[exit_escape]
 18B                        block_cursor: 
 18B  0B02F                               FETCH s0, 2F[video_mode]
 18C  05008                               OR s0, 08[CURSOR_BLOCK]
 18D  2F02F                               STORE s0, 2F[video_mode]
 18E  2D00B                               OUTPUT s0, 0B[MODE_PORT]
 18F  2243C                               JUMP 43C[exit_escape]
 190                      csi_reset_mode: 
 190  1D56C                               COMPARE s5, 6C["l"]
 191  361A1                               JUMP NZ, 1A1[csi_delete_line]
 192  0B009                               FETCH s0, 09[param_two]                         ; second param because of the question mark
 193  1D00C                               COMPARE s0, 0C[12'd]                            ; CSI ? 12 l is underline cursor mode
 194  3219C                               JUMP Z, 19C[underline_cursor]
 195  1D019                               COMPARE s0, 19[25'd]
 196  3643C                               JUMP NZ, 43C[exit_escape]
 197                       cursor_hidden: 
 197  0B02F                               FETCH s0, 2F[video_mode]
 198  05010                               OR s0, 10[CURSOR_HIDDEN]
 199  2F02F                               STORE s0, 2F[video_mode]
 19A  200B3                               CALL 0B3[hide_cursor]
 19B  2243C                               JUMP 43C[exit_escape]
 19C                    underline_cursor: 
 19C  0B02F                               FETCH s0, 2F[video_mode]
 19D  030F7                               AND s0, F7[CURSOR_BLOCK_CLR]
 19E  2F02F                               STORE s0, 2F[video_mode]
 19F  2D00B                               OUTPUT s0, 0B[MODE_PORT]
 1A0  2243C                               JUMP 43C[exit_escape]
 1A1                     csi_delete_line: ; delete the current line and scroll everything up
 1A1  1D54D                               COMPARE s5, 4D["M"]
 1A2  361D4                               JUMP NZ, 1D4[csi_insert_line]
 1A3  2FB00                               STORE sB[CURSOR_LOW], 00[scratchLOW]
 1A4  2FA01                               STORE sA[CURSOR_HIGH], 01[scratchHIGH]
 1A5  204CF                               CALL 4CF[home_cursor]
 1A6  20557                               CALL 557[compare_cursor_last]
 1A7  361AA                               JUMP NZ, 1AA[delete_line_0]
 1A8  204F2                               CALL 4F2[scroll_up_plain]
 1A9  2243C                               JUMP 43C[exit_escape]
 1AA                       delete_line_0: 
 1AA  0B008                               FETCH s0, 08[param_block]
 1AB  1D000                               COMPARE s0, 00                                  ; we're always deleting at least one line
 1AC  361AE                               JUMP NZ, 1AE[delete_line_1]
 1AD  11001                               ADD s0, 01
 1AE                       delete_line_1: ; if we're on the top line and we're only inserting one line we do a scroll up instead of an insert.
 1AE                       delete_line_2: 
 1AE  00800                               LOAD s8[DIVISOR_LOW], s0
 1AF  009D0                               LOAD s9[DIVISOR_HIGH], sD[CHAR_PER_LINE]
 1B0  205E5                               CALL 5E5[mult_8x8]                              ; result in s4 and DIVIDEND_HIGH
 1B1  2F43D                               STORE s4, 3D[scratchX]
 1B2  2F33E                               STORE s3[DIVIDEND_HIGH], 3E[scratchY]
 1B3  00EB0                               LOAD sE, sB[CURSOR_LOW]
 1B4  00FA0                               LOAD sF, sA[CURSOR_HIGH]
 1B5  10E40                               ADD sE, s4
 1B6  12F30                               ADDCY sF, s3[DIVIDEND_HIGH]                     ; starting address for copy
 1B7                                      ; make sure starting address for copy in sEsF is a legal address ****
 1B7  0B020                               FETCH s0, 20[MAX_LINE_LOWER]
 1B8  0B121                               FETCH s1, 21[MAX_LINE_UPPER]
 1B9  2F237                               STORE s2[DIVIDEND_LOW], 37[scratchR]
 1BA                    delete_line_loop: 
 1BA  2DE03                               OUTPUT sE, 03[LSB_PORT]                         ; move to the source
 1BB  2DF02                               OUTPUT sF, 02[MSB_PORT]
 1BC  00000                               LOAD s0, s0                                     ; NOP
 1BD  09250                               INPUT s2[DIVIDEND_LOW], 50[EXTRA_READ_PORT]
 1BE  09405                               INPUT s4, 05[CHAR_READ_PORT]                    ; read the source
 1BF  0950A                               INPUT s5, 0A[ATTR_READ_PORT]
 1C0  200B0                               CALL 0B0[set_cursor]                            ; move the to destination
 1C1  2D251                               OUTPUT s2[DIVIDEND_LOW], 51[EXTRA_PORT]
 1C2  2D404                               OUTPUT s4, 04[CHAR_PORT]                        ; write the destination
 1C3  2D509                               OUTPUT s5, 09[ATTR_PORT]
 1C4  11B01                               ADD sB[CURSOR_LOW], 01                          ; increment destination
 1C5  13A00                               ADDCY sA[CURSOR_HIGH], 00
 1C6  11E01                               ADD sE, 01                                      ; increment source
 1C7  13F00                               ADDCY sF, 00
 1C8  1CE00                               COMPARE sE, s0
 1C9  1EF10                               COMPARECY sF, s1
 1CA  361BA                               JUMP NZ, 1BA[delete_line_loop]
 1CB                end_delete_line_loop: 
 1CB  0B237                               FETCH s2[DIVIDEND_LOW], 37[scratchR]
 1CC  0BB20                               FETCH sB[CURSOR_LOW], 20[MAX_LINE_LOWER]
 1CD  0BA21                               FETCH sA[CURSOR_HIGH], 21[MAX_LINE_UPPER]
 1CE  0B43D                               FETCH s4, 3D[scratchX]
 1CF  0B33E                               FETCH s3[DIVIDEND_HIGH], 3E[scratchY]
 1D0  18B40                               SUB sB[CURSOR_LOW], s4
 1D1  1AA30                               SUBCY sA[CURSOR_HIGH], s3[DIVIDEND_HIGH]
 1D2  204FC                               CALL 4FC[clear_last_lines]                      ; this also restores our cursor position for us
 1D3  2243C                               JUMP 43C[exit_escape]
 1D4                     csi_insert_line: 
 1D4  1D54C                               COMPARE s5, 4C["L"]
 1D5  36210                               JUMP NZ, 210[csi_erase_char]
 1D6  2FB00                               STORE sB[CURSOR_LOW], 00[scratchLOW]
 1D7  2FA01                               STORE sA[CURSOR_HIGH], 01[scratchHIGH]
 1D8  204CF                               CALL 4CF[home_cursor]
 1D9  20557                               CALL 557[compare_cursor_last]                   ; if we're on the last line we just nuke it- no copying necessary
 1DA  361DD                               JUMP NZ, 1DD[insert_line_0]
 1DB  204FA                               CALL 4FA[clear_last_line]
 1DC  2243C                               JUMP 43C[exit_escape]
 1DD                       insert_line_0: 
 1DD  2FB3B                               STORE sB[CURSOR_LOW], 3B[scratchV]
 1DE  2FA3C                               STORE sA[CURSOR_HIGH], 3C[scratchW]
 1DF  0B008                               FETCH s0, 08[param_block]
 1E0  1D000                               COMPARE s0, 00
 1E1  361E3                               JUMP NZ, 1E3[insert_line_1]                     ; we insert at least one line
 1E2  11001                               ADD s0, 01
 1E3                       insert_line_1: ; if we're at the top of the screen we do a scroll_down instead of an insert
 1E3  1DB00                               COMPARE sB[CURSOR_LOW], 00
 1E4  1FA00                               COMPARECY sA[CURSOR_HIGH], 00
 1E5  361EA                               JUMP NZ, 1EA[insert_line_2]
 1E6                       insert_scroll: 
 1E6  2050E                               CALL 50E[scroll_down_offset]
 1E7  19001                               SUB s0, 01
 1E8  361E6                               JUMP NZ, 1E6[insert_scroll]
 1E9  2243C                               JUMP 43C[exit_escape]
 1EA                       insert_line_2: 
 1EA                                      ;STORE s0, param_block
 1EA  00800                               LOAD s8[DIVISOR_LOW], s0
 1EB  009D0                               LOAD s9[DIVISOR_HIGH], sD[CHAR_PER_LINE]
 1EC  205E5                               CALL 5E5[mult_8x8]
 1ED  2F43D                               STORE s4, 3D[scratchX]
 1EE  2F33E                               STORE s3[DIVIDEND_HIGH], 3E[scratchY]           ; s4/DH holds number of chars to insert
 1EF  0BE20                               FETCH sE, 20[MAX_LINE_LOWER]
 1F0  0BF21                               FETCH sF, 21[MAX_LINE_UPPER]
 1F1  19E01                               SUB sE, 01
 1F2  1BF00                               SUBCY sF, 00
 1F3  00BE0                               LOAD sB[CURSOR_LOW], sE                         ; CURSOR_LH holds last character of screen
 1F4  00AF0                               LOAD sA[CURSOR_HIGH], sF
 1F5  18B40                               SUB sB[CURSOR_LOW], s4
 1F6  1AA30                               SUBCY sA[CURSOR_HIGH], s3[DIVIDEND_HIGH]
 1F7  00530                               LOAD s5, s3[DIVIDEND_HIGH]
 1F8                                      ; make sure address is legal ****
 1F8  0B23B                               FETCH s2[DIVIDEND_LOW], 3B[scratchV]
 1F9  0B33C                               FETCH s3[DIVIDEND_HIGH], 3C[scratchW]
 1FA  10240                               ADD s2[DIVIDEND_LOW], s4
 1FB  12350                               ADDCY s3[DIVIDEND_HIGH], s5
 1FC                    insert_line_loop: 
 1FC  200B0                               CALL 0B0[set_cursor]
 1FD  09850                               INPUT s8[DIVISOR_LOW], 50[EXTRA_READ_PORT]
 1FE  09405                               INPUT s4, 05[CHAR_READ_PORT]
 1FF  0950A                               INPUT s5, 0A[ATTR_READ_PORT]
 200  2DE03                               OUTPUT sE, 03[LSB_PORT]
 201  2DF02                               OUTPUT sF, 02[MSB_PORT]
 202  00000                               LOAD s0, s0                                     ; NOP
 203  2D851                               OUTPUT s8[DIVISOR_LOW], 51[EXTRA_PORT]
 204  2D404                               OUTPUT s4, 04[CHAR_PORT]
 205  2D509                               OUTPUT s5, 09[ATTR_PORT]
 206  200AB                               CALL 0AB[decrement_cursor]
 207  19E01                               SUB sE, 01
 208  1BF00                               SUBCY sF, 00
 209  1CE20                               COMPARE sE, s2[DIVIDEND_LOW]
 20A  1EF30                               COMPARECY sF, s3[DIVIDEND_HIGH]
 20B  361FC                               JUMP NZ, 1FC[insert_line_loop]
 20C  0B03D                               FETCH s0, 3D[scratchX]
 20D  0B13E                               FETCH s1, 3E[scratchY]
 20E  20528                               CALL 528[clear_current_lines]
 20F  2243C                               JUMP 43C[exit_escape]
 210                      csi_erase_char: 
 210  1D558                               COMPARE s5, 58["X"]
 211  36224                               JUMP NZ, 224[csi_insert_char]
 212  2FB00                               STORE sB[CURSOR_LOW], 00[scratchLOW]
 213  2FA01                               STORE sA[CURSOR_HIGH], 01[scratchHIGH]
 214  0B008                               FETCH s0, 08[param_block]                       ; repeat count
 215  01500                               LOAD s5, 00
 216  1D000                               COMPARE s0, 00
 217  36219                               JUMP NZ, 219[erase_char_loop]
 218  11001                               ADD s0, 01
 219                     erase_char_loop: 
 219  2D551                               OUTPUT s5, 51[EXTRA_PORT]
 21A  2D504                               OUTPUT s5, 04[CHAR_PORT]
 21B  2D609                               OUTPUT s6[COLOR_REG], 09[ATTR_PORT]
 21C  200AE                               CALL 0AE[advance_cursor]
 21D  19001                               SUB s0, 01
 21E  1D000                               COMPARE s0, 00
 21F  36219                               JUMP NZ, 219[erase_char_loop]
 220  0BB00                               FETCH sB[CURSOR_LOW], 00[scratchLOW]
 221  0BA01                               FETCH sA[CURSOR_HIGH], 01[scratchHIGH]
 222  200B0                               CALL 0B0[set_cursor]
 223  2243C                               JUMP 43C[exit_escape]
 224                     csi_insert_char: 
 224  1D540                               COMPARE s5, 40["@"]
 225  3624B                               JUMP NZ, 24B[csi_delete_char]
 226  0B108                               FETCH s1, 08[param_block]
 227  1D100                               COMPARE s1, 00
 228  3622A                               JUMP NZ, 22A[insert_loop]
 229  11101                               ADD s1, 01
 22A                         insert_loop: 
 22A  2FB00                               STORE sB[CURSOR_LOW], 00[scratchLOW]
 22B  2FA01                               STORE sA[CURSOR_HIGH], 01[scratchHIGH]
 22C  205BF                               CALL 5BF[get_row_column_plus]
 22D  000D0                               LOAD s0, sD[CHAR_PER_LINE]
 22E  180E0                               SUB s0, sE                                      ; s0 now contains the number of characters to the end of the line
 22F  19001                               SUB s0, 01
 230  10B00                               ADD sB[CURSOR_LOW], s0
 231  13A00                               ADDCY sA[CURSOR_HIGH], 00
 232  200B0                               CALL 0B0[set_cursor]
 233  11001                               ADD s0, 01
 234                         insert_next: 
 234  09250                               INPUT s2[DIVIDEND_LOW], 50[EXTRA_READ_PORT]
 235  09405                               INPUT s4, 05[CHAR_READ_PORT]
 236  0950A                               INPUT s5, 0A[ATTR_READ_PORT]
 237  200AE                               CALL 0AE[advance_cursor]
 238  2D251                               OUTPUT s2[DIVIDEND_LOW], 51[EXTRA_PORT]
 239  2D404                               OUTPUT s4, 04[CHAR_PORT]
 23A  2D509                               OUTPUT s5, 09[ATTR_PORT]
 23B  19B02                               SUB sB[CURSOR_LOW], 02
 23C  1BA00                               SUBCY sA[CURSOR_HIGH], 00
 23D  200B0                               CALL 0B0[set_cursor]
 23E  19001                               SUB s0, 01
 23F  1D000                               COMPARE s0, 00
 240  36234                               JUMP NZ, 234[insert_next]
 241  200AE                               CALL 0AE[advance_cursor]
 242  01420                               LOAD s4, 20
 243  0B200                               FETCH s2[DIVIDEND_LOW], 00                      ;mode_flags
 244  2D251                               OUTPUT s2[DIVIDEND_LOW], 51[EXTRA_PORT]
 245  2D404                               OUTPUT s4, 04[CHAR_PORT]
 246  2D609                               OUTPUT s6[COLOR_REG], 09[ATTR_PORT]
 247  19101                               SUB s1, 01
 248  1D100                               COMPARE s1, 00
 249  3622A                               JUMP NZ, 22A[insert_loop]
 24A  2243C                               JUMP 43C[exit_escape]
 24B                                      ;FETCH CURSOR_LOW, scratchLOW
 24B                                      ;FETCH CURSOR_HIGH, scratchHIGH
 24B                                      ;CALL set_cursor
 24B                     csi_delete_char: ; delete character forward and shift line
 24B  1D550                               COMPARE s5, 50["P"]
 24C  36271                               JUMP NZ, 271[csi_clear]
 24D  0B108                               FETCH s1, 08[param_block]
 24E  1D100                               COMPARE s1, 00
 24F  36251                               JUMP NZ, 251[delete_loop]
 250  11101                               ADD s1, 01
 251                         delete_loop: 
 251  2FB00                               STORE sB[CURSOR_LOW], 00[scratchLOW]
 252  2FA01                               STORE sA[CURSOR_HIGH], 01[scratchHIGH]
 253  205BF                               CALL 5BF[get_row_column_plus]
 254  000D0                               LOAD s0, sD[CHAR_PER_LINE]
 255  180E0                               SUB s0, sE                                      ; s0 now contains the number of characters to the end of the line
 256                         delete_next: 
 256  200AE                               CALL 0AE[advance_cursor]
 257  09250                               INPUT s2[DIVIDEND_LOW], 50[EXTRA_READ_PORT]
 258  09405                               INPUT s4, 05[CHAR_READ_PORT]
 259  0950A                               INPUT s5, 0A[ATTR_READ_PORT]
 25A  200AB                               CALL 0AB[decrement_cursor]
 25B  200B0                               CALL 0B0[set_cursor]
 25C  2D251                               OUTPUT s2[DIVIDEND_LOW], 51[EXTRA_PORT]
 25D  2D404                               OUTPUT s4, 04[CHAR_PORT]
 25E  2D509                               OUTPUT s5, 09[ATTR_PORT]
 25F  11B01                               ADD sB[CURSOR_LOW], 01
 260  13A00                               ADDCY sA[CURSOR_HIGH], 00
 261  19001                               SUB s0, 01
 262  1D000                               COMPARE s0, 00
 263  36256                               JUMP NZ, 256[delete_next]
 264  200B0                               CALL 0B0[set_cursor]
 265  0B250                               FETCH s2[DIVIDEND_LOW], 50[EXTRA_READ_PORT]
 266  01420                               LOAD s4, 20
 267  2D451                               OUTPUT s4, 51[EXTRA_PORT]
 268  2D404                               OUTPUT s4, 04[CHAR_PORT]
 269  2D609                               OUTPUT s6[COLOR_REG], 09[ATTR_PORT]
 26A  0BB00                               FETCH sB[CURSOR_LOW], 00[scratchLOW]
 26B  0BA01                               FETCH sA[CURSOR_HIGH], 01[scratchHIGH]
 26C  200B0                               CALL 0B0[set_cursor]
 26D  19101                               SUB s1, 01
 26E  1D100                               COMPARE s1, 00
 26F  36251                               JUMP NZ, 251[delete_loop]
 270  2243C                               JUMP 43C[exit_escape]
 271                           csi_clear: 
 271  1D54A                               COMPARE s5, 4A["J"]
 272  3627E                               JUMP NZ, 27E[csi_sgr]
 273                                      ;CALL form_feed
 273  0B008                               FETCH s0, 08[param_block]
 274  1D002                               COMPARE s0, 02
 275  36278                               JUMP NZ, 278[partial_clear]
 276  204BB                               CALL 4BB[form_feed]
 277  2243C                               JUMP 43C[exit_escape]
 278                       partial_clear: 
 278  1D001                               COMPARE s0, 01
 279  3627C                               JUMP NZ, 27C[end_clear]
 27A  204A9                               CALL 4A9[clear_start_screen]
 27B  2243C                               JUMP 43C[exit_escape]
 27C                           end_clear: 
 27C  204BD                               CALL 4BD[clear_end_screen]
 27D  2243C                               JUMP 43C[exit_escape]
 27E                             csi_sgr: ; select graphics rendition, this is the big one
 27E  1D56D                               COMPARE s5, 6D["m"]
 27F  36322                               JUMP NZ, 322[csi_move]
 280  0B007                               FETCH s0, 07[param_counter]
 281  01108                               LOAD s1, 08[param_block]
 282  10010                               ADD s0, s1
 283                           sgr_param: 
 283  0A410                               FETCH s4, (s1)
 284                           sgr_reset: 
 284  1D400                               COMPARE s4, 00                                  ; 00 means reset all values
 285  3628D                               JUMP NZ, 28D[sgr_bold]
 286  01670                               LOAD s6[COLOR_REG], 70                          ; default of dim white foreground black background
 287  03CFB                               AND sC[ANSI_FLAG_REG], FB[ANSI_INVERSE_CLR]
 288  03CF7                               AND sC[ANSI_FLAG_REG], F7[ANSI_HIDDEN_CLR]
 289                                      ; AND ANSI_FLAG_REG, ANSI_VT_GRAPHICS_CLR ; is this right or do we require CSI 10 m instead?
 289  0B430                               FETCH s4, 30[mode_flags]
 28A  034FD                               AND s4, FD[MODE_UNDERLINE_CLR]
 28B  2F430                               STORE s4, 30[mode_flags]
 28C  2231E                               JUMP 31E[sgr_next]
 28D                            sgr_bold: ; setting the high bit of foreground color makes it "bold" by choosing brighter colors
 28D  1D401                               COMPARE s4, 01
 28E  36295                               JUMP NZ, 295[sgr_underline]
 28F  0DC04                               TEST sC[ANSI_FLAG_REG], 04[ANSI_INVERSE]
 290  3445A                               CALL NZ, 45A[invert_colors]
 291  05680                               OR s6[COLOR_REG], 80
 292  0DC04                               TEST sC[ANSI_FLAG_REG], 04[ANSI_INVERSE]
 293  3445A                               CALL NZ, 45A[invert_colors]
 294  2231E                               JUMP 31E[sgr_next]
 295                       sgr_underline: 
 295  1D404                               COMPARE s4, 04
 296  3629B                               JUMP NZ, 29B[sgr_blink]
 297  0B430                               FETCH s4, 30[mode_flags]
 298  05402                               OR s4, 02[MODE_UNDERLINE]
 299  2F430                               STORE s4, 30[mode_flags]
 29A  2231E                               JUMP 31E[sgr_next]
 29B                           sgr_blink: ; high bit of background color
 29B  1D405                               COMPARE s4, 05
 29C  362A3                               JUMP NZ, 2A3[sgr_inverse]
 29D  0DC04                               TEST sC[ANSI_FLAG_REG], 04[ANSI_INVERSE]
 29E  3445A                               CALL NZ, 45A[invert_colors]
 29F  05608                               OR s6[COLOR_REG], 08
 2A0  0DC04                               TEST sC[ANSI_FLAG_REG], 04[ANSI_INVERSE]
 2A1  3445A                               CALL NZ, 45A[invert_colors]
 2A2  2231E                               JUMP 31E[sgr_next]
 2A3                         sgr_inverse: 
 2A3  1D407                               COMPARE s4, 07
 2A4  362AA                               JUMP NZ, 2AA[sgr_hidden]
 2A5  0DC04                               TEST sC[ANSI_FLAG_REG], 04[ANSI_INVERSE]        ; don't invert if we're already inverted
 2A6  3631E                               JUMP NZ, 31E[sgr_next]
 2A7  2045A                               CALL 45A[invert_colors]
 2A8  05C04                               OR sC[ANSI_FLAG_REG], 04[ANSI_INVERSE]
 2A9  2231E                               JUMP 31E[sgr_next]
 2AA                          sgr_hidden: ; turns on hidden mode- spaces will be printed instead of symbols
 2AA  1D408                               COMPARE s4, 08
 2AB  362AE                               JUMP NZ, 2AE[sgr_default_font]
 2AC  05C08                               OR sC[ANSI_FLAG_REG], 08[ANSI_HIDDEN]
 2AD  2231E                               JUMP 31E[sgr_next]
 2AE                    sgr_default_font: 
 2AE  1D40A                               COMPARE s4, 0A                                  ; CSI10m
 2AF  362B5                               JUMP NZ, 2B5[sgr_vt_graphics_font]
 2B0  03CBF                               AND sC[ANSI_FLAG_REG], BF[ANSI_VT_GRAPHICS_CLR]
 2B1  0B430                               FETCH s4, 30[mode_flags]
 2B2  034FE                               AND s4, FE[MODE_ALTERNATE_FONT_CLR]
 2B3  2F430                               STORE s4, 30[mode_flags]
 2B4  2231E                               JUMP 31E[sgr_next]
 2B5                sgr_vt_graphics_font: 
 2B5  1D40B                               COMPARE s4, 0B                                  ; CSI11m
 2B6  362BC                               JUMP NZ, 2BC[sgr_alternate_font]
 2B7  05C40                               OR sC[ANSI_FLAG_REG], 40[ANSI_VT_GRAPHICS]
 2B8  0B430                               FETCH s4, 30[mode_flags]
 2B9  034FE                               AND s4, FE[MODE_ALTERNATE_FONT_CLR]
 2BA  2F430                               STORE s4, 30[mode_flags]
 2BB  2231E                               JUMP 31E[sgr_next]
 2BC                  sgr_alternate_font: 
 2BC  1D40C                               COMPARE s4, 0C                                  ; CSI12m
 2BD  362C3                               JUMP NZ, 2C3[sgr_alternate_graphics_font]
 2BE  03CBF                               AND sC[ANSI_FLAG_REG], BF[ANSI_VT_GRAPHICS_CLR]
 2BF  0B430                               FETCH s4, 30[mode_flags]
 2C0  05401                               OR s4, 01[MODE_ALTERNATE_FONT]
 2C1  2F430                               STORE s4, 30[mode_flags]
 2C2  2231E                               JUMP 31E[sgr_next]
 2C3         sgr_alternate_graphics_font: 
 2C3  1D40D                               COMPARE s4, 0D                                  ; CSI13m
 2C4  362CA                               JUMP NZ, 2CA[sgr_reveal]
 2C5  05C40                               OR sC[ANSI_FLAG_REG], 40[ANSI_VT_GRAPHICS]
 2C6  0B430                               FETCH s4, 30[mode_flags]
 2C7  05401                               OR s4, 01[MODE_ALTERNATE_FONT]
 2C8  2F430                               STORE s4, 30[mode_flags]
 2C9  2231E                               JUMP 31E[sgr_next]
 2CA                          sgr_reveal: ; turns off hidden mode.
 2CA  1D41C                               COMPARE s4, 1C[28'd]
 2CB  362CE                               JUMP NZ, 2CE[sgr_normal_intensity]
 2CC  03CF7                               AND sC[ANSI_FLAG_REG], F7[ANSI_HIDDEN_CLR]
 2CD  2231E                               JUMP 31E[sgr_next]
 2CE                sgr_normal_intensity: ; turn off boldface
 2CE  1D416                               COMPARE s4, 16[22'd]
 2CF  362D6                               JUMP NZ, 2D6[sgr_underline_off]
 2D0  0DC04                               TEST sC[ANSI_FLAG_REG], 04[ANSI_INVERSE]
 2D1  3445A                               CALL NZ, 45A[invert_colors]
 2D2  0367F                               AND s6[COLOR_REG], 7F
 2D3  0DC04                               TEST sC[ANSI_FLAG_REG], 04[ANSI_INVERSE]
 2D4  3445A                               CALL NZ, 45A[invert_colors]
 2D5  2231E                               JUMP 31E[sgr_next]
 2D6                   sgr_underline_off: 
 2D6  1D418                               COMPARE s4, 18[24'd]
 2D7  362DC                               JUMP NZ, 2DC[sgr_blink_off]
 2D8  0B430                               FETCH s4, 30[mode_flags]
 2D9  034FD                               AND s4, FD[MODE_UNDERLINE_CLR]
 2DA  2F430                               STORE s4, 30[mode_flags]
 2DB  2231E                               JUMP 31E[sgr_next]
 2DC                       sgr_blink_off: ; turn off blink
 2DC  1D419                               COMPARE s4, 19[25'd]
 2DD  362E4                               JUMP NZ, 2E4[sgr_positive]
 2DE  0DC04                               TEST sC[ANSI_FLAG_REG], 04[ANSI_INVERSE]
 2DF  3445A                               CALL NZ, 45A[invert_colors]
 2E0  036F7                               AND s6[COLOR_REG], F7
 2E1  0DC04                               TEST sC[ANSI_FLAG_REG], 04[ANSI_INVERSE]
 2E2  3445A                               CALL NZ, 45A[invert_colors]
 2E3  2231E                               JUMP 31E[sgr_next]
 2E4                        sgr_positive: ; turn off inverse video
 2E4  1D41B                               COMPARE s4, 1B[27'd]
 2E5  362EB                               JUMP NZ, 2EB[sgr_default_foreground]
 2E6  0DC04                               TEST sC[ANSI_FLAG_REG], 04[ANSI_INVERSE]
 2E7  3231E                               JUMP Z, 31E[sgr_next]
 2E8  2045A                               CALL 45A[invert_colors]
 2E9  03CFB                               AND sC[ANSI_FLAG_REG], FB[ANSI_INVERSE_CLR]
 2EA  2231E                               JUMP 31E[sgr_next]
 2EB              sgr_default_foreground: 
 2EB  1D427                               COMPARE s4, 27[39'd]
 2EC  362F4                               JUMP NZ, 2F4[sgr_default_background]
 2ED  0DC04                               TEST sC[ANSI_FLAG_REG], 04[ANSI_INVERSE]
 2EE  3445A                               CALL NZ, 45A[invert_colors]
 2EF  0360F                               AND s6[COLOR_REG], 0F
 2F0  05670                               OR s6[COLOR_REG], 70
 2F1  0DC04                               TEST sC[ANSI_FLAG_REG], 04[ANSI_INVERSE]
 2F2  3445A                               CALL NZ, 45A[invert_colors]
 2F3  2231E                               JUMP 31E[sgr_next]
 2F4              sgr_default_background: 
 2F4  1D431                               COMPARE s4, 31[49'd]
 2F5  362FC                               JUMP NZ, 2FC[sgr_foreground]
 2F6  0DC04                               TEST sC[ANSI_FLAG_REG], 04[ANSI_INVERSE]
 2F7  3445A                               CALL NZ, 45A[invert_colors]
 2F8  036F0                               AND s6[COLOR_REG], F0
 2F9  0DC04                               TEST sC[ANSI_FLAG_REG], 04[ANSI_INVERSE]
 2FA  3445A                               CALL NZ, 45A[invert_colors]
 2FB  2231E                               JUMP 31E[sgr_next]
 2FC                      sgr_foreground: 
 2FC  1D426                               COMPARE s4, 26[38'd]                            ; highest foreground color plus one
 2FD  3E30F                               JUMP NC, 30F[sgr_background]
 2FE  0151D                               LOAD s5, 1D[29'd]                               ; lowest foreground color minus one
 2FF  1C540                               COMPARE s5, s4
 300  3E30F                               JUMP NC, 30F[sgr_background]
 301                                      ; OK, we're in the range 30-37
 301  0DC04                               TEST sC[ANSI_FLAG_REG], 04[ANSI_INVERSE]        ; swap the colors if we need to
 302  3445A                               CALL NZ, 45A[invert_colors]
 303  2F43D                               STORE s4, 3D[scratchX]
 304  1941E                               SUB s4, 1E[30'd]                                ; normalize to zero
 305  0368F                               AND s6[COLOR_REG], 8F                           ; clear the three bits we're interested in
 306  14406                               SL0 s4
 307  14406                               SL0 s4
 308  14406                               SL0 s4
 309  14406                               SL0 s4
 30A  10640                               ADD s6[COLOR_REG], s4                           ; and set the new value
 30B  0DC04                               TEST sC[ANSI_FLAG_REG], 04[ANSI_INVERSE]        ; swap the colors back if we need to
 30C  3445A                               CALL NZ, 45A[invert_colors]
 30D  0B43D                               FETCH s4, 3D[scratchX]
 30E  2231E                               JUMP 31E[sgr_next]
 30F                      sgr_background: 
 30F  1D430                               COMPARE s4, 30[48'd]                            ; highest background color plus one
 310  3E31E                               JUMP NC, 31E[sgr_other]
 311  01527                               LOAD s5, 27[39'd]                               ; lowest background color minus one
 312  1C540                               COMPARE s5, s4
 313  3E31E                               JUMP NC, 31E[sgr_other]
 314                                      ; OK, we're in the range 40-37
 314  0DC04                               TEST sC[ANSI_FLAG_REG], 04[ANSI_INVERSE]        ; swap the colors if we need to
 315  3445A                               CALL NZ, 45A[invert_colors]
 316  2F43D                               STORE s4, 3D[scratchX]
 317  19428                               SUB s4, 28[40'd]                                ; normalize to zero
 318  036F8                               AND s6[COLOR_REG], F8                           ; clear the three bits we're interested in
 319  10640                               ADD s6[COLOR_REG], s4                           ; and set the new value
 31A  0DC04                               TEST sC[ANSI_FLAG_REG], 04[ANSI_INVERSE]        ; swap the colors back if we need to
 31B  3445A                               CALL NZ, 45A[invert_colors]
 31C  0B43D                               FETCH s4, 3D[scratchX]
 31D  2231E                               JUMP 31E[sgr_next]
 31E                           sgr_other: 
 31E                            sgr_next: 
 31E  11101                               ADD s1, 01
 31F  1C100                               COMPARE s1, s0
 320  36283                               JUMP NZ, 283[sgr_param]                         ; get the next one until we're done
 321                             sgr_end: 
 321  2243C                               JUMP 43C[exit_escape]
 322                            csi_move: ; set cursor position Y,X
 322  1D548                               COMPARE s5, 48["H"]
 323  32326                               JUMP Z, 326[csi_move2]
 324  1D566                               COMPARE s5, 66["f"]
 325  36346                               JUMP NZ, 346[csi_set_row]
 326                           csi_move2: 
 326  0B007                               FETCH s0, 07[param_counter]
 327  1D002                               COMPARE s0, 02                                  ; do we have exactly two parameters?
 328  3232B                               JUMP Z, 32B[two_params]
 329  01000                               LOAD s0, 00
 32A  2F009                               STORE s0, 09[param_two]
 32B  01008                   two_params: LOAD s0, 08[param_block]
 32C  0A100                               FETCH s1, (s0)
 32D  1D100                               COMPARE s1, 00                                  ; if we're already zero we don't subtract
 32E  32330                               JUMP Z, 330[move_y0]
 32F  19101                               SUB s1, 01                                      ; we're zero based
 330                             move_y0: 
 330  1C170                               COMPARE s1, s7[MAX_LINE]
 331  3A334                               JUMP C, 334[move_y00]                           ; clip to the bottom edge
 332  00170                               LOAD s1, s7[MAX_LINE]
 333  19101                               SUB s1, 01
 334                            move_y00: 
 334  00810                               LOAD s8[DIVISOR_LOW], s1
 335  009D0                               LOAD s9[DIVISOR_HIGH], sD[CHAR_PER_LINE]
 336  205E5                               CALL 5E5[mult_8x8]
 337  00A30                               LOAD sA[CURSOR_HIGH], s3[DIVIDEND_HIGH]
 338  00B40                               LOAD sB[CURSOR_LOW], s4
 339  11001                               ADD s0, 01
 33A  0A100                               FETCH s1, (s0)
 33B  1D100                               COMPARE s1, 00                                  ;if we're already zero we don't subtract
 33C  3233E                               JUMP Z, 33E[move_x0]
 33D  19101                               SUB s1, 01                                      ; we're zero based
 33E                             move_x0: 
 33E  1C1D0                               COMPARE s1, sD[CHAR_PER_LINE]
 33F  3A342                               JUMP C, 342[move_x00]                           ; clip to the right edge
 340  001D0                               LOAD s1, sD[CHAR_PER_LINE]
 341  19101                               SUB s1, 01
 342                            move_x00: 
 342  10B10                               ADD sB[CURSOR_LOW], s1
 343  13A00                               ADDCY sA[CURSOR_HIGH], 00
 344  200B0                               CALL 0B0[set_cursor]
 345  2243C                               JUMP 43C[exit_escape]
 346                         csi_set_row: 
 346  1D564                               COMPARE s5, 64["d"]
 347  3635C                               JUMP NZ, 35C[csi_set_column]
 348  0B008                               FETCH s0, 08[param_block]
 349  1D000                               COMPARE s0, 00
 34A  3234C                               JUMP Z, 34C[row_0]
 34B  19001                               SUB s0, 01
 34C                               row_0: 
 34C  1C070                               COMPARE s0, s7[MAX_LINE]
 34D  3A350                               JUMP C, 350[row_00]
 34E  00070                               LOAD s0, s7[MAX_LINE]                           ; clip to the bottom edge
 34F  19001                               SUB s0, 01
 350                              row_00: 
 350  2F03D                               STORE s0, 3D[scratchX]
 351  205C4                               CALL 5C4[get_row_column]
 352  0B03D                               FETCH s0, 3D[scratchX]
 353  00800                               LOAD s8[DIVISOR_LOW], s0
 354  009D0                               LOAD s9[DIVISOR_HIGH], sD[CHAR_PER_LINE]
 355  205E5                               CALL 5E5[mult_8x8]
 356  00A30                               LOAD sA[CURSOR_HIGH], s3[DIVIDEND_HIGH]
 357  00B40                               LOAD sB[CURSOR_LOW], s4
 358  10BE0                               ADD sB[CURSOR_LOW], sE
 359  13A00                               ADDCY sA[CURSOR_HIGH], 00
 35A  200B0                               CALL 0B0[set_cursor]
 35B  2243C                               JUMP 43C[exit_escape]
 35C                      csi_set_column: 
 35C  1D547                               COMPARE s5, 47["G"]
 35D  36372                               JUMP NZ, 372[csi_repeat]
 35E  0B008                               FETCH s0, 08[param_block]
 35F  1D000                               COMPARE s0, 00
 360  32362                               JUMP Z, 362[column_0]
 361  19001                               SUB s0, 01
 362                            column_0: 
 362  1C0D0                               COMPARE s0, sD[CHAR_PER_LINE]
 363  3A366                               JUMP C, 366[column_00]
 364  000D0                               LOAD s0, sD[CHAR_PER_LINE]                      ; clip to the right edge
 365  19001                               SUB s0, 01
 366                           column_00: 
 366  2F03D                               STORE s0, 3D[scratchX]
 367  205C4                               CALL 5C4[get_row_column]
 368  00820                               LOAD s8[DIVISOR_LOW], s2[DIVIDEND_LOW]
 369  009D0                               LOAD s9[DIVISOR_HIGH], sD[CHAR_PER_LINE]
 36A  205E5                               CALL 5E5[mult_8x8]
 36B  00A30                               LOAD sA[CURSOR_HIGH], s3[DIVIDEND_HIGH]
 36C  00B40                               LOAD sB[CURSOR_LOW], s4
 36D  0B03D                               FETCH s0, 3D[scratchX]
 36E  10B00                               ADD sB[CURSOR_LOW], s0
 36F  13A00                               ADDCY sA[CURSOR_HIGH], 00
 370  200B0                               CALL 0B0[set_cursor]
 371  2243C                               JUMP 43C[exit_escape]
 372                          csi_repeat: ; repeat last character # times
 372  1D562                               COMPARE s5, 62["b"]
 373  36384                               JUMP NZ, 384[csi_clear_line]
 374  03CFD                               AND sC[ANSI_FLAG_REG], FD[ANSI_ESCAPE_CLR]
 375  03CFE                               AND sC[ANSI_FLAG_REG], FE[ANSI_CSI_CLR]
 376  2F537                               STORE s5, 37[scratchR]
 377  0B008                               FETCH s0, 08[param_block]
 378  1D000                               COMPARE s0, 00
 379  3637B                               JUMP NZ, 37B[repeat_loop]
 37A  11001                               ADD s0, 01                                      ; treat zero as one
 37B                         repeat_loop: 
 37B  0B531                               FETCH s5, 31[last_char]                         ; do this every time?
 37C  2F036                               STORE s0, 36[scratchQ]
 37D  200DC                               CALL 0DC[raw_char_out]
 37E  0B036                               FETCH s0, 36[scratchQ]
 37F  19001                               SUB s0, 01
 380  1D000                               COMPARE s0, 00
 381  3637B                               JUMP NZ, 37B[repeat_loop]
 382  0B537                               FETCH s5, 37[scratchR]
 383  25000                               RETURN 
 384                      csi_clear_line: 
 384  1D54B                               COMPARE s5, 4B["K"]                             ; ANSI.SYS ignores the parameter and always clears right
 385  363B2                               JUMP NZ, 3B2[csi_up]                            ; the spec says parameter 1 clears left, 2 clears whole line
 386  2FB00                               STORE sB[CURSOR_LOW], 00[scratchLOW]
 387  2FA01                               STORE sA[CURSOR_HIGH], 01[scratchHIGH]
 388  205BF                               CALL 5BF[get_row_column_plus]
 389  0B408                               FETCH s4, 08[param_block]
 38A  1D400                               COMPARE s4, 00
 38B  3239F                               JUMP Z, 39F[clear_eol]                          ; end of line
 38C  1D401                               COMPARE s4, 01
 38D  32395                               JUMP Z, 395[clear_sol]                          ; start of line
 38E                    clear_whole_line: 
 38E  19E01                               SUB sE, 01
 38F  18BE0                               SUB sB[CURSOR_LOW], sE
 390  1BA00                               SUBCY sA[CURSOR_HIGH], 00
 391  200B0                               CALL 0B0[set_cursor]                            ; we're at the start of the line
 392  00ED0                               LOAD sE, sD[CHAR_PER_LINE]
 393  01400                               LOAD s4, 00
 394                                      ; FETCH DIVIDEND_LOW, 00 ; clear underline and font bits
 394  223A7                               JUMP 3A7[clear_eol_loop]
 395                           clear_sol: ; start of line
 395                                      ; FETCH DIVIDEND_LOW, 00 ; clear underline and font bits
 395  01400                               LOAD s4, 00
 396                      clear_sol_loop: 
 396  2D451                               OUTPUT s4, 51[EXTRA_PORT]
 397  2D404                               OUTPUT s4, 04[CHAR_PORT]
 398  2D609                               OUTPUT s6[COLOR_REG], 09[ATTR_PORT]
 399  200AB                               CALL 0AB[decrement_cursor]
 39A  200B0                               CALL 0B0[set_cursor]
 39B  19E01                               SUB sE, 01
 39C  1DE00                               COMPARE sE, 00
 39D  36396                               JUMP NZ, 396[clear_sol_loop]
 39E  223AE                               JUMP 3AE[finish_clear_line]
 39F                           clear_eol: ; end of line
 39F  004D0                               LOAD s4, sD[CHAR_PER_LINE]
 3A0  11401                               ADD s4, 01                                      ; we should just define another constant and remove this instruction
 3A1  184E0                               SUB s4, sE                                      ; invert it to get remaining characters
 3A2  00E40                               LOAD sE, s4
 3A3                                      ;FETCH DIVIDEND_LOW, 00 ; clear underline and font bits
 3A3  01400                               LOAD s4, 00
 3A4  1DE00                               COMPARE sE, 00
 3A5  363A7                               JUMP NZ, 3A7[clear_eol_loop]
 3A6  00ED0                               LOAD sE, sD[CHAR_PER_LINE]                      ; we're at the beginning of the line so we do it all
 3A7                      clear_eol_loop: 
 3A7  2D451                               OUTPUT s4, 51[EXTRA_PORT]
 3A8  2D404                               OUTPUT s4, 04[CHAR_PORT]
 3A9  2D609                               OUTPUT s6[COLOR_REG], 09[ATTR_PORT]
 3AA  200AE                               CALL 0AE[advance_cursor]
 3AB  19E01                               SUB sE, 01
 3AC  1DE00                               COMPARE sE, 00                                  ; sE is the line remainder
 3AD  363A7                               JUMP NZ, 3A7[clear_eol_loop]
 3AE                   finish_clear_line: 
 3AE  0BB00                               FETCH sB[CURSOR_LOW], 00[scratchLOW]
 3AF  0BA01                               FETCH sA[CURSOR_HIGH], 01[scratchHIGH]
 3B0  200B0                               CALL 0B0[set_cursor]
 3B1  2243C                               JUMP 43C[exit_escape]
 3B2                              csi_up: 
 3B2  1D541                               COMPARE s5, 41["A"]                             ; we're going UP
 3B3  363BC                               JUMP NZ, 3BC[csi_down]
 3B4  0B108                               FETCH s1, 08[param_block]
 3B5  1D100                               COMPARE s1, 00
 3B6  363B8                               JUMP NZ, 3B8[up_loop]
 3B7  11101                               ADD s1, 01
 3B8                             up_loop: 
 3B8  20496                               CALL 496[line_up]
 3B9  19101                               SUB s1, 01
 3BA  363B8                               JUMP NZ, 3B8[up_loop]
 3BB  2243C                               JUMP 43C[exit_escape]
 3BC                            csi_down: 
 3BC  1D542                               COMPARE s5, 42["B"]
 3BD  363C6                               JUMP NZ, 3C6[csi_right]
 3BE  0B108                               FETCH s1, 08[param_block]
 3BF  1D100                               COMPARE s1, 00
 3C0  363C2                               JUMP NZ, 3C2[down_loop]
 3C1  11101                               ADD s1, 01
 3C2                           down_loop: 
 3C2  2049D                               CALL 49D[line_down]
 3C3  19101                               SUB s1, 01
 3C4  363C2                               JUMP NZ, 3C2[down_loop]
 3C5  2243C                               JUMP 43C[exit_escape]
 3C6                           csi_right: 
 3C6  1D543                               COMPARE s5, 43["C"]
 3C7  363D4                               JUMP NZ, 3D4[csi_left]
 3C8  0B008                               FETCH s0, 08[param_block]
 3C9  1D000                               COMPARE s0, 00
 3CA  363CD                               JUMP NZ, 3CD[one_right]
 3CB  11001                               ADD s0, 01                                      ; if the param is zero make it one
 3CC  2F008                               STORE s0, 08[param_block]
 3CD                           one_right: 
 3CD  20490                               CALL 490[right_cursor]
 3CE  0B008                               FETCH s0, 08[param_block]
 3CF  19001                               SUB s0, 01
 3D0  2F008                               STORE s0, 08[param_block]
 3D1  1D000                               COMPARE s0, 00
 3D2  363CD                               JUMP NZ, 3CD[one_right]
 3D3  2243C                               JUMP 43C[exit_escape]                           ;
 3D4                            csi_left: 
 3D4  1D544                               COMPARE s5, 44["D"]
 3D5  363E2                               JUMP NZ, 3E2[csi_back_tab]
 3D6  0B008                               FETCH s0, 08[param_block]
 3D7  1D000                               COMPARE s0, 00
 3D8  363DB                               JUMP NZ, 3DB[one_left]
 3D9  11001                               ADD s0, 01                                      ; if the param is zero make it one
 3DA  2F008                               STORE s0, 08[param_block]
 3DB                            one_left: 
 3DB  2048A                               CALL 48A[left_cursor]
 3DC  0B008                               FETCH s0, 08[param_block]
 3DD  19001                               SUB s0, 01
 3DE  2F008                               STORE s0, 08[param_block]
 3DF  1D000                               COMPARE s0, 00
 3E0  363DB                               JUMP NZ, 3DB[one_left]
 3E1  2243C                               JUMP 43C[exit_escape]
 3E2                        csi_back_tab: 
 3E2  1D55A                               COMPARE s5, 5A["Z"]
 3E3  363EF                               JUMP NZ, 3EF[csi_tab]
 3E4  0B108                               FETCH s1, 08[param_block]
 3E5  1D100                               COMPARE s1, 00
 3E6  363E8                               JUMP NZ, 3E8[back_tab_loop]
 3E7  11101                               ADD s1, 01
 3E8                       back_tab_loop: 
 3E8  2F13D                               STORE s1, 3D[scratchX]
 3E9  2047D                               CALL 47D[backtab]
 3EA  0B13D                               FETCH s1, 3D[scratchX]
 3EB  19101                               SUB s1, 01
 3EC  1D100                               COMPARE s1, 00
 3ED  363E8                               JUMP NZ, 3E8[back_tab_loop]
 3EE  2243C                               JUMP 43C[exit_escape]
 3EF                             csi_tab: 
 3EF  1D549                               COMPARE s5, 49["I"]
 3F0  363FC                               JUMP NZ, 3FC[csi_device_status_report]
 3F1  0B108                               FETCH s1, 08[param_block]
 3F2  1D100                               COMPARE s1, 00
 3F3  363F5                               JUMP NZ, 3F5[tab_loop]
 3F4  11101                               ADD s1, 01
 3F5                            tab_loop: 
 3F5  2F13D                               STORE s1, 3D[scratchX]
 3F6  20476                               CALL 476[htab]
 3F7  0B13D                               FETCH s1, 3D[scratchX]
 3F8  19101                               SUB s1, 01
 3F9  1D100                               COMPARE s1, 00
 3FA  363F5                               JUMP NZ, 3F5[tab_loop]
 3FB  2243C                               JUMP 43C[exit_escape]
 3FC            csi_device_status_report: 
 3FC  1D56E                               COMPARE s5, 6E["n"]
 3FD  3641C                               JUMP NZ, 41C[csi_margins]
 3FE  0B008                               FETCH s0, 08[param_block]
 3FF  1D006                               COMPARE s0, 06
 400  3641B                               JUMP NZ, 41B[DSR_other]
 401                send_position_report: ; note that this will not be echoed locally- just remote.
 401  2FB00                               STORE sB[CURSOR_LOW], 00[scratchLOW]
 402  2FA01                               STORE sA[CURSOR_HIGH], 01[scratchHIGH]
 403  2F43D                               STORE s4, 3D[scratchX]
 404  2F53E                               STORE s5, 3E[scratchY]
 405  0151B                               LOAD s5, 1B
 406  20635                               CALL 635[UART_TX]                               ; send the CSI only to the serial port, no local echo for this
 407  0155B                               LOAD s5, 5B["["]
 408  20635                               CALL 635[UART_TX]
 409  205C4                               CALL 5C4[get_row_column]
 40A  2FE3F                               STORE sE, 3F[scratchZ]
 40B  11201                               ADD s2[DIVIDEND_LOW], 01
 40C  13300                               ADDCY s3[DIVIDEND_HIGH], 00
 40D  205F0                               CALL 5F0[send_integer]
 40E  0153B                               LOAD s5, 3B[";"]
 40F  20635                               CALL 635[UART_TX]
 410  0B23F                               FETCH s2[DIVIDEND_LOW], 3F[scratchZ]
 411  01300                               LOAD s3[DIVIDEND_HIGH], 00
 412  11201                               ADD s2[DIVIDEND_LOW], 01
 413  13300                               ADDCY s3[DIVIDEND_HIGH], 00
 414                                      ;LOAD DIVIDEND_HIGH, 00
 414  205F0                               CALL 5F0[send_integer]
 415  01552                               LOAD s5, 52["R"]
 416  20635                               CALL 635[UART_TX]
 417  0BB00                               FETCH sB[CURSOR_LOW], 00[scratchLOW]
 418  0BA01                               FETCH sA[CURSOR_HIGH], 01[scratchHIGH]
 419  0B43D                               FETCH s4, 3D[scratchX]
 41A  0B53E                               FETCH s5, 3E[scratchY]
 41B                           DSR_other: ; the host has requested a DSR but it's not a position report request, so we ignore it right now
 41B  2243C                               JUMP 43C[exit_escape]
 41C                         csi_margins: ; VT100 command set margins. we accept this command but we ignore it. it is used by the linux "resize" command.
 41C  1D572                               COMPARE s5, 72["r"]
 41D  3641F                               JUMP NZ, 41F[csi_tilde]
 41E                                      ; NOP
 41E  2243C                               JUMP 43C[exit_escape]
 41F                                      ;
 41F                                      ; CSI tilde is non-standard. when we're in local echo mode it's nice to have the home/end/pgup/pgdn/insert/delete keys do something useful.
 41F                                      ;
 41F                           csi_tilde: ; these are the function keys,etc. we try do to the right thing when we're in loopback mode
 41F  1D57E                               COMPARE s5, 7E["~"]
 420  3643C                               JUMP NZ, 43C[unknown_command]
 421  0B008                               FETCH s0, 08[param_block]
 422                          check_home: 
 422  1D001                               COMPARE s0, 01
 423  36426                               JUMP NZ, 426[check_insert]
 424  204CF                               CALL 4CF[home_cursor]
 425  2243C                               JUMP 43C[exit_escape]
 426                        check_insert: 
 426  1D002                               COMPARE s0, 02
 427  3642B                               JUMP NZ, 42B[check_delete]
 428  01101                               LOAD s1, 01
 429  2022A                               CALL 22A[insert_loop]
 42A  2243C                               JUMP 43C[exit_escape]
 42B                        check_delete: 
 42B  1D003                               COMPARE s0, 03
 42C  36430                               JUMP NZ, 430[check_end]
 42D  01101                               LOAD s1, 01
 42E  20251                               CALL 251[delete_loop]
 42F  2243C                               JUMP 43C[exit_escape]
 430                           check_end: 
 430  1D004                               COMPARE s0, 04
 431  36434                               JUMP NZ, 434[check_pgup]
 432  204DE                               CALL 4DE[end_of_line]
 433  2243C                               JUMP 43C[exit_escape]
 434                          check_pgup: 
 434  1D005                               COMPARE s0, 05
 435  36438                               JUMP NZ, 438[check_pgdn]
 436  204D6                               CALL 4D6[set_origin]
 437  2243C                               JUMP 43C[exit_escape]
 438                          check_pgdn: 
 438  1D006                               COMPARE s0, 06
 439  3643C                               JUMP NZ, 43C[unknown_command]
 43A  204DA                               CALL 4DA[end_cursor]
 43B  2243C                               JUMP 43C[exit_escape]
 43C                     unknown_command: 
 43C                                      ; LOAD s4,s5   ; we used to print U but now we send the actual code
 43C                                      ; CALL debug_s4  ; comment this line out unless debugging ****
 43C                         exit_escape: 
 43C  03CFD                               AND sC[ANSI_FLAG_REG], FD[ANSI_ESCAPE_CLR]
 43D  03CFE                               AND sC[ANSI_FLAG_REG], FE[ANSI_CSI_CLR]
 43E  25000                               RETURN 
 43F                           end_param: ; OK, we've already stored the decimal digits. now it's time to convert them to hex
 43F  01E00                               LOAD sE, 00                                     ; empty parameters default to zero
 440  0B111                               FETCH s1, 11[digit_counter]
 441  1D100                               COMPARE s1, 00
 442  32450                               JUMP Z, 450[end_digits]                         ; no digits? just clean up with the zero value
 443  01012                               LOAD s0, 12[digit_block]
 444                            do_digit: ; convert decimal digits to hex value stored in sE
 444  0A400                               FETCH s4, (s0)                                  ; get the actual digit
 445  19430                               SUB s4, 30                                      ; convert ASCII character to integer
 446  10E40                               ADD sE, s4                                      ; add the digit to the total
 447  19101                               SUB s1, 01
 448  1D100                               COMPARE s1, 00                                  ; is this the last digit?
 449  32450                               JUMP Z, 450[end_digits]
 44A  11001                               ADD s0, 01                                      ; go to the next digit
 44B  008E0                               LOAD s8[DIVISOR_LOW], sE                        ; multiplicand
 44C  0190A                               LOAD s9[DIVISOR_HIGH], 0A                       ; multiplier times 10
 44D  205E5                               CALL 5E5[mult_8x8]                              ; multiply the whole thing by 10, place result back in s4, ignore overflow?
 44E  00E40                               LOAD sE, s4
 44F  22444                               JUMP 444[do_digit]
 450                          end_digits: ; we've done all the digits.
 450  004E0                               LOAD s4, sE
 451                                      ; store the parameter here and increment the parameter counter
 451  01008                               LOAD s0, 08[param_block]
 452  0B107                               FETCH s1, 07[param_counter]
 453  10010                               ADD s0, s1
 454  2EE00                               STORE sE, (s0)
 455  01000                               LOAD s0, 00
 456  2F011                               STORE s0, 11[digit_counter]                     ; reset the digit counter to zero
 457  11101                               ADD s1, 01                                      ; increment the parameter count
 458                                      ; COMPARE s1,max_param  ; prevent overflow of parameter space
 458                                      ; RETURN NC
 458  2F107                               STORE s1, 07[param_counter]
 459  25000                               RETURN 
 45A                       invert_colors: ; swap the foreground and background colors
 45A  2F43E                               STORE s4, 3E[scratchY]
 45B  00460                               LOAD s4, s6[COLOR_REG]
 45C  1460E                               SR0 s6[COLOR_REG]
 45D  1460E                               SR0 s6[COLOR_REG]
 45E  1460E                               SR0 s6[COLOR_REG]
 45F  1460E                               SR0 s6[COLOR_REG]
 460  14406                               SL0 s4
 461  14406                               SL0 s4
 462  14406                               SL0 s4
 463  14406                               SL0 s4
 464  04640                               OR s6[COLOR_REG], s4
 465  0B43E                               FETCH s4, 3E[scratchY]
 466  25000                               RETURN 
 467                                      ;
 467                                      ; process various control codes
 467                                      ;
 467                                      ;
 467                             enquiry: ; we respond to an ENQ with an ACK, but not locally
 467  01506                               LOAD s5, 06[ACK_CHAR]
 468  20635                               CALL 635[UART_TX]
 469  25000                               RETURN 
 46A                           backspace: 
 46A  1DB00                               COMPARE sB[CURSOR_LOW], 00
 46B  1FA00                               COMPARECY sA[CURSOR_HIGH], 00
 46C  31000                               RETURN Z                                        ; do nothing if we're at the top left
 46D  19B01                               SUB sB[CURSOR_LOW], 01
 46E  1BA00                               SUBCY sA[CURSOR_HIGH], 00
 46F  200B0                               CALL 0B0[set_cursor]
 470  25000                               RETURN 
 471  2248A                               JUMP 48A[left_cursor]
 472                              rubout: ; rubout is a destructive non-wrapping backspace.
 472  2048A                               CALL 48A[left_cursor]
 473  01520                               LOAD s5, 20
 474  200B8                               CALL 0B8[send_next]                             ; this is recursive
 475  2248A                               JUMP 48A[left_cursor]
 476                                      ; tabs stops are every eight characters (0,8,16,24,32,40,48,56,64,72,80,88,96,104,112 (120)
 476                                      ; note that this wraps to the next line and it probably should not.. maybe? It depends on the mode.    ****
 476  000B0                         htab: LOAD s0, sB[CURSOR_LOW]
 477  03007                               AND s0, 07
 478  01108                               LOAD s1, 08
 479  18100                               SUB s1, s0
 47A  10B10                               ADD sB[CURSOR_LOW], s1
 47B  13A00                               ADDCY sA[CURSOR_HIGH], 00
 47C  220B0                               JUMP 0B0[set_cursor]
 47D                             backtab: ; move to the previous tab stop (0,8...)
 47D  205C4                               CALL 5C4[get_row_column]                        ; sE now contains the column
 47E  1DE00                               COMPARE sE, 00
 47F  31000                               RETURN Z                                        ; we're already at the left edge, so we do nothing
 480  000E0                               LOAD s0, sE
 481  03007                               AND s0, 07                                      ; round it to the nearest 8
 482  1D000                               COMPARE s0, 00
 483  32487                               JUMP Z, 487[full_back]                          ; move back an entire 8 characters
 484  18B00                               SUB sB[CURSOR_LOW], s0
 485  1BA00                               SUBCY sA[CURSOR_HIGH], 00
 486  220B0                               JUMP 0B0[set_cursor]
 487                           full_back: 
 487  19B08                               SUB sB[CURSOR_LOW], 08
 488  1BA00                               SUBCY sA[CURSOR_HIGH], 00
 489  220B0                               JUMP 0B0[set_cursor]
 48A                         left_cursor: 
 48A  205C4                               CALL 5C4[get_row_column]
 48B  1DE00                               COMPARE sE, 00
 48C  31000                               RETURN Z                                        ; do nothing if we're on the left edge
 48D  200AB                               CALL 0AB[decrement_cursor]
 48E  200B0                               CALL 0B0[set_cursor]
 48F  25000                               RETURN 
 490                        right_cursor: 
 490  205C4                               CALL 5C4[get_row_column]
 491  11E01                               ADD sE, 01
 492  1CED0                               COMPARE sE, sD[CHAR_PER_LINE]
 493  31000                               RETURN Z                                        ; do nothing if we're on the right edge
 494  200AE                               CALL 0AE[advance_cursor]
 495  25000                               RETURN 
 496                             line_up: 
 496  1CBD0                               COMPARE sB[CURSOR_LOW], sD[CHAR_PER_LINE]
 497  1FA00                               COMPARECY sA[CURSOR_HIGH], 00
 498  39000                               RETURN C                                        ; do nothing if we're on the top line
 499  18BD0                               SUB sB[CURSOR_LOW], sD[CHAR_PER_LINE]           ; move the cursor up one line, stopping at the top.
 49A  1BA00                               SUBCY sA[CURSOR_HIGH], 00
 49B  200B0                               CALL 0B0[set_cursor]
 49C  25000                               RETURN 
 49D                           line_down: 
 49D  20557                               CALL 557[compare_cursor_last]
 49E  3D000                               RETURN NC
 49F  10BD0                               ADD sB[CURSOR_LOW], sD[CHAR_PER_LINE]
 4A0  13A00                               ADDCY sA[CURSOR_HIGH], 00                       ; move the cursor down one line
 4A1  200B0                               CALL 0B0[set_cursor]
 4A2  25000                               RETURN 
 4A3                           line_feed: 
 4A3  20557                               CALL 557[compare_cursor_last]
 4A4  3E4F0                               JUMP NC, 4F0[scroll_up]
 4A5  10BD0                               ADD sB[CURSOR_LOW], sD[CHAR_PER_LINE]
 4A6  13A00                               ADDCY sA[CURSOR_HIGH], 00                       ; move the cursor down one line
 4A7  200B0                               CALL 0B0[set_cursor]
 4A8  25000                               RETURN 
 4A9                  clear_start_screen: ; clear from cursor position to the start of the screen.
 4A9  2FB00                               STORE sB[CURSOR_LOW], 00[scratchLOW]
 4AA  2FA01                               STORE sA[CURSOR_HIGH], 01[scratchHIGH]
 4AB  01400                               LOAD s4, 00
 4AC                      clear_backward: 
 4AC  2D451                               OUTPUT s4, 51[EXTRA_PORT]
 4AD  2D404                               OUTPUT s4, 04[CHAR_PORT]
 4AE  2D609                               OUTPUT s6[COLOR_REG], 09[ATTR_PORT]
 4AF  200AB                               CALL 0AB[decrement_cursor]
 4B0  1DB00                               COMPARE sB[CURSOR_LOW], 00
 4B1  1FA00                               COMPARECY sA[CURSOR_HIGH], 00
 4B2  200B0                               CALL 0B0[set_cursor]
 4B3  364AC                               JUMP NZ, 4AC[clear_backward]
 4B4  2D251                               OUTPUT s2[DIVIDEND_LOW], 51[EXTRA_PORT]
 4B5  2D404                               OUTPUT s4, 04[CHAR_PORT]                        ; do the last bit
 4B6  2D609                               OUTPUT s6[COLOR_REG], 09[ATTR_PORT]
 4B7  0BB00                               FETCH sB[CURSOR_LOW], 00[scratchLOW]
 4B8  0BA01                               FETCH sA[CURSOR_HIGH], 01[scratchHIGH]
 4B9  200B0                               CALL 0B0[set_cursor]
 4BA  25000                               RETURN 
 4BB                           form_feed: 
 4BB  01B00                               LOAD sB[CURSOR_LOW], 00
 4BC  01A00                               LOAD sA[CURSOR_HIGH], 00
 4BD                    clear_end_screen: ; clear to end of screen inclusive
 4BD  2FB00                               STORE sB[CURSOR_LOW], 00[scratchLOW]
 4BE  2FA01                               STORE sA[CURSOR_HIGH], 01[scratchHIGH]
 4BF  01400                               LOAD s4, 00                                     ; fill the screen with spaces
 4C0  0B020                               FETCH s0, 20[MAX_LINE_LOWER]
 4C1  0B121                               FETCH s1, 21[MAX_LINE_UPPER]
 4C2                        clear_a_char: 
 4C2  200B0                               CALL 0B0[set_cursor]
 4C3  2D451                               OUTPUT s4, 51[EXTRA_PORT]
 4C4  2D404                               OUTPUT s4, 04[CHAR_PORT]
 4C5  2D609                               OUTPUT s6[COLOR_REG], 09[ATTR_PORT]
 4C6  11B01                               ADD sB[CURSOR_LOW], 01                          ; increment
 4C7  13A00                               ADDCY sA[CURSOR_HIGH], 00
 4C8  1CB00                               COMPARE sB[CURSOR_LOW], s0
 4C9  1EA10                               COMPARECY sA[CURSOR_HIGH], s1
 4CA  364C2                               JUMP NZ, 4C2[clear_a_char]
 4CB  0BB00                               FETCH sB[CURSOR_LOW], 00[scratchLOW]            ; restore our cursor position
 4CC  0BA01                               FETCH sA[CURSOR_HIGH], 01[scratchHIGH]
 4CD  200B0                               CALL 0B0[set_cursor]                            ;
 4CE  25000                               RETURN 
 4CF                         home_cursor: ; cursor to start of line
 4CF  205C4                               CALL 5C4[get_row_column]
 4D0  1DE00                               COMPARE sE, 00                                  ; are we on the left edge?
 4D1  31000                               RETURN Z
 4D2  18BE0                               SUB sB[CURSOR_LOW], sE                          ; no, subtract the remainder to put us at the left edge
 4D3  1BA00                               SUBCY sA[CURSOR_HIGH], 00
 4D4  200B0                               CALL 0B0[set_cursor]
 4D5  25000                               RETURN 
 4D6                          set_origin: ; put cursor in upper left corner
 4D6  01B00                               LOAD sB[CURSOR_LOW], 00
 4D7  01A00                               LOAD sA[CURSOR_HIGH], 00
 4D8  200B0                               CALL 0B0[set_cursor]
 4D9  25000                               RETURN 
 4DA                          end_cursor: ; cursor to first character of last line
 4DA  0BB22                               FETCH sB[CURSOR_LOW], 22[LAST_LINE_LOWER]
 4DB  0BA23                               FETCH sA[CURSOR_HIGH], 23[LAST_LINE_UPPER]
 4DC  200B0                               CALL 0B0[set_cursor]
 4DD  25000                               RETURN 
 4DE                         end_of_line: ; cursor to end of line
 4DE  204CF                               CALL 4CF[home_cursor]
 4DF  200AB                               CALL 0AB[decrement_cursor]
 4E0  10BD0                               ADD sB[CURSOR_LOW], sD[CHAR_PER_LINE]
 4E1  13A00                               ADDCY sA[CURSOR_HIGH], 00
 4E2  200B0                               CALL 0B0[set_cursor]
 4E3  25000                               RETURN 
 4E4                                CRLF: 
 4E4  204E6                               CALL 4E6[carriage_return]
 4E5  224E8                               JUMP 4E8[cr_leftedge]
 4E6                     carriage_return: 
 4E6  204CF                               CALL 4CF[home_cursor]
 4E7  25000                               RETURN                                          ; uncomment this for no automatic CR/LF pair
 4E8  10BD0                  cr_leftedge: ADD sB[CURSOR_LOW], sD[CHAR_PER_LINE]           ; add 80 characters
 4E9  13A00                               ADDCY sA[CURSOR_HIGH], 00
 4EA  2054E                               CALL 54E[compare_cursor_max]
 4EB  324EE                               JUMP Z, 4EE[cr_scroll_up]
 4EC  200B0                 cr_regadjust: CALL 0B0[set_cursor]
 4ED  25000                               RETURN 
 4EE                        cr_scroll_up: 
 4EE  0BB22                               FETCH sB[CURSOR_LOW], 22[LAST_LINE_LOWER]
 4EF  0BA23                               FETCH sA[CURSOR_HIGH], 23[LAST_LINE_UPPER]
 4F0                           scroll_up: ; scrolling is done in hardware with an address offset register.
 4F0  2FB00                               STORE sB[CURSOR_LOW], 00[scratchLOW]
 4F1  2FA01                               STORE sA[CURSOR_HIGH], 01[scratchHIGH]
 4F2                     scroll_up_plain: 
 4F2  0BE1E                scroll_offset: FETCH sE, 1E[offset_low]
 4F3  0BF1F                               FETCH sF, 1F[offset_high]
 4F4  10ED0                               ADD sE, sD[CHAR_PER_LINE]
 4F5  13F00                               ADDCY sF, 00
 4F6  2FE1E                               STORE sE, 1E[offset_low]
 4F7  2FF1F                               STORE sF, 1F[offset_high]
 4F8  2DE0F                               OUTPUT sE, 0F[OFFSET_LSB_PORT]
 4F9  2DF0E                               OUTPUT sF, 0E[OFFSET_MSB_PORT]
 4FA                     clear_last_line: 
 4FA  0BB22                               FETCH sB[CURSOR_LOW], 22[LAST_LINE_LOWER]
 4FB  0BA23                               FETCH sA[CURSOR_HIGH], 23[LAST_LINE_UPPER]
 4FC                    clear_last_lines: 
 4FC  01500                               LOAD s5, 00
 4FD  0B020                               FETCH s0, 20[MAX_LINE_LOWER]
 4FE  0B121                               FETCH s1, 21[MAX_LINE_UPPER]
 4FF  200B0                   clear_loop: CALL 0B0[set_cursor]
 500  2D551                               OUTPUT s5, 51[EXTRA_PORT]
 501  2D504                               OUTPUT s5, 04[CHAR_PORT]
 502  2D609                               OUTPUT s6[COLOR_REG], 09[ATTR_PORT]
 503  11B01                               ADD sB[CURSOR_LOW], 01
 504  13A00                               ADDCY sA[CURSOR_HIGH], 00
 505  1CB00                               COMPARE sB[CURSOR_LOW], s0
 506  1EA10                               COMPARECY sA[CURSOR_HIGH], s1
 507  364FF                               JUMP NZ, 4FF[clear_loop]
 508                      done_scrolling: 
 508  0BB00                               FETCH sB[CURSOR_LOW], 00[scratchLOW]
 509  0BA01                               FETCH sA[CURSOR_HIGH], 01[scratchHIGH]
 50A  200B0                               CALL 0B0[set_cursor]
 50B  25000                               RETURN 
 50C                         scroll_down: 
 50C  2FB00                               STORE sB[CURSOR_LOW], 00[scratchLOW]
 50D  2FA01                               STORE sA[CURSOR_HIGH], 01[scratchHIGH]
 50E                  scroll_down_offset: 
 50E  0BE1E                               FETCH sE, 1E[offset_low]
 50F  0BF1F                               FETCH sF, 1F[offset_high]
 510  18ED0                               SUB sE, sD[CHAR_PER_LINE]
 511  1BF00                               SUBCY sF, 00
 512  2FE1E                               STORE sE, 1E[offset_low]
 513  2FF1F                               STORE sF, 1F[offset_high]
 514  2DE0F                               OUTPUT sE, 0F[OFFSET_LSB_PORT]
 515  2DF0E                               OUTPUT sF, 0E[OFFSET_MSB_PORT]
 516                    clear_first_line: 
 516  01B00                               LOAD sB[CURSOR_LOW], 00
 517  01A00                               LOAD sA[CURSOR_HIGH], 00
 518  01500                               LOAD s5, 00
 519                    clear_first_loop: 
 519  200B0                               CALL 0B0[set_cursor]
 51A  2D551                               OUTPUT s5, 51[EXTRA_PORT]
 51B  2D504                               OUTPUT s5, 04[CHAR_PORT]
 51C  2D609                               OUTPUT s6[COLOR_REG], 09[ATTR_PORT]
 51D  11B01                               ADD sB[CURSOR_LOW], 01
 51E  13A00                               ADDCY sA[CURSOR_HIGH], 00
 51F  1CBD0                               COMPARE sB[CURSOR_LOW], sD[CHAR_PER_LINE]
 520  1FA00                               COMPARECY sA[CURSOR_HIGH], 00
 521  36519                               JUMP NZ, 519[clear_first_loop]
 522                   done_scrolling_up: 
 522  0BB00                               FETCH sB[CURSOR_LOW], 00[scratchLOW]
 523  0BA01                               FETCH sA[CURSOR_HIGH], 01[scratchHIGH]
 524  200B0                               CALL 0B0[set_cursor]
 525  25000                               RETURN 
 526                  clear_current_line: 
 526  000D0                               LOAD s0, sD[CHAR_PER_LINE]
 527  01100                               LOAD s1, 00
 528                 clear_current_lines: 
 528  01500                               LOAD s5, 00
 529                     clear_line_loop: 
 529  200B0                               CALL 0B0[set_cursor]
 52A  2D551                               OUTPUT s5, 51[EXTRA_PORT]
 52B  2D504                               OUTPUT s5, 04[CHAR_PORT]
 52C  2D609                               OUTPUT s6[COLOR_REG], 09[ATTR_PORT]
 52D  11B01                               ADD sB[CURSOR_LOW], 01
 52E  13A00                               ADDCY sA[CURSOR_HIGH], 00
 52F  19001                               SUB s0, 01
 530  1B100                               SUBCY s1, 00
 531  1D000                               COMPARE s0, 00
 532  1F100                               COMPARECY s1, 00
 533  36529                               JUMP NZ, 529[clear_line_loop]
 534  0BB00                               FETCH sB[CURSOR_LOW], 00[scratchLOW]
 535  0BA01                               FETCH sA[CURSOR_HIGH], 01[scratchHIGH]
 536  200B0                               CALL 0B0[set_cursor]
 537  25000                               RETURN 
 538                           ring_bell: 
 538                                      ; RETURN ; uncomment this line to disable the bell ****
 538  2FB00                               STORE sB[CURSOR_LOW], 00[scratchLOW]
 539  2FA01                               STORE sA[CURSOR_HIGH], 01[scratchHIGH]
 53A  2F63D                               STORE s6[COLOR_REG], 3D[scratchX]
 53B  20543                               CALL 543[invert_screen]
 53C  205DC                               CALL 5DC[delay_100ms]                           ; this might be too long ****
 53D  20543                               CALL 543[invert_screen]
 53E  0BB00                               FETCH sB[CURSOR_LOW], 00[scratchLOW]
 53F  0BA01                               FETCH sA[CURSOR_HIGH], 01[scratchHIGH]
 540  0B63D                               FETCH s6[COLOR_REG], 3D[scratchX]
 541  200B0                               CALL 0B0[set_cursor]
 542  25000                               RETURN 
 543                       invert_screen: 
 543  01B00                               LOAD sB[CURSOR_LOW], 00
 544  01A00                               LOAD sA[CURSOR_HIGH], 00
 545                           bell_loop: 
 545  200B0                               CALL 0B0[set_cursor]
 546  0960A                               INPUT s6[COLOR_REG], 0A[ATTR_READ_PORT]
 547  2045A                               CALL 45A[invert_colors]
 548  2D609                               OUTPUT s6[COLOR_REG], 09[ATTR_PORT]
 549  11B01                               ADD sB[CURSOR_LOW], 01
 54A  13A00                               ADDCY sA[CURSOR_HIGH], 00
 54B  2054E                               CALL 54E[compare_cursor_max]
 54C  36545                               JUMP NZ, 545[bell_loop]
 54D  25000                               RETURN 
 54E                  compare_cursor_max: 
 54E  2F039                               STORE s0, 39[scratchT]
 54F  2F13A                               STORE s1, 3A[scratchU]
 550  0B020                               FETCH s0, 20[MAX_LINE_LOWER]
 551  0B121                               FETCH s1, 21[MAX_LINE_UPPER]
 552  1CB00                               COMPARE sB[CURSOR_LOW], s0
 553  1EA10                               COMPARECY sA[CURSOR_HIGH], s1
 554  0B039                               FETCH s0, 39[scratchT]
 555  0B13A                               FETCH s1, 3A[scratchU]
 556  25000                               RETURN 
 557                 compare_cursor_last: 
 557  2F039                               STORE s0, 39[scratchT]
 558  2F13A                               STORE s1, 3A[scratchU]
 559  0B022                               FETCH s0, 22[LAST_LINE_LOWER]
 55A  0B123                               FETCH s1, 23[LAST_LINE_UPPER]
 55B  1CB00                               COMPARE sB[CURSOR_LOW], s0
 55C  1EA10                               COMPARECY sA[CURSOR_HIGH], s1
 55D  0B039                               FETCH s0, 39[scratchT]
 55E  0B13A                               FETCH s1, 3A[scratchU]
 55F  25000                               RETURN 
 560                        test_pattern: ; dumps all 256 characters to the console in RAW mode.
 560  01500                               LOAD s5, 00
 561                           ascii_set: 
 561  2F536                               STORE s5, 36[scratchQ]
 562  200DC                               CALL 0DC[raw_char_out]
 563  0B536                               FETCH s5, 36[scratchQ]
 564  11501                               ADD s5, 01
 565  1D500                               COMPARE s5, 00
 566  31000                               RETURN Z
 567  22561                               JUMP 561[ascii_set]
 568                                      ; print_string:
 568                                      ; sends NULL terminated STRING to the HDMI character display
 568                                      ; string pointer is passed in s8s9
 568                                      ; returns with s8s9 pointing to NUL terminator at end of string
 568                                      ; does not affect other registers
 568  24890                 print_string: CALL@ (s8[DIVISOR_LOW], s9[DIVISOR_HIGH])
 569  1D500                               COMPARE s5, 00                                  ;terminate on NUL character
 56A  31000                               RETURN Z
 56B  2F800                               STORE s8[DIVISOR_LOW], 00[scratchLOW]
 56C  2F901                               STORE s9[DIVISOR_HIGH], 01[scratchHIGH]
 56D  200B8                               CALL 0B8[send_next]
 56E  0B800                               FETCH s8[DIVISOR_LOW], 00[scratchLOW]
 56F  0B901                               FETCH s9[DIVISOR_HIGH], 01[scratchHIGH]
 570  11901                               ADD s9[DIVISOR_HIGH], 01[1'd]
 571  13800                               ADDCY s8[DIVISOR_LOW], 00[0'd]
 572  22568                               JUMP 568[print_string]
 573                                      ; hex_byte
 573                                      ; echo the 8 bit value of s4 to the serial port in hexadecimal
 573                                      ; followed by a space (three characters total are sent)
 573                                      ; the s5 register is corrupted by this function
 573                            hex_byte: 
 573  00540                               LOAD s5, s4                                     ;isolate upper nibble
 574  1450E                               SR0 s5
 575  1450E                               SR0 s5
 576  1450E                               SR0 s5
 577  1450E                               SR0 s5
 578  20591                               CALL 591[hex_to_text]                           ; convert to ASCII
 579  20635                               CALL 635[UART_TX]                               ;send upper digit to UART
 57A  00540                               LOAD s5, s4                                     ;isolate lower nibble
 57B  0350F                               AND s5, 0F
 57C  20591                               CALL 591[hex_to_text]                           ; convert to ASCII
 57D  20635                               CALL 635[UART_TX]                               ;send lower digit to UART
 57E  25000                               RETURN 
 57F                                      ;
 57F                                      ; debug hex dumps a hex value in s4 to the character display
 57F                                      ;
 57F                           debug_hex: 
 57F  0157B                               LOAD s5, 7B["{"]
 580  200DC                               CALL 0DC[raw_char_out]
 581  20585                               CALL 585[print_hex]
 582  0157D                               LOAD s5, 7D["}"]
 583  200DC                               CALL 0DC[raw_char_out]
 584  25000                               RETURN 
 585                           print_hex: 
 585  00540                               LOAD s5, s4                                     ;isolate upper nibble
 586  1450E                               SR0 s5
 587  1450E                               SR0 s5
 588  1450E                               SR0 s5
 589  1450E                               SR0 s5
 58A  20591                               CALL 591[hex_to_text]                           ; convert to ASCII
 58B  200DC                               CALL 0DC[raw_char_out]
 58C  00540                               LOAD s5, s4                                     ;isolate lower nibble
 58D  0350F                               AND s5, 0F
 58E  20591                               CALL 591[hex_to_text]                           ; convert to ASCII
 58F  200DC                               CALL 0DC[raw_char_out]
 590  25000                               RETURN 
 591                                      ; Convert value 00 to 0F provided in 's5' into ASCII character in 's5'
 591                                      ; Register used s5
 591  1950A                  hex_to_text: SUB s5, 0A                                      ;test if value is in range 0 to 9
 592  3A594                               JUMP C, 594[number_to_char]
 593  11507                               ADD s5, 07                                      ;ASCII char A to F in range 41 to 46
 594  1153A               number_to_char: ADD s5, 3A                                      ;ASCII char 0 to 9 in range 30 to 40
 595  25000                               RETURN 
 596                                      STRING hello$, "QuackTerm V1.02  Mode "
 596                            debug_s4: 
 596  0153C                               LOAD s5, 3C["<"]
 597  200DC                               CALL 0DC[raw_char_out]
 598  2F400                               STORE s4, 00[scratchLOW]
 599  0B408                               FETCH s4, 08[param_block]
 59A  2057F                               CALL 57F[debug_hex]
 59B  0B400                               FETCH s4, 00[scratchLOW]
 59C  00540                               LOAD s5, s4
 59D  200DC                               CALL 0DC[raw_char_out]
 59E  0153E                               LOAD s5, 3E[">"]
 59F  200DC                               CALL 0DC[raw_char_out]
 5A0  25000                               RETURN 
 5A1                           debug_s4e: 
 5A1  0157B                               LOAD s5, 7B["{"]
 5A2  200DC                               CALL 0DC[raw_char_out]
 5A3  00540                               LOAD s5, s4
 5A4  200DC                               CALL 0DC[raw_char_out]
 5A5  0157D                               LOAD s5, 7D["}"]
 5A6  200DC                               CALL 0DC[raw_char_out]
 5A7  25000                               RETURN 
 5A8  21551                    hello_msg: LOAD&RETURN s5, 51[hello$:"Q"]
 5A9  21575                               LOAD&RETURN s5, 75[hello$:"u"]
 5AA  21561                               LOAD&RETURN s5, 61[hello$:"a"]
 5AB  21563                               LOAD&RETURN s5, 63[hello$:"c"]
 5AC  2156B                               LOAD&RETURN s5, 6B[hello$:"k"]
 5AD  21554                               LOAD&RETURN s5, 54[hello$:"T"]
 5AE  21565                               LOAD&RETURN s5, 65[hello$:"e"]
 5AF  21572                               LOAD&RETURN s5, 72[hello$:"r"]
 5B0  2156D                               LOAD&RETURN s5, 6D[hello$:"m"]
 5B1  21520                               LOAD&RETURN s5, 20[hello$:" "]
 5B2  21556                               LOAD&RETURN s5, 56[hello$:"V"]
 5B3  21531                               LOAD&RETURN s5, 31[hello$:"1"]
 5B4  2152E                               LOAD&RETURN s5, 2E[hello$:"."]
 5B5  21530                               LOAD&RETURN s5, 30[hello$:"0"]
 5B6  21532                               LOAD&RETURN s5, 32[hello$:"2"]
 5B7  21520                               LOAD&RETURN s5, 20[hello$:" "]
 5B8  21520                               LOAD&RETURN s5, 20[hello$:" "]
 5B9  2154D                               LOAD&RETURN s5, 4D[hello$:"M"]
 5BA  2156F                               LOAD&RETURN s5, 6F[hello$:"o"]
 5BB  21564                               LOAD&RETURN s5, 64[hello$:"d"]
 5BC  21565                               LOAD&RETURN s5, 65[hello$:"e"]
 5BD  21520                               LOAD&RETURN s5, 20[hello$:" "]
 5BE                                      ;LOAD&RETURN s5, CR
 5BE  21500                               LOAD&RETURN s5, 00[NUL]
 5BF                 get_row_column_plus: 
 5BF  002B0                               LOAD s2[DIVIDEND_LOW], sB[CURSOR_LOW]
 5C0  003A0                               LOAD s3[DIVIDEND_HIGH], sA[CURSOR_HIGH]
 5C1  11201                               ADD s2[DIVIDEND_LOW], 01
 5C2  13300                               ADDCY s3[DIVIDEND_HIGH], 00
 5C3  225C6                               JUMP 5C6[finish_row_column]
 5C4                      get_row_column: ;returns the ROW in DIVIDEND_LOW and the COLUMN in sE
 5C4  002B0                               LOAD s2[DIVIDEND_LOW], sB[CURSOR_LOW]
 5C5  003A0                               LOAD s3[DIVIDEND_HIGH], sA[CURSOR_HIGH]
 5C6                   finish_row_column: 
 5C6  009D0                               LOAD s9[DIVISOR_HIGH], sD[CHAR_PER_LINE]
 5C7  01800                               LOAD s8[DIVISOR_LOW], 00
 5C8  225C9                               JUMP 5C9[divide_16bit_by_any]                   ; sE is now the line (column) position
 5C9                                      ; parasitic RETURN
 5C9                                      ; Divide 16-bit binary integer
 5C9                                      ;
 5C9                                      ; The value to be divided by should be provided in register set [DIVIDEND_HIGH,DIVIDEND_LOW].
 5C9                                      ; The divisor should be placed in DIVISOR_LOW,DIVISOR_HIGH
 5C9                                      ; The routine will return the integer result [DIVIDEND_HIGH,s2]/80 back in[DIVIDEND_HIGH,DIVIDEND_LOW]
 5C9                                      ; with any remainder in register sE.
 5C9                                      ; Registers used s0,DIVIDEND_LOW,DIVIDEND_HIGH,DIVISOR_LOW,DIVISOR_HIGH,sE,sF
 5C9                                      ;
 5C9                                      ; NOTE: this is NOT a general purpose divide function. It only works for a narrow range of values.
 5C9                                      ;
 5C9  00E20          divide_16bit_by_any: LOAD sE, s2[DIVIDEND_LOW]                       ;copy input value into [CURSOR_LOW,sA]
 5CA  00F30                               LOAD sF, s3[DIVIDEND_HIGH]
 5CB  01200                               LOAD s2[DIVIDEND_LOW], 00                       ;clear division result
 5CC  01300                               LOAD s3[DIVIDEND_HIGH], 00
 5CD  01009                               LOAD s0, 09[9'd]                                ;9 subtract and shift iterations to be performed (0x50 uses 7 bits for a total of 16)
 5CE                                      ; a general purpose subtract function would perform all 16 shifts and would have the
 5CE                                      ; 8-bit divisor loaded straight into s8 with s9 being 00 (the MSB)
 5CE  18E80                     div_loop: SUB sE, s8[DIVISOR_LOW]                         ;perform 16-bit subtract [CURSOR_LOW,sA]-[DIVISOR_HIGH,DIVISOR_LOW]
 5CF  1AF90                               SUBCY sF, s9[DIVISOR_HIGH]
 5D0  3A5D3                               JUMP C, 5D3[div_restore]                        ;if carry then could not subtract from total
 5D1  14207                               SL1 s2[DIVIDEND_LOW]                            ;shift '1' into result because subtract ok
 5D2  225D6                               JUMP 5D6[div_shifts]
 5D3  10E80                  div_restore: ADD sE, s8[DIVISOR_LOW]                         ;perform 16-bit addition [CURSOR_LOW,sA]+[DIVISOR_HIGH,DIVISOR_LOW]
 5D4  12F90                               ADDCY sF, s9[DIVISOR_HIGH]                      ;to restore total
 5D5  14206                               SL0 s2[DIVIDEND_LOW]                            ;shift '0' into result because could no subtract
 5D6  14300                   div_shifts: SLA s3[DIVIDEND_HIGH]                           ;complete 16-bit shift left into [DIVIDEND_HIGH,s2]
 5D7  1490E                               SR0 s9[DIVISOR_HIGH]                            ;divide '10' value by 2 (shift right 1 place)
 5D8  14808                               SRA s8[DIVISOR_LOW]
 5D9  19001                               SUB s0, 01                                      ;count iterations
 5DA  31000                               RETURN Z                                        ;on return the remainder of division is in sA
 5DB  225CE                               JUMP 5CE[div_loop]
 5DC                                      ; delay for one second
 5DC                                      ;1s is 50,000,000 clock cycles requiring 6,250,000 delay iterations
 5DC                                      ; (5F5E10)
 5DC                                      ;          delay_1s: LOAD DIVIDEND_LOW, 5F
 5DC                                      ;                    LOAD s1, 5E
 5DC                                      ;                    LOAD s0, 10
 5DC                                      ;                    JUMP software_delay
 5DC                                      ;
 5DC                                      ; The delay loop decrements [DIVIDEND_LOW,s1,s0] until it reaches zero
 5DC                                      ; Each decrement cycle is 4 instructions which is 8 clock cycles (160ns at 50MHz)
 5DC                                      ; 100 milliseconds is 0x98968
 5DC                                      ;
 5DC                                      ;
 5DC                         delay_100ms: 
 5DC  01209                               LOAD s2[DIVIDEND_LOW], 09
 5DD  01189                               LOAD s1, 89
 5DE  01068                               LOAD s0, 68
 5DF  225E0                               JUMP 5E0[software_delay]
 5E0                                      ; 2 ms is 2 milliseconds, requiring
 5E0                                      ; 12,500 delay iterations (0030D4)
 5E0                                      ; 4  ms is 61A8
 5E0                                      ;
 5E0                                      ; delay_4ms:
 5E0                                      ;   LOAD DIVIDEND_LOW, 00
 5E0                                      ;   LOAD s1, 61
 5E0                                      ;   LOAD s0, A8
 5E0                                      ;   JUMP software_delay
 5E0                                      ;
 5E0  19001               software_delay: SUB s0, 01[1'd]
 5E1  1B100                               SUBCY s1, 00[0'd]
 5E2  1B200                               SUBCY s2[DIVIDEND_LOW], 00[0'd]
 5E3  365E0                               JUMP NZ, 5E0[software_delay]
 5E4  25000                               RETURN 
 5E5                                      ; Multiplier Routine (8-bit x 8-bit = 16-bit product)
 5E5                                      ; ==================================================
 5E5                                      ; Shift and add algorithm
 5E5                                      ;
 5E5                            mult_8x8: 
 5E5                                      NAMEREG DIVISOR_LOW, multiplicand               ; preserved
 5E5                                      NAMEREG DIVISOR_HIGH, multiplier                ; preserved
 5E5                                      NAMEREG DIVIDEND_LOW, bit_mask                  ; modified
 5E5                                      NAMEREG DIVIDEND_HIGH, result_msb               ; most-significant byte (MSB) of result, modified
 5E5                                      NAMEREG s4, result_lsb                          ; least-significant byte (LSB) of result, modified
 5E5                                      ;
 5E5  01201                               LOAD s2[bit_mask], 01                           ; start with least-significant bit (lsb)
 5E6  01300                               LOAD s3[result_msb], 00                         ; clear product MSB
 5E7  01400                               LOAD s4[result_lsb], 00                         ; clear product LSB (not required)
 5E8                                      ;
 5E8                                      ; loop through all bits in multiplier
 5E8                           mult_loop: 
 5E8  0C920                               TEST s9[multiplier], s2[bit_mask]               ; check if bit is set
 5E9  325EB                               JUMP Z, 5EB[no_add]                             ; if bit is not set, skip addition
 5EA                                      ;
 5EA  10380                               ADD s3[result_msb], s8[multiplicand]            ; addition only occurs in MSB
 5EB                                      ;
 5EB  14308                       no_add: SRA s3[result_msb]                              ; shift MSB right, CARRY into bit 7,
 5EC                                      ; lsb into CARRY
 5EC  14408                               SRA s4[result_lsb]                              ; shift LSB right,
 5ED                                      ; lsb from result_msb into bit 7
 5ED                                      ;
 5ED  14206                               SL0 s2[bit_mask]                                ; shift bit_mask left to examine
 5EE                                      ; next bit in multiplier
 5EE                                      ;
 5EE  365E8                               JUMP NZ, 5E8[mult_loop]                         ; if all bit examined, then bit_mask = 0
 5EF  25000                               RETURN 
 5F0                                      ;
 5F0                                      ; the following code uses normal register names, it's taken from the Xilinx example more or less
 5F0                                      ; so we use NAMEREG to restore our registers to their original names more or less
 5F0                                      NAMEREG multiplicand, DIVISOR_LOW
 5F0                                      NAMEREG multiplier, DIVISOR_HIGH
 5F0                                      NAMEREG bit_mask, s2
 5F0                                      NAMEREG result_msb, s3
 5F0                                      NAMEREG result_lsb, s4
 5F0                                      NAMEREG COLOR_REG, s6
 5F0                                      NAMEREG CURSOR_LOW, sB
 5F0                                      NAMEREG CURSOR_HIGH, sA
 5F0                                      NAMEREG DIVISOR_LOW, s8
 5F0                                      NAMEREG DIVISOR_HIGH, s9
 5F0                                      ;
 5F0                                      ; sends a 16 bit integer value in s2s3 to the serial port in decimal format.
 5F0                                      ;
 5F0                                      ;;
 5F0  1D200                 send_integer: COMPARE s2, 00                                  ;test for special case of zero
 5F1  1F300                               COMPARECY s3, 00
 5F2  32600                               JUMP Z, 600[zero_integer]
 5F3                                      ;
 5F3  20616                               CALL 616[integer16_to_BCD]                      ;Convert to BCD in SPM
 5F4                                      ;
 5F4  01E06                               LOAD sE, 06[decimal4]                           ;pointer to BCD in SPM
 5F5  01F00                               LOAD sF, 00[0'd]                                ;flag for leading zero blanking
 5F6  0A5E0            send_integer_loop: FETCH s5, (sE)
 5F7  10F50                               ADD sF, s5                                      ;make sF non-zero to stop blanking
 5F8  1DF00                               COMPARE sF, 00[0'd]                             ;Test for blanking
 5F9  325FC                               JUMP Z, 5FC[next_int_digit]
 5FA  11530                               ADD s5, 30["0"]                                 ;convert to ASCII
 5FB  20635                               CALL 635[UART_TX]                               ;send digit
 5FC  1DE02               next_int_digit: COMPARE sE, 02[decimal0]
 5FD  31000                               RETURN Z
 5FE  19E01                               SUB sE, 01[1'd]                                 ;move pointer to next digit
 5FF  225F6                               JUMP 5F6[send_integer_loop]
 600                                      ;
 600  01530                 zero_integer: LOAD s5, 30["0"]                                ;special response for zero
 601  20635                               CALL 635[UART_TX]
 602  25000                               RETURN 
 603                       print_integer: 
 603  1D200                               COMPARE s2, 00                                  ;test for special case of zero
 604  1F300                               COMPARECY s3, 00
 605  32613                               JUMP Z, 613[zero_printeger]
 606  20616                               CALL 616[integer16_to_BCD]                      ;Convert to BCD in SPM
 607  01E06                               LOAD sE, 06[decimal4]                           ;pointer to BCD in SPM
 608  01F00                               LOAD sF, 00[0'd]                                ;flag for leading zero blanking
 609                  print_integer_loop: 
 609  0A5E0                               FETCH s5, (sE)
 60A  10F50                               ADD sF, s5                                      ;make sF non-zero to stop blanking
 60B  1DF00                               COMPARE sF, 00[0'd]                             ;Test for blanking
 60C  3260F                               JUMP Z, 60F[next_print_digit]
 60D  11530                               ADD s5, 30["0"]                                 ;convert to ASCII
 60E  200B8                               CALL 0B8[send_next]
 60F                    next_print_digit: 
 60F  1DE02                               COMPARE sE, 02[decimal0]
 610  31000                               RETURN Z
 611  19E01                               SUB sE, 01[1'd]                                 ;move pointer to next digit
 612  22609                               JUMP 609[print_integer_loop]
 613                      zero_printeger: 
 613  01530                               LOAD s5, 30["0"]                                ;special response for zero
 614  200B8                               CALL 0B8[send_next]
 615  25000                               RETURN 
 616  01402             integer16_to_BCD: LOAD s4, 02[decimal0]                           ;pointer for LS-Digit in scratch pad memory
 617  2061D              int_to_BCD_loop: CALL 61D[divide_16bit_by_10]
 618  2EE40                               STORE sE, (s4)                                  ;remainder is the digit value
 619  1D406                               COMPARE s4, 06[decimal4]                        ;test for MS-Digit completed
 61A  31000                               RETURN Z
 61B  11401                               ADD s4, 01[1'd]                                 ;advance pointer to next digit
 61C  22617                               JUMP 617[int_to_BCD_loop]
 61D                                      ;
 61D                                      ; Divide 16-bit binary integer by 10
 61D                                      ;
 61D                                      ; The value to be divided by 10 should be provided in register set [s3,s2].
 61D                                      ; The routine will return the integer result [s3,s2]/10 back in[s3,s2]
 61D                                      ; with any remainder in (0 to 9) in register sA.
 61D                                      ;
 61D                                      ; Registers used s0,s2,s3,s8,s9,sA,sB
 61D                                      ;
 61D  00E20           divide_16bit_by_10: LOAD sE, s2                                     ;copy input value into [sB,sA]
 61E  00F30                               LOAD sF, s3
 61F  01200                               LOAD s2, 00                                     ;clear division result
 620  01300                               LOAD s3, 00
 621  019A0                               LOAD s9, A0                                     ;initialise [s9,s8] with '10' in MSBs
 622  01800                               LOAD s8, 00
 623  0100D                               LOAD s0, 0D[13'd]                               ;13 subtract and shift iterations to be performed
 624  18E80                   div10_loop: SUB sE, s8                                      ;perform 16-bit subtract [sB,sA]-[s9,s8]
 625  1AF90                               SUBCY sF, s9
 626  3A629                               JUMP C, 629[div10_restore]                      ;if carry then could not subtract from total
 627  14207                               SL1 s2                                          ;shift '1' into result because subtract ok
 628  2262C                               JUMP 62C[div10_shifts]
 629  10E80                div10_restore: ADD sE, s8                                      ;perform 16-bit addition [sB,sA]+[s9,s8]
 62A  12F90                               ADDCY sF, s9                                    ;to restore total
 62B  14206                               SL0 s2                                          ;shift '0' into result because could no subtract
 62C  14300                 div10_shifts: SLA s3                                          ;complete 16-bit shift left into [s3,s2]
 62D  1490E                               SR0 s9                                          ;divide '10' value by 2 (shift right 1 place)
 62E  14808                               SRA s8
 62F  19001                               SUB s0, 01                                      ;count iterations
 630  31000                               RETURN Z                                        ;on return the remainder of division is in sA
 631  22624                               JUMP 624[div10_loop]
 632                                      CONSTANT UART_status_port, 00                   ; Read status
 632                                      CONSTANT UART_Tx_full, 00000100'b               ; full - bit2
 632                                      CONSTANT UART_TX6_output_port, 01
 632                                      CONSTANT reset_UART_port, 01
 632                                      CONSTANT UART_reset, 00000011'b                 ; reset Tx and Rx
 632                                      CONSTANT UART_operate, 00000000'b               ; Tx and Rx free to operate
 632                   reset_UART_macros: 
 632  2B031                               OUTPUTK 03[UART_reset], 1[reset_UART_port]
 633  2B001                               OUTPUTK 00[UART_operate], 1[reset_UART_port]
 634  25000                               RETURN 
 635                             UART_TX: 
 635  09000                               INPUT s0, 00[UART_status_port]                  ;Check if buffer is full
 636  0D004                               TEST s0, 04[UART_Tx_full]
 637  36635                               JUMP NZ, 635[UART_TX]                           ;wait if full
 638  2D501                               OUTPUT s5, 01[UART_TX6_output_port]
 639  25000                               RETURN 
 63A                                      ; End of Program


All unused memory locations contain zero (equivalent to 'LOAD s0, s0')



List of PSM files that have been assembled

C:\Users\equack\Documents\Xilinx\DVI-1080p\dvid_test_hd\PicoBlaze\quackterm.psm



List of defined constants

 CONSTANT name           Value        Source PSM File

 timestamp_hours         16'd         
 timestamp_minutes       13'd         
 timestamp_seconds       31'd         
 datestamp_year          17'd         
 datestamp_month         5'd          
 datestamp_day           22'd         
 NUL                     00           
 BEL                     07           
 BS                      08           
 HT                      09           
 LF                      0A           
 VT                      0B           
 CR                      0D           
 ESC                     1B           
 DEL                     7F           
 DCS                     90           
 ST                      9C           
 scratchLOW              00           quackterm.psm
 scratchHIGH             01           quackterm.psm
 decimal0                02           quackterm.psm
 decimal1                03           quackterm.psm
 decimal2                04           quackterm.psm
 decimal3                05           quackterm.psm
 decimal4                06           quackterm.psm
 param_counter           07           quackterm.psm
 param_block             08           quackterm.psm
 param_two               09           quackterm.psm
 max_param               10           quackterm.psm
 digit_counter           11           quackterm.psm
 digit_block             12           quackterm.psm
 max_digit               05           quackterm.psm
 RAM_17                  17           quackterm.psm
 RAM_18                  18           quackterm.psm
 RAM_19                  19           quackterm.psm
 RAM_1A                  1A           quackterm.psm
 RAM_1B                  1B           quackterm.psm
 RAM_1C                  1C           quackterm.psm
 RAM_1D                  1D           quackterm.psm
 offset_low              1E           quackterm.psm
 offset_high             1F           quackterm.psm
 MAX_LINE_LOWER          20           quackterm.psm
 MAX_LINE_UPPER          21           quackterm.psm
 LAST_LINE_LOWER         22           quackterm.psm
 LAST_LINE_UPPER         23           quackterm.psm
 video_mode              2F           quackterm.psm
 mode_flags              30           quackterm.psm
 last_char               31           quackterm.psm
 saved_cursor_low        32           quackterm.psm
 saved_cursor_high       33           quackterm.psm
 saved_color_reg         34           quackterm.psm
 saved_ansi_reg          35           quackterm.psm
 scratchQ                36           quackterm.psm
 scratchR                37           quackterm.psm
 scratchS                38           quackterm.psm
 scratchT                39           quackterm.psm
 scratchU                3A           quackterm.psm
 scratchV                3B           quackterm.psm
 scratchW                3C           quackterm.psm
 scratchX                3D           quackterm.psm
 scratchY                3E           quackterm.psm
 scratchZ                3F           quackterm.psm
 VIDEO_TALL              01           quackterm.psm
 VIDEO_EIGHTY            02           quackterm.psm
 VIDEO_FIFTY             04           quackterm.psm
 CURSOR_BLOCK            08           quackterm.psm
 CURSOR_HIDDEN           10           quackterm.psm
 CURSOR_BLOCK_CLR        F7           quackterm.psm
 CURSOR_HIDDEN_CLR       EF           quackterm.psm
 MODE_ALTERNATE_FONT     01           quackterm.psm
 MODE_UNDERLINE          02           quackterm.psm
 MODE_04                 04           quackterm.psm
 MODE_08                 08           quackterm.psm
 MODE_10                 10           quackterm.psm
 MODE_SET_FONT           20           quackterm.psm
 MODE_META               40           quackterm.psm
 MODE_LOCAL              80           quackterm.psm
 MODE_ALTERNATE_FONT_CLR FE           quackterm.psm
 MODE_UNDERLINE_CLR      FD           quackterm.psm
 MODE_SET_FONT_CLR       DF           quackterm.psm
 MODE_META_CLR           BF           quackterm.psm
 MODE_LOCAL_CLR          7F           quackterm.psm
 MSB_PORT                02           quackterm.psm
 LSB_PORT                03           quackterm.psm
 CHAR_PORT               04           quackterm.psm
 CHAR_READ_PORT          05           quackterm.psm
 ATTR_PORT               09           quackterm.psm
 ATTR_READ_PORT          0A           quackterm.psm
 MODE_PORT               0B           quackterm.psm
 UART_STATUS_PORT        0C           quackterm.psm
 UART_READ_FIFO_PORT     0D           quackterm.psm
 KEYBOARD_FIFO_PORT      40           quackterm.psm
 KEYBOARD_STATUS_PORT    41           quackterm.psm
 EXTRA_READ_PORT         50           quackterm.psm
 EXTRA_PORT              51           quackterm.psm
 FIFO_EMPTY              01           quackterm.psm
 FIFO_FULL               02           quackterm.psm
 OFFSET_MSB_PORT         0E           quackterm.psm
 OFFSET_LSB_PORT         0F           quackterm.psm
 ANSI_CSI                01           quackterm.psm
 ANSI_ESCAPE             02           quackterm.psm
 ANSI_ESC_CSI            03           quackterm.psm
 ANSI_INVERSE            04           quackterm.psm
 ANSI_HIDDEN             08           quackterm.psm
 ANSI_SSG2               10           quackterm.psm
 ANSI_DEBUG              20           quackterm.psm
 ANSI_VT_GRAPHICS        40           quackterm.psm
 ANSI_SSG3               80           quackterm.psm
 ANSI_SSG                90           quackterm.psm
 ANSI_CSI_CLR            FE           quackterm.psm
 ANSI_ESCAPE_CLR         FD           quackterm.psm
 ANSI_INVERSE_CLR        FB           quackterm.psm
 ANSI_HIDDEN_CLR         F7           quackterm.psm
 ANSI_SSG2_CLR           EF           quackterm.psm
 ANSI_DEBUG_CLR          DF           quackterm.psm
 ANSI_VT_GRAPHICS_CLR    BF           quackterm.psm
 ANSI_SSG3_CLR           7F           quackterm.psm
 ENQ_CHAR                05           quackterm.psm
 ACK_CHAR                06           quackterm.psm
 BEL_CHAR                07           quackterm.psm
 TAB_CHAR                09           quackterm.psm
 VT_CHAR                 0B           quackterm.psm
 FORM_FEED_CHAR          0C           quackterm.psm
 ESC_CHAR                1B           quackterm.psm
 RUBOUT_CHAR             7F           quackterm.psm
 META_CHAR               9E           quackterm.psm
 META_PLAIN              73           quackterm.psm
 META_SHIFT              53           quackterm.psm
 META_CONTROL            13           quackterm.psm
 META_ALT                F3           quackterm.psm
 META_CONTROL_ALT        93           quackterm.psm
 META_SHIFT_ALT          D3           quackterm.psm
 META_CONTROL_SHIFT      24           quackterm.psm
 META_CONTROL_ALT_SHIFT  A4           quackterm.psm
 UART_status_port        00           quackterm.psm
 UART_Tx_full            00000100'b   quackterm.psm
 UART_TX6_output_port    01           quackterm.psm
 reset_UART_port         01           quackterm.psm
 UART_reset              00000011'b   quackterm.psm
 UART_operate            00000000'b   quackterm.psm



No TABLEs defined



List of text strings

 STRING name       String                    Source PSM File

 KCPSM6_version$   "v2.70"                   
 datestamp$        "22 May 2017"             
 timestamp$        "16:13:31"                
 hello$            "QuackTerm V1.02  Mode "  quackterm.psm



List of line labels

   Label                         Addr  Source PSM File

 * cold_start                    000   quackterm.psm
   init_terminal                 002   quackterm.psm
   init_mode                     007   quackterm.psm
 * soft_boot                     016   quackterm.psm
   color_loop                    02D   quackterm.psm
   set_maximums                  038   quackterm.psm
   echo_loop                     042   quackterm.psm
   UART_FIFO_RX                  04A   quackterm.psm
   UART_TIMEOUT                  04B   quackterm.psm
   read_fifo_Rx                  051   quackterm.psm
   KEYBOARD_FIFO_RX              055   quackterm.psm
   KEYBOARD_TIMEOUT              056   quackterm.psm
   keyboard_rx                   05C   quackterm.psm
   KEYBOARD_CHECK                060   quackterm.psm
   meta_command                  06A   quackterm.psm
   meta_next                     077   quackterm.psm
   mode_next                     07B   quackterm.psm
   vmode_set                     07E   quackterm.psm
 * video_0                       080   quackterm.psm
   video_1                       085   quackterm.psm
   video_2                       08A   quackterm.psm
   video_3                       08F   quackterm.psm
   video_4                       094   quackterm.psm
   video_5                       099   quackterm.psm
   video_6                       09E   quackterm.psm
   video_7                       0A3   quackterm.psm
   KEYBOARD_TX                   0A6   quackterm.psm
   decrement_cursor              0AB   quackterm.psm
   advance_cursor                0AE   quackterm.psm
   set_cursor                    0B0   quackterm.psm
   hide_cursor                   0B3   quackterm.psm
   send_next                     0B8   quackterm.psm
   not_stored                    0BE   quackterm.psm
 * control_character             0C8   quackterm.psm
   raw_char_out                  0DC   quackterm.psm
   raw_vt_graphics               0E0   quackterm.psm
 * check_lower_alpha             0E2   quackterm.psm
 * VT_graphic                    0E7   quackterm.psm
   VT_shift                      0EB   quackterm.psm
   raw_output                    0ED   quackterm.psm
   escape_received               0F9   quackterm.psm
   escape_sequence               0FB   quackterm.psm
   not_csi                       100   quackterm.psm
 * save_cursor                   100   quackterm.psm
   restore_cursor                107   quackterm.psm
   RSI                           10F   quackterm.psm
   SSG2                          115   quackterm.psm
   clear_alternate_keypad        119   quackterm.psm
   set_font                      11C   quackterm.psm
   set_VT100                     122   quackterm.psm
   clear_VT100                   12D   quackterm.psm
   set_alternate_font            133   quackterm.psm
   set_alternate_graphics        139   quackterm.psm
   set_video_mode                13F   quackterm.psm
   unknown_escape                147   quackterm.psm
   end_csi                       147   quackterm.psm
   parse_csi_init                149   quackterm.psm
 * start_clear                   14D   quackterm.psm
   clear_params                  14F   quackterm.psm
   parse_csi_digit               154   quackterm.psm
 * process_digit                 159   quackterm.psm
   not_a_digit                   160   quackterm.psm
 * check_semicolon               161   quackterm.psm
   check_question_mark           164   quackterm.psm
   csi_scroll_up                 167   quackterm.psm
   scroll_up_loop                16D   quackterm.psm
   csi_scroll_down               174   quackterm.psm
   scroll_down_loop              17A   quackterm.psm
   csi_set_mode                  17F   quackterm.psm
 * cursor_visible                186   quackterm.psm
   block_cursor                  18B   quackterm.psm
   csi_reset_mode                190   quackterm.psm
 * cursor_hidden                 197   quackterm.psm
   underline_cursor              19C   quackterm.psm
   csi_delete_line               1A1   quackterm.psm
   delete_line_0                 1AA   quackterm.psm
   delete_line_1                 1AE   quackterm.psm
 * delete_line_2                 1AE   quackterm.psm
   delete_line_loop              1BA   quackterm.psm
 * end_delete_line_loop          1CB   quackterm.psm
   csi_insert_line               1D4   quackterm.psm
   insert_line_0                 1DD   quackterm.psm
   insert_line_1                 1E3   quackterm.psm
   insert_scroll                 1E6   quackterm.psm
   insert_line_2                 1EA   quackterm.psm
   insert_line_loop              1FC   quackterm.psm
   csi_erase_char                210   quackterm.psm
   erase_char_loop               219   quackterm.psm
   csi_insert_char               224   quackterm.psm
   insert_loop                   22A   quackterm.psm
   insert_next                   234   quackterm.psm
   csi_delete_char               24B   quackterm.psm
   delete_loop                   251   quackterm.psm
   delete_next                   256   quackterm.psm
   csi_clear                     271   quackterm.psm
   partial_clear                 278   quackterm.psm
   end_clear                     27C   quackterm.psm
   csi_sgr                       27E   quackterm.psm
   sgr_param                     283   quackterm.psm
 * sgr_reset                     284   quackterm.psm
   sgr_bold                      28D   quackterm.psm
   sgr_underline                 295   quackterm.psm
   sgr_blink                     29B   quackterm.psm
   sgr_inverse                   2A3   quackterm.psm
   sgr_hidden                    2AA   quackterm.psm
   sgr_default_font              2AE   quackterm.psm
   sgr_vt_graphics_font          2B5   quackterm.psm
   sgr_alternate_font            2BC   quackterm.psm
   sgr_alternate_graphics_font   2C3   quackterm.psm
   sgr_reveal                    2CA   quackterm.psm
   sgr_normal_intensity          2CE   quackterm.psm
   sgr_underline_off             2D6   quackterm.psm
   sgr_blink_off                 2DC   quackterm.psm
   sgr_positive                  2E4   quackterm.psm
   sgr_default_foreground        2EB   quackterm.psm
   sgr_default_background        2F4   quackterm.psm
   sgr_foreground                2FC   quackterm.psm
   sgr_background                30F   quackterm.psm
   sgr_other                     31E   quackterm.psm
   sgr_next                      31E   quackterm.psm
 * sgr_end                       321   quackterm.psm
   csi_move                      322   quackterm.psm
   csi_move2                     326   quackterm.psm
   two_params                    32B   quackterm.psm
   move_y0                       330   quackterm.psm
   move_y00                      334   quackterm.psm
   move_x0                       33E   quackterm.psm
   move_x00                      342   quackterm.psm
   csi_set_row                   346   quackterm.psm
   row_0                         34C   quackterm.psm
   row_00                        350   quackterm.psm
   csi_set_column                35C   quackterm.psm
   column_0                      362   quackterm.psm
   column_00                     366   quackterm.psm
   csi_repeat                    372   quackterm.psm
   repeat_loop                   37B   quackterm.psm
   csi_clear_line                384   quackterm.psm
 * clear_whole_line              38E   quackterm.psm
   clear_sol                     395   quackterm.psm
   clear_sol_loop                396   quackterm.psm
   clear_eol                     39F   quackterm.psm
   clear_eol_loop                3A7   quackterm.psm
   finish_clear_line             3AE   quackterm.psm
   csi_up                        3B2   quackterm.psm
   up_loop                       3B8   quackterm.psm
   csi_down                      3BC   quackterm.psm
   down_loop                     3C2   quackterm.psm
   csi_right                     3C6   quackterm.psm
   one_right                     3CD   quackterm.psm
   csi_left                      3D4   quackterm.psm
   one_left                      3DB   quackterm.psm
   csi_back_tab                  3E2   quackterm.psm
   back_tab_loop                 3E8   quackterm.psm
   csi_tab                       3EF   quackterm.psm
   tab_loop                      3F5   quackterm.psm
   csi_device_status_report      3FC   quackterm.psm
 * send_position_report          401   quackterm.psm
   DSR_other                     41B   quackterm.psm
   csi_margins                   41C   quackterm.psm
   csi_tilde                     41F   quackterm.psm
 * check_home                    422   quackterm.psm
   check_insert                  426   quackterm.psm
   check_delete                  42B   quackterm.psm
   check_end                     430   quackterm.psm
   check_pgup                    434   quackterm.psm
   check_pgdn                    438   quackterm.psm
   unknown_command               43C   quackterm.psm
   exit_escape                   43C   quackterm.psm
   end_param                     43F   quackterm.psm
   do_digit                      444   quackterm.psm
   end_digits                    450   quackterm.psm
   invert_colors                 45A   quackterm.psm
   enquiry                       467   quackterm.psm
   backspace                     46A   quackterm.psm
   rubout                        472   quackterm.psm
   htab                          476   quackterm.psm
   backtab                       47D   quackterm.psm
   full_back                     487   quackterm.psm
   left_cursor                   48A   quackterm.psm
   right_cursor                  490   quackterm.psm
   line_up                       496   quackterm.psm
   line_down                     49D   quackterm.psm
   line_feed                     4A3   quackterm.psm
   clear_start_screen            4A9   quackterm.psm
   clear_backward                4AC   quackterm.psm
   form_feed                     4BB   quackterm.psm
   clear_end_screen              4BD   quackterm.psm
   clear_a_char                  4C2   quackterm.psm
   home_cursor                   4CF   quackterm.psm
   set_origin                    4D6   quackterm.psm
   end_cursor                    4DA   quackterm.psm
   end_of_line                   4DE   quackterm.psm
   CRLF                          4E4   quackterm.psm
   carriage_return               4E6   quackterm.psm
   cr_leftedge                   4E8   quackterm.psm
 * cr_regadjust                  4EC   quackterm.psm
   cr_scroll_up                  4EE   quackterm.psm
   scroll_up                     4F0   quackterm.psm
   scroll_up_plain               4F2   quackterm.psm
 * scroll_offset                 4F2   quackterm.psm
   clear_last_line               4FA   quackterm.psm
   clear_last_lines              4FC   quackterm.psm
   clear_loop                    4FF   quackterm.psm
 * done_scrolling                508   quackterm.psm
   scroll_down                   50C   quackterm.psm
   scroll_down_offset            50E   quackterm.psm
 * clear_first_line              516   quackterm.psm
   clear_first_loop              519   quackterm.psm
 * done_scrolling_up             522   quackterm.psm
 * clear_current_line            526   quackterm.psm
   clear_current_lines           528   quackterm.psm
   clear_line_loop               529   quackterm.psm
   ring_bell                     538   quackterm.psm
   invert_screen                 543   quackterm.psm
   bell_loop                     545   quackterm.psm
   compare_cursor_max            54E   quackterm.psm
   compare_cursor_last           557   quackterm.psm
 * test_pattern                  560   quackterm.psm
   ascii_set                     561   quackterm.psm
   print_string                  568   quackterm.psm
 * hex_byte                      573   quackterm.psm
   debug_hex                     57F   quackterm.psm
   print_hex                     585   quackterm.psm
   hex_to_text                   591   quackterm.psm
   number_to_char                594   quackterm.psm
 * debug_s4                      596   quackterm.psm
 * debug_s4e                     5A1   quackterm.psm
   hello_msg                     5A8   quackterm.psm
   get_row_column_plus           5BF   quackterm.psm
   get_row_column                5C4   quackterm.psm
   finish_row_column             5C6   quackterm.psm
   divide_16bit_by_any           5C9   quackterm.psm
   div_loop                      5CE   quackterm.psm
   div_restore                   5D3   quackterm.psm
   div_shifts                    5D6   quackterm.psm
   delay_100ms                   5DC   quackterm.psm
   software_delay                5E0   quackterm.psm
   mult_8x8                      5E5   quackterm.psm
   mult_loop                     5E8   quackterm.psm
   no_add                        5EB   quackterm.psm
   send_integer                  5F0   quackterm.psm
   send_integer_loop             5F6   quackterm.psm
   next_int_digit                5FC   quackterm.psm
   zero_integer                  600   quackterm.psm
   print_integer                 603   quackterm.psm
   print_integer_loop            609   quackterm.psm
   next_print_digit              60F   quackterm.psm
   zero_printeger                613   quackterm.psm
   integer16_to_BCD              616   quackterm.psm
   int_to_BCD_loop               617   quackterm.psm
   divide_16bit_by_10            61D   quackterm.psm
   div10_loop                    624   quackterm.psm
   div10_restore                 629   quackterm.psm
   div10_shifts                  62C   quackterm.psm
   reset_UART_macros             632   quackterm.psm
   UART_TX                       635   quackterm.psm

      * Line label has not been referenced in any instructions.
        Hint - This may indicate unused code that could be
               removed to reduce the size of this program.



Instruction usage statistics

 Instruction    Instances

 LOAD            175
 STAR              -

 AND              35
 OR               22
 XOR               2

 ADD              69
 ADDCY            27
 SUB              63
 SUBCY            19

 TEST             34
 TESTCY            -
 COMPARE         176
 COMPARECY        14

 SL0              11
 SL1               2
 SLX               -
 SLA               2
 RL                -
 SR0              14
 SR1               -
 SRX               -
 SRA               4
 RR                -

 REGBANK           -

 INPUT            18
 OUTPUT           68
 OUTPUTK           2

 STORE           139
 FETCH           139

 DISABLE           -
 ENABLE            -
 RETURNI           -

 JUMP            295
 JUMP@             -
 CALL            189
 CALL@             1
 RETURN           78
 LOAD&RETURN      23

 HWBUILD           -



End of KCPSM6 log file.
